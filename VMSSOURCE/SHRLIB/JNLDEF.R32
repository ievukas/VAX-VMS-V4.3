! 
! ****************************************************************************
! *									    *
! *  Copyright (c) 1982, 1983		                                    *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.			    *
! * 									    *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.							    *
! * 									    *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.							    *
! * 									    *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.		    *
! *									    *
! ****************************************************************************
! *********************************************************************************************************************************
!  Created 15-SEP-1984 22:42:27  by  VAX-11 SDL V2.0       Source: 15-SEP-1984 22:41:33 _$255$DUA28:[CJFV4.SRC]JNLDEF.SDL;1        
! *********************************************************************************************************************************
 
 
!*** MODULE $CJFDEF ***
! 
! ++
! 
!  CJF-flags, specified to CJF services as parameters
!  and CJF constants used internally in CJF and in the user interface
! 
! --
literal CJF$_RU = 1;                    !  RU journal
literal CJF$_BI = 2;                    !  BI journal
literal CJF$_AI = 3;                    !  AI journal
literal CJF$_AT = 4;                    !  AT journal
literal CJF$_CL = 5;                    !  CL journal
literal CJF$M_PHASE1 = 1;
literal CJF$M_PHASE2 = 2;
literal CJF$M_MARK = 4;
literal CJF$M_FORWARD = 8;
literal CJF$M_BACKWARD = 16;
literal CJF$M_ABORT = 32;
literal CJF$M_READ = 64;
literal CJF$M_WRITE = 128;
literal CJF$M_DELFIL = 256;
literal CJF$M_CONT = 512;
literal CJF$M_INIT = 1024;
literal CJF$M_DRVWT = 2048;
literal CJF$M_UNIT = 4096;
literal CJF$M_NOUNLOAD = 8192;
literal CJF$M_SUPERSEDE = 16384;
literal CJF$M_RESIDUAL = 32768;
literal CJF$M_SAVFIL = 65536;
literal CJF$M_DISCONNECT = 131072;
literal CJF$M_NOLOOKUP = 262144;
literal CJF$M_ADDFILTER = 524288;
literal CJF$M_DELFILTER = 1048576;
literal CJF$M_COMPLETED = 2097152;
literal CJF$M_RESET = 4194304;
literal CJF$M_REMOUNT = 8388608;
literal CJF$M_FORCE = 16777216;
literal CJF$M_RESTART = 33554432;
literal CJF$M_FAILOVER = 67108864;
literal CJF$M_LOG = 134217728;
literal CJF$M_MERGE = 268435456;
literal CJF$M_LOGOBJ = 536870912;
literal CJF$M_ROOTDEV = 1073741824;
literal CJF$M_RCP = -2147483648;
literal CJF$C_ABENUM = 8;               !  Number of ABEs allocated per ABL 
literal CJF$C_BUFIOMAX = 200;           !  Max size buffer for which BIO done
literal CJF$C_DEFBUFSIZ = 512;          !  default buffer size in bytes
literal CJF$C_INITADBNUM = 8;           !  inial number of ADBs per ADL
literal CJF$C_MAXATTR = 27;             !  Max number of attributes returned 
!   with read.
literal CJF$C_MAXBUFSIZ = 20;           !  max buffer size in 512 b. blocks
literal CJF$C_MAXCOPIES = 1;            !  Max number of journal copies allowed
literal CJF$C_MAXFILLEN = 255;          !  max file length
literal CJF$C_MAXFILT = 512;            !  Max filter size
literal CJF$C_MAXITEMS = 21;            !  Max number of items in items list for MOUNT
literal CJF$C_MAXJNLS = 30;             !  max number of journals on one tape group
literal CJF$C_MAXAIJNL = 31;            !  max AI journals that can be accessed
literal CJF$C_MAXBIJNL = 31;            !  max BI journals that can be accessed
literal CJF$C_MAXRUJNL = 31;            !  max RU journals that can be accessed
literal CJF$C_MAXRECSIZ = 32767;        !  max journal entry size
literal CJF$C_MAXSPLFIL = 5;            !  max number of spool files
literal CJF$C_MAXTBUFSZ = 2048;         !  max size journal tape buffer in bytes
literal CJF$C_MAX_STAGE = 15;           !  max number of next stage macros in
!   one routine
literal CJF$C_MAX_DATA_AREA = 180;      !  max bytes of next stage 
!  data allowed in one routine
literal CJF$C_MXDEVNAML = 20;           !  maximum length device name
literal CJF$C_MXGRPNAML = 15;           !  maximum group name length
literal CJF$C_MXITEMLEN = 20;           !  max length item in item list for MOUNT
literal CJF$C_MXJNLNAML = 16;           !  max length journal name
literal CJF$C_MXLENATR = 20;            !  Max length attribute field
literal CJF$C_MXLENFIL = 64;            !  Max length filter element
literal CJF$C_MXPRCNAML = 15;           !  Max length process name string
literal CJF$C_MXSGBLEN = 255;           !  Max SGB field length
literal CJF$C_NUMVLE = 8;               !  initial and incremental number of VLEs
literal CJF$C_RDBUFMAX = 512;           !  Max buffer that can be used for reading
literal CJF$C_RUFIMPSIZ = 3000;         !  RUF impure area size
literal CJF$C_RULINC = 5;               !  RUL increment: number of RUEs added
!   when RUL is full
literal CJF$C_RUDLEN = 1;               !  Starting number of RUEs in RUL
literal CJF$C_SGBSTART = 128;           !  Starting number for SGB codes
literal CJF$C_ACPUIC = 65539;           !  ACP's UIC ([1,3])
literal CJF$C_MAXZFBUF = 127;           !  Max size buf for 0-filling jnl file
! +
! 
!  Definitions for codes indicating the type of RU-control entry.
! 
! -
literal CJF$C_PHASE1 = 1;               !  phase1 entry
literal CJF$C_PHASE2 = 2;               !  phase2 entry
literal CJF$C_ABORT = 3;                !  abort entry
literal CJF$C_MARK = 4;                 !  mark point entry
literal CJF$C_RESET = 5;                !  reset entry
literal CJF$C_COMPLETED = 6;            !  completed entry
literal CJF$C_RESIDUAL = 7;             !  residual entry
literal CJF$C_CLEANUP = 8;              !  cleanup entry
! +
! 
!  Definitions for Recovery Control Process and Recovery Routines
! 
!  Miscellaneous constants
! -
literal RCP$K_LOGLENGTH = 512;          !  max length of log mbx msg
! +
!  Offsets to argument list supplied to Recovery Routines by the RCP.
! -
literal RCPARG$_COMMAND = 4;            !  Command code defines type of call (see below)
literal RCPARG$_RRP = 8;                !  Address of Recovery Request Packet
literal RCPARG$_JEN = 12;               !  Address of Journal ENtry 
literal RCPARG$_IMPURE = 16;            !  Address of RR-supplied impure data area
literal RCPARG$_ASTADR = 20;            !  Address of RCP-supplied AST for asynch op's
literal RCPARG$_CALLBAK = 24;           !  Address of RCP-supplied callback routine 
! +
!  Command codes for Recovery Routines within Recovery Control Process
!  (RCPARG$_COMMAND).
! -
literal RCP$K_START = 1;                !  Start of Recovery Operation
literal RCP$K_PROCESS = 2;              !  Process a Journal Entry
literal RCP$K_END = 3;                  !  End of Recovery Operation
literal RCP$K_MAP_ENTRY = 4;            !  Process Journal Entry as Mapping Entry
literal RCP$K_LOCK_ENTRY = 5;           !  Lock a Journal Entry
literal RCP$K_ABORT = 6;                !  Abort a Recovery Operation
literal RCP$K_NOPR_ENTRY = 7;           !  Process Journal Entry; caller lacks privs
literal RCP$K_LOG_OBJECT = 8;           !  Return log information about OBJECT_ID entry
literal RCP$K_DIRECTION = 9;            !  Request direction to roll Phase 1 RU
literal RCP$K_LASTPLUS1 = 10;           !   *** Insert new entries before this ***
literal RCP$K_MAX_COMMAND = 9;          !  Adjust back
! +
!  Codes to pass as P1 to RCPARG$_CALLBAK (RCP callback routine).
! -
literal RCP$K_WAIT = 64;                !  Wait for AST (no additional arguments)
literal RCP$K_FADD = 65;                !  Add Filter (P2=Address of filter list)
literal RCP$K_FDEL = 66;                !  Delete Filter (P2=Address of filter list)
literal RCP$K_LOGMSG = 67;              !  Log Message (P2=Address of message descr.)
literal RCP$K_MESSAG = 68;              !  Other message (P2=Addr of msg descr.)
literal CJF$S_$CJFDEF = 4;
macro CJF$R_CJFMASKS = 0,0,32,0 %;
literal CJF$S_CJFMASKS = 4;             !  define CJF masks
macro CJF$V_PHASE1 = 0,0,1,0 %;         !  do phase 1
macro CJF$V_PHASE2 = 0,1,1,0 %;         !  do phase 2
macro CJF$V_MARK = 0,2,1,0 %;           !  make mark point
macro CJF$V_FORWARD = 0,3,1,0 %;        !  read in fifo order
macro CJF$V_BACKWARD = 0,4,1,0 %;       !  read in lifo order
macro CJF$V_ABORT = 0,5,1,0 %;          !  abort RU
macro CJF$V_READ = 0,6,1,0 %;           !  read indicator
macro CJF$V_WRITE = 0,7,1,0 %;          !  write indicator
macro CJF$V_DELFIL = 0,8,1,0 %;         !  delete file flag
macro CJF$V_CONT = 0,9,1,0 %;           !  continue: used with MNTJMD
macro CJF$V_INIT = 0,10,1,0 %;          !  initialize flag: with MNTJMD
macro CJF$V_DRVWT = 0,11,1,0 %;         !  driver-wait flag
macro CJF$V_UNIT = 0,12,1,0 %;          !  only specified units to be effected
macro CJF$V_NOUNLOAD = 0,13,1,0 %;      !  no-unload of medium/media
macro CJF$V_SUPERSEDE = 0,14,1,0 %;     !  supersede flag
macro CJF$V_RESIDUAL = 0,15,1,0 %;      !  This is a residual entry indicator
macro CJF$V_SAVFIL = 0,16,1,0 %;        !  save file flag
macro CJF$V_DISCONNECT = 0,17,1,0 %;    !  Disconnect label/uic pair
macro CJF$V_NOLOOKUP = 0,18,1,0 %;      !  Do not perform known journal
macro CJF$V_ADDFILTER = 0,19,1,0 %;     !  Add filter ($MODFLT)
macro CJF$V_DELFILTER = 0,20,1,0 %;     !  Delete filter ($MODFLT)
macro CJF$V_COMPLETED = 0,21,1,0 %;     !  RU completed successfully
macro CJF$V_RESET = 0,22,1,0 %;         !  RU was reset to mark (ID in attributes)
macro CJF$V_REMOUNT = 0,23,1,0 %;       !  Recovery for volume mount
macro CJF$V_FORCE = 0,24,1,0 %;         !  Modifier for Forward/Backward
macro CJF$V_RESTART = 0,25,1,0 %;       !  Restart frozen REMOUNT recovery op
macro CJF$V_FAILOVER = 0,26,1,0 %;      !  Failover RUs for remastered journal
macro CJF$V_LOG = 0,27,1,0 %;           !  RECOVER/LOG request
macro CJF$V_MERGE = 0,28,1,0 %;         !  Merge new facility with RCP
macro CJF$V_LOGOBJ = 0,29,1,0 %;        !  Request list of frozen objects
macro CJF$V_ROOTDEV = 0,30,1,0 %;       !  Indicating root RU journal or not
macro CJF$V_RCP = 0,31,1,0 %;           !  Service call coming from the RCP
!   lookup in $ASSJNL
!  Note: all previous bits must go
!   in first word
!  Note: all previous bits must go
!   in first byte
 
!*** MODULE $WRFLGDEF ***
! ++
! 
!  WRFLG - Flags supplied with $WRITEJNL
! 
!  These flags may be supplied with a call to $WRITEJNL to accompany the
!  journal entry. The flags may later be read as an attribute (JATR$C_ENTATR) of
!  the journal entry via $READJNL or may be used as a filter (JFCB$C_ENTATR) to
!  $POSJNL to select flagged journal entries.
! 
! --
literal WRFLG$M_AI = 1;
literal WRFLG$M_BI = 2;
literal WRFLG$M_RUALSO = 4;
literal WRFLG$M_OBJECT_ID = 8;
literal WRFLG$M_LOCK = 16;
literal WRFLG$S_$WRFLGDEF = 1;
macro WRFLG$R_WRFLG = 0,0,8,0 %;
literal WRFLG$S_WRFLG = 1;              !  define CJF masks
macro WRFLG$V_AI = 0,0,1,0 %;           !  This is a roll forward (AI) entry
macro WRFLG$V_BI = 0,1,1,0 %;           !  This is a roll back (BI) entry
macro WRFLG$V_RUALSO = 0,2,1,0 %;       !  This AI/BI entry also written to RUJ
macro WRFLG$V_OBJECT_ID = 0,3,1,0 %;    !  This entry identifies an object
macro WRFLG$V_LOCK = 0,4,1,0 %;         !  This entry contains locking info
 
!*** MODULE $WRMODDEF ***
! ++
! 
!  WRMOD - Modifiers supplied with $WRITEJNL
! 
!  These flags may be supplied with a call to $WRITEJNL to modify the write 
!  QIO.  They are defined to have the same values as the corresponding IO
!  modifiers.
! 
! --
literal WRMOD$M_FORCE = 64;
literal WRMOD$M_CNTRLENTRY = 128;
literal WRMOD$S_$WRMODDEF = 1;
macro WRMOD$R_WRMOD = 0,0,8,0 %;
literal WRMOD$S_WRMOD = 1;              !  define write modifier masks
!  defined values agree with IO$DEF.
macro WRMOD$V_FORCE = 0,6,1,0 %;        !  Force entry to be written to file.
macro WRMOD$V_CNTRLENTRY = 0,7,1,0 %;   !  This is a control entry.
 
!*** MODULE $ILEDEF ***
! 
! ++
! 
!  ILE - Item List Element for MOUNT
! 
!  The item list parameter for MOUNT consists of these items
! 
! --
literal ILE$K_LENGTH = 12;              !  length of data structure
literal ILE$C_LENGTH = 12;              !  length of data structure
literal ILE$S_$ILEDEF = 12;
macro ILE$W_BUFLEN = 0,0,16,0 %;        !  buffer length
macro ILE$W_ITEMCODE = 2,0,16,0 %;      !  item code
macro ILE$L_BUFFADDR = 4,0,32,0 %;      !  buffer address
macro ILE$L_RESLEN = 8,0,32,0 %;        !  result length (used for GETDVI)
 
!*** MODULE $JATRDEF ***
! 
! ++
! 
!  JATR - Journal Attributes 
! 
!  A READ-Journal operation ($READJNL) can also be used to get attributes
!  of the entry being read and/or attributes of the journal from which
!  reading is done. The attribute block is a vector of attribute descriptors
!  which contain attribute type and attribute size in the first longword
!  and the address of the user buffer for the attribute in the second longword.
!  The attribute block is zero ended.
! 
!  ****** WARNING ******
!    If any new attributes are added or old attributes removed make sure that
!    the constant CJF$C_MAXATTR is updated to reflect the change.
!  ****** WARNING ******
! --
literal JATR$C_CTRLBLCKSIZ = 8;         !  control block size
literal JATR$C_LENGTH = 8;
literal JATR$K_LENGTH = 8;
literal JATR$C_MIN_VAL = 3;             !  define low limit 
! +
!  Attribute codes
!  ****** WARNING ******
!    If any new attributes are added or old attributes removed make sure that
!    the constant CJF$C_MAXATTR is updated to reflect the change.
!  ****** WARNING ******
! -
literal JATR$C_TIME = 3;                !  time
literal JATR$C_ENTMOD = 4;              !  access mode of entry
literal JATR$C_JNLMOD = 5;              !  access mode for journal
literal JATR$C_SEQNO = 6;               !  sequence number of entry
literal JATR$C_ENTMASK = 7;             !  mask given to entry at write
literal JATR$C_JNLMASK = 8;             !  journal mask
literal JATR$C_JNLCRDAT = 9;            !  journal device creation date/time
literal JATR$C_FILCRDAT = 10;           !  journal file creation date/time
literal JATR$C_COPAVL = 11;             !  number of journal copies available
literal JATR$C_COPEXI = 12;             !  number of journal copies existing
literal JATR$C_ENTUIC = 13;             !  UIC of entry
literal JATR$C_JNLUIC = 14;             !  UIC of journal
literal JATR$C_ENTPROT = 15;            !  protection mask of entry
literal JATR$C_JNLPROT = 16;            !  protection mask of journal
literal JATR$C_FILSIZ = 17;             !  journal file size (disk journals only)
literal JATR$C_BIODATA = 18;            !  BIO journal entry - internal only
literal JATR$C_DIODATA = 19;            !  DIO journal entry - internal only
literal JATR$C_ENTLEN = 20;             !  entry length 
literal JATR$C_XFERCNT = 21;            !  Count of # of bytes actually transfered.
literal JATR$C_FACCOD = 22;             !  facility code
literal JATR$C_MAXENTSIZ = 23;          !  Maximum size (bytes) of a journal entry.
literal JATR$C_ENTATR = 24;             !  Journal entry attribute flags (WRFLG$...)
literal JATR$C_RUID = 25;               !  Recovery Unit ID for this entry
literal JATR$C_MARKPT = 26;             !  Markpoint ID for this entry
literal JATR$C_ENTPRUIC = 27;           !  UIC of process that wrote entry
literal JATR$C_SESSID = 28;             !  Session ID from which entry was written
literal JATR$C_BUFSIZ = 29;             !  Size of buffers for journal in 512 byte blocks
literal JATR$C_MAX_VAL = 30;            !  maximum value * MUST BE LAST ENTRY IN LIST *
!  ****** WARNING ******
!    If any new attributes are added or old attributes removed make sure that
!    the constant CJF$C_MAXATTR is updated to reflect the change.
!  ****** WARNING ******
!  attribute sizes
literal JATR$S_TIME = 8;                !  time
literal JATR$S_ENTMOD = 1;              !  access mode of entry
literal JATR$S_JNLMOD = 1;              !  access mode for journal
literal JATR$S_SEQNO = 4;               !  sequence number of entry
literal JATR$S_ENTMASK = 4;             !  mask given to entry at write
literal JATR$S_JNLMASK = 4;             !  journal mask
literal JATR$S_JNLCRDAT = 8;            !  journal device creation date/time
literal JATR$S_FILCRDAT = 8;            !  journal file creation date/time
literal JATR$S_COPAVL = 1;              !  number of journal copies available
literal JATR$S_COPEXI = 1;              !  number of journal copies existing
literal JATR$S_ENTUIC = 4;              !  UIC of entry
literal JATR$S_JNLUIC = 4;              !  UIC of journal
literal JATR$S_ENTPROT = 2;             !  protection mask of entry
literal JATR$S_JNLPROT = 2;             !  protection mask of journal
literal JATR$S_FILSIZ = 4;              !  journal file size (disk journals only)
literal JATR$S_BIODATA = 8;             !  BIO journal entry - internal only
literal JATR$S_DIODATA = 8;             !  DIO journal entry - internal only
literal JATR$S_ENTLEN = 4;              !  entry length 
literal JATR$S_XFERCNT = 4;             !  Transfer count (bytes).
literal JATR$S_FACCOD = 2;              !  facility code
literal JATR$S_MAXENTSIZ = 2;           !  Maximum size (bytes) of a journal entry.
literal JATR$S_ENTATR = 4;              !  Journal entry attribute flag
literal JATR$S_RUID = 16;               !  Recovery Unit ID
literal JATR$S_MARKPT = 4;              !  Mark point ID
literal JATR$S_ENTPRUIC = 4;            !  UIC of process that wrote entry
literal JATR$S_SESSID = 16;             !  Session ID from which entry was written
literal JATR$S_BUFSIZ = 2;              !  Buffer size in 512 byte blocks 
literal JATR$S_MAX_VAL = 1;             !  Maximum value
!  ****** WARNING ******
!    If any new attributes are added or old attributes removed make sure that
!    the constant CJF$C_MAXATTR is updated to reflect the change.
!  ****** WARNING ******
literal JATR$S_$JATRDEF = 8;
macro JATR$W_SIZE = 0,0,16,0 %;         !  size of attribute descriptor block
macro JATR$W_TYPE = 2,0,16,0 %;         !  type of attribute
macro JATR$L_ADDR = 4,0,32,0 %;         !  address user buffer for attribute
 
!*** MODULE $JFCBDEF ***
! 
! ++
! 
!  JFCB - Journal Filter Control Block
! 
!  When a POSJNL (Position Journal) is done, the caller specifies the
!  category of entries he wants to read. This is done by passing a filter.
!  The filter consists of a vector of descriptors, which have in their
!  first longword the size and type of the filter element, and in their
!  second longword the address of the user buffer containing the value of 
!  the filter element
! 
!   *** NOTE ESPECIALLY: The RUID and MARK filters are valid only for RU journals
! 			and are the ONLY filters used for RU journals;  furthermore,
! 			the RUID filter MUST be provided for RU journals.
! 
! --
literal JFCB$C_CTRLBLCKSIZ = 8;         !  control block size
literal JFCB$C_LENGTH = 8;
literal JFCB$K_LENGTH = 8;
literal JFCB$C_MIN_VAL = 64;            !  define low limit 
literal JFCB$C_UIC = 64;                !  UIC of writer of entry
literal JFCB$C_ACMODE = 65;             !  access mode from which entry was written
literal JFCB$C_FACCODE = 66;            !  facility code of of facility that wrote entry
literal JFCB$C_STRING = 67;             !  field describing: in first word offset
!   in user entry, in rest of field
!   string to match entry's subfield
literal JFCB$C_MASK = 68;               !  mask given to entry at write
literal JFCB$C_SEQNO = 69;              !  sequence number or range: lowest # for
!   reading AT and BI jnl's, highest # for
!   reading AT and AI jnl's
!   if two longwords supplied, range of sequence #s
literal JFCB$C_DATTIM = 70;             !  date time up to and/or from which to read
literal JFCB$C_RUID = 71;               !  RU identifier
literal JFCB$C_MARK = 72;               !  MARK point ID, up to which to roll back
literal JFCB$C_SESSID = 73;             !  session ID
literal JFCB$C_PID = 74;                !  Process ID
literal JFCB$C_ACTIVE = 75;             !  Describes what action to take with
!  active processes
literal JFCB$C_spare = 76;              !  	*** put next new filter here ***
literal JFCB$C_JOURNAL = 77;            !  Journal name (for RCP - not used by ACP)
literal JFCB$C_ENTATR = 78;             !  Journal entry attribute flags
literal JFCB$C_OUTRANGE = 79;           !  matches entries outside range of seq #s
literal JFCB$C_MAX_VAL = 80;            !  maximum value * MUST BE LAST ENTRY IN LIST *
literal JFCB$S_UIC = 4;                 !  UIC of writer of entry
literal JFCB$S_ACMODE = 1;              !  access mode from which entry was written
literal JFCB$S_FACCODE = 2;             !  facility code of of facility that wrote entry
literal JFCB$S_STRING = 512;            !  field describing: in first word offset
!   in user entry in second word length
!   of subfield, in rest of field
!   string to match entry's subfield
literal JFCB$S_MASK = 4;                !  mask given to entry at write
literal JFCB$S_SEQNO = 8;               !  sequence number(s)
literal JFCB$S_DATTIM = 16;             !  date time up to and/or from which to read
literal JFCB$S_RUID = 16;               !  RU identifier
literal JFCB$S_MARK = 4;                !  MARK point ID, up to which to roll back
literal JFCB$S_SESSID = 15;             !  session ID
literal JFCB$S_PID = 4;                 !  process ID
literal JFCB$S_ACTIVE = 1;              !  Active process flag
literal JFCB$S_JOURNAL = 12;            !  journal name
literal JFCB$S_ENTATR = 4;              !  Journal entry attribute flag
literal JFCB$S_OUTRANGE = 8;            !  low, high limit sequence numbers
literal JFCB$S_MAX_VAL = 4;             !  maximum value
literal JFCB$C_EXCLUDE = 0;             !  Exclude entries from active processes
literal JFCB$C_INCLUDE = 1;             !  Include entries from active processes
literal JFCB$C_NONE = 2;                !  Ignore effects of active processes
!  Special INTERNAL definitions of the JFCB structure (used by the driver
!  and the ACP only.
literal JFCB$C_DIRECT = 80;             !  The typecode for the direction flag is
!  set to the maximum type-code value.
literal JFCB$S_DIRECT = 4;              !  The size of the flag is 4 (?) bytes.
literal JFCB$S_$JFCBDEF = 12;
macro JFCB$W_SIZE = 0,0,16,0 %;         !  size of filter element descriptor block
macro JFCB$W_TYPE = 2,0,16,0 %;         !  type of filter element
macro JFCB$L_ADDR = 4,0,32,0 %;         !  address user buffer for filter element
macro JFCB$L_TERM = 8,0,32,0 %;         !  offset to terminating zero from last entry
! +
!  Filter element codes
! -
 
!*** MODULE $JNLCHARDEF ***
! 
! ++
! 
!  JNLCHAR - journal characteristics bits
! 
! --
literal JNLCHAR$M_RESWL = 1;
literal JNLCHAR$M_SEAVL = 2;
literal JNLCHAR$M_REAVL = 4;
literal JNLCHAR$S_$JNLCHARDEF = 1;
macro JNLCHAR$V_RESWL = 0,0,1,0 %;      !  reset SWL for jnl 
macro JNLCHAR$V_SEAVL = 0,1,1,0 %;      !  set def on-line again
macro JNLCHAR$V_REAVL = 0,2,1,0 %;      !  take device off-line
 
!*** MODULE $JSBDEF ***
! 
! ++
! 
!  JSB - Journal Specification Block
! 
! 	When a journal is to be created, the user must pass this 
! 	structure to the CJF $CREJNL service.
! 
! --
literal JSB$C_RU = 1;                   !  RU journal
literal JSB$C_BI = 2;                   !  BI journal
literal JSB$C_AI = 3;                   !  AI journal
literal JSB$C_AT = 4;                   !  AT journal
literal JSB$C_CL = 5;                   !  CL journal
literal JSB$C_DISK = 1;                 !    journal is on disk
literal JSB$C_TAPE = 2;                 !    journal is on tape
literal JSB$C_KERNEL = 0;               !  kernel mode
literal JSB$C_EXEC = 1;                 !  exec mode
literal JSB$C_SUPER = 2;                !  supervisor mode
literal JSB$C_USER = 3;                 !  user mode
literal JSB$M_TMPJNL = 1;
literal JSB$M_KNOWN = 2;
literal JSB$M_CREATE = 4;
literal JSB$M_CIF = 8;
literal JSB$M_TMPFIL = 16;
literal JSB$M_CREACP = 32;
literal JSB$M_DIFACP = 64;
literal JSB$M_REPLACE = 128;
literal JSB$M_TAPEDRIVE = 256;
literal JSB$M_CLUSTER = 512;
literal JSB$M_REMASTER = 1024;
literal JSB$K_LENGTH = 80;              !  length of data structure
literal JSB$C_LENGTH = 80;              !  length of data structure
literal JSB$S_$JSBDEF = 80;
macro JSB$W_JNLNAMLEN = 0,0,16,0 %;     !  length journal name
macro JSB$L_JNLNAM = 4,0,32,0 %;        !  journal name ASCII
macro JSB$B_JNLTYP = 10,0,8,0 %;        !  journal type.  can be one of:
macro JSB$B_JNLDEV = 11,0,8,0 %;        !  journal device type. can be one of:
macro JSB$L_MASK = 12,0,32,0 %;         !  journal mask
macro JSB$W_FACCOD = 16,0,16,0 %;       !  facility code (eg RMS)
macro JSB$W_APPLID = 18,0,16,0 %;       !  applications id (eg datatrieve)
macro JSB$W_MAXSIZ = 20,0,16,0 %;       !  maximum entry size
macro JSB$w_spare1 = 22,0,16,0 %;       !  spare
macro JSB$L_FILSIZ = 24,0,32,0 %;       !  blocks to initially allocate for journal file
macro JSB$W_FILEXT = 28,0,16,0 %;       !  blocks to extend journal file when full
macro JSB$W_BUFSIZ = 30,0,16,0 %;       !  buffer size (in 512 byte blocks)
macro JSB$L_QUOTA = 32,0,32,0 %;        !  byte quota (for RU journals only)
macro JSB$B_ACMODE = 36,0,8,0 %;        !  least priv access mode allowed
macro JSB$b_spare2 = 37,0,8,0 %;        !  spare (for longword alignment)
macro JSB$W_PROT = 38,0,16,0 %;         !  protection mask for journal device
macro JSB$r_uic_overlay = 40,0,32,0 %;
literal JSB$s_uic_overlay = 4;
macro JSB$L_UIC = 40,0,32,0 %;          !  UIC for journal device
macro JSB$r_uic_0 = 40,0,32,0 %;
literal JSB$s_uic_0 = 4;                !  
macro JSB$W_UIC_MBM = 40,0,16,0 %;      !    UIC member number
macro JSB$W_UIC_GRP = 42,0,16,0 %;      !    UIC group number
macro JSB$r_flags_overlay = 44,0,32,0 %;
literal JSB$s_flags_overlay = 4;
macro JSB$L_FLAGS = 44,0,32,0 %;        !  flags as follows:
macro JSB$r_flags_bits = 44,0,32,0 %;
literal JSB$s_flags_bits = 4;           !  
macro JSB$V_TMPJNL = 44,0,1,0 %;        !    temporary journal device - delete on last deaccess
macro JSB$V_KNOWN = 44,1,1,0 %;         !    site permanent journal
macro JSB$V_CREATE = 44,2,1,0 %;        !    always create file (supercedes CREATE_IF)
macro JSB$V_CIF = 44,3,1,0 %;           !    create only if file does not exist
macro JSB$V_TMPFIL = 44,4,1,0 %;        !    temporary journal file - delete when device deleted
macro JSB$V_CREACP = 44,5,1,0 %;        !    create a new ACP. OPER priv req'ed.
macro JSB$V_DIFACP = 44,6,1,0 %;        !    do not use default ACP. 
macro JSB$V_REPLACE = 44,7,1,0 %;       !    replace current journal with this
macro JSB$V_TAPEDRIVE = 44,8,1,0 %;     !    (internal only) create journal tape drive
macro JSB$V_CLUSTER = 44,9,1,0 %;       !    create the journal across
macro JSB$V_REMASTER = 44,10,1,0 %;     !    (internal only) remaster the journal
!        the cluster
!        DELETE priv required
!        ACP name in JSB is valid.
!        ACP name in JSB is valid.
!   NOTE: flags are used in prologue - 
!    must be in same places.
macro JSB$W_ACPNAMLEN = 48,0,16,0 %;    !  length prcnam string
macro JSB$W_SPARE4 = 50,0,16,0 %;       !  spare
macro JSB$L_ACPNAM = 52,0,32,0 %;       !  prcnam of alternate ACP
macro JSB$W_MAX_JNLS = 56,0,16,0 %;     !  (internal only) max jnls (if TAPEDRIVE set)
macro JSB$B_COPIES = 58,0,8,0 %;        !  number of copies
macro JSB$B_SPARE3 = 59,0,8,0 %;        !  SPARE (for longword alignment)
macro JSB$Q_EXPDAT = 60,0,0,0 %;
literal JSB$S_EXPDAT = 8;               !  expiration date (-1 = never)
!  Primary file specifications
macro JSB$L_PRINAMDES = 68,0,32,0 %;    !  address of filename descriptor list 
!  (one quadword per file) (required)
macro JSB$L_PRIRESDES = 72,0,32,0 %;    !  address of result string descriptor list 
!  (one quadword per file) (optional)
macro JSB$L_PRIRESLEN = 76,0,32,0 %;    !  address of result length list 
!  (one longword per file) (optional)
 
!*** MODULE $RODBDEF ***
! 
! ++
! 
!  RODB - Recovery Object Descriptor Block
!  
!  The RODB describes the object to recover.
! 
! --
literal RODB$K_RMSFILE = 1;             !  ...Object is an RMS file
literal RODB$K_VOLUME = 2;              !  ...Object is a volume set
literal RODB$K_RU = 3;                  !  ...Object is a Recovery Unit
literal RODB$K_RUJNL = 4;               !  ...Object is a Recovery Unit Journal
literal RODB$k_spare = 5;               !  ...RUNODE removed from here
literal RODB$K_FACCOD = 6;              !  ...Facility code for use with merge ** INTERNAL USE ONLY **
literal RODB$K_RFSAMPLE = 7;            !  ...Object is the Sample Application
literal RODB$K_LENGTH = 8;              !  Length of this structure
literal RODB$C_LENGTH = 8;              !  length of data structure
literal RODB$S_$RODBDEF = 8;
macro RODB$B_TYPE = 0,0,8,0 %;          !  Type of object described
macro RODB$B_COUNT = 1,0,8,0 %;         !  Number of attributes assoc with object
macro RODB$W_SIZE = 2,0,16,0 %;         !  Size of RODBA
macro RODB$A_POINTER = 4,0,32,0 %;      !  Address of attribute list
! 
! ++
! 
!  RODBA - Recovery Object Descriptor Block Attribute
!  
!  The RODBA describes an attribute associated with the object of recovery.
! 
! --
literal RODBA$K_LENGTH = 8;             !  Length of this structure
literal RODBA$C_LENGTH = 8;             !  length of data structure
! +
!  Define attributes for RMS object attributes
! -
literal RODBA$K_FILENAME = 1;           !  File name to recover
literal RODBA$K_CFILENAME = 2;          !  File name to create and recover
! +
!  Define attributes for Volume Recovery attributes
! -
literal RODBA$K_VOLDEVICE = 3;          !  Volume device name
literal RODBA$K_VOLLABEL = 4;           !  Volume label
! +
!  Define attributes for RU attributes
! -
literal RODBA$K_RUID = 5;               !  Recovery Unit ID
! +
!  Define attributes for RUJNL attributes
! -
literal RODBA$K_RUJDEVNAM = 6;          !  Device name of RU journal
! +
!  Define attributes for failed node (PROCESSOR) attributes
! -
literal RODBA$K_NODE_ID = 7;            !  Node ID of failed node
! +
!  Define attribute for facility code to be used with merge command.
! -
literal RODBA$K_FACCOD = 8;             !  Facility code *** INTERNAL USE ONLY ***
! +
!  End of definitions
! -
literal RODBA$S_$RODBADEF = 8;
macro RODBA$B_TYPE = 0,0,8,0 %;         !  Type of object described
macro RODBA$b_spare = 1,0,8,0 %;        !  Spare
macro RODBA$W_SIZE = 2,0,16,0 %;        !  Size of attribute
macro RODBA$A_POINTER = 4,0,32,0 %;     !  Pointer to attribute
 
!*** MODULE $RRPDEF ***
! 
! ++
! 
!  RRP - Recovery Request Packet
! 
!  When a recovery is to be performed a Recovery Request Packet must
!  be sent to the RCP that describes the caller, the object to be 
!  recovered and the type of recovery.
! 
! --
literal RRP$M_RECOVERY = 1;
literal RRP$M_MERGE = 2;
literal RRP$M_FORWARD = 4;
literal RRP$M_BACK = 8;
literal RRP$M_RECOVERY_UNIT = 16;
literal RRP$M_REMOUNT = 32;
literal RRP$M_FORCE = 64;
literal RRP$M_LOG = 128;
literal RRP$M_FAILOVER = 256;
literal RRP$M_RESTART = 512;
literal RRP$K_MBX_SIZE = 512;           !  Size of status MBX to create
literal RRP$K_FIXED = 58;               !  Size of fixed portion of RRP
literal RRP$S_$RRPDEF = 59;
macro RRP$A_FLINK = 0,0,32,0 %;         !  Forward Link
macro RRP$A_BLINK = 4,0,32,0 %;         !  Backward Link
macro RRP$W_SIZE = 8,0,16,0 %;          !  Actual allocation size (in RCP)
macro RRP$B_TYPE = 10,0,8,0 %;          !  Structure type
macro RRP$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype
macro RRP$r_flags_overlay = 12,0,16,0 %;
literal RRP$s_flags_overlay = 2;
macro RRP$W_FLAGS = 12,0,16,0 %;        !  Request flags:
macro RRP$r_flags_bits = 12,0,16,0 %;
literal RRP$s_flags_bits = 2;           !  
macro RRP$V_RECOVERY = 12,0,1,0 %;      !  If set, start Recovery Operation
macro RRP$V_MERGE = 12,1,1,0 %;         !  If set, merge in new facility
macro RRP$V_FORWARD = 12,2,1,0 %;       !  Roll-forward operation
macro RRP$V_BACK = 12,3,1,0 %;          !  Roll-back operation
macro RRP$V_RECOVERY_UNIT = 12,4,1,0 %; !  Process a Recovery Unit
macro RRP$V_REMOUNT = 12,5,1,0 %;       !  Process a Recovery Unit Journal
macro RRP$V_FORCE = 12,6,1,0 %;         !  Process a frozen Recovery Unit
macro RRP$V_LOG = 12,7,1,0 %;           !  Log recovery events
macro RRP$V_FAILOVER = 12,8,1,0 %;      !  Failover of RUs from failed node in cluster
macro RRP$V_RESTART = 12,9,1,0 %;       !  Restart of frozen REMOUNT
!  ..for BI, roll back over RUALSO entries for
!  ..successful RUs.
!  These flags apply only to RECOVERY
!  These two flags are exclusive
macro RRP$W_FACNO = 14,0,16,0 %;        !  Facility number (RRP$M_MERGE only)
macro RRP$Q_TIME = 16,0,0,0 %;
literal RRP$S_TIME = 8;                 !  Time of request
macro RRP$Q_CALL_PRIV = 24,0,0,0 %;
literal RRP$S_CALL_PRIV = 8;            !  Privilege mask of CALLER
macro RRP$L_CALL_PID = 32,0,32,0 %;     !  CALLER's process ID (EPID form)
macro RRP$L_CALL_UIC = 36,0,32,0 %;     !  UIC of calling process
macro RRP$L_CALL_NODE = 40,0,32,0 %;    !  CSID of CALLER 
macro RRP$B_CALL_AMOD = 44,0,8,0 %;     !  Access mode of CALLER
macro RRP$B_CALL_MSG = 45,0,8,0 %;      !  CTL$GB_MSGMASK of CALLER
macro RRP$A_FILTER = 46,0,32,0 %;       !  Address of filter descr part of RRP
macro RRP$A_RODB = 50,0,32,0 %;         !  Address of RODB descr part of RRP
macro RRP$W_MBX_UNIT = 54,0,16,0 %;     !  Status MBX unit number
macro RRP$W_LOG_UNIT = 56,0,16,0 %;     !  Logging MBX unit number
macro RRP$AB_WORK = 58,0,8,1 %;         !  Start of RODBs, filters, and Journals
 
!*** MODULE $RUSDEF ***
! 
! ++
! 
!  RUS - List of recovery units as returned from IO$_RUCNTR ! IO$M_RUIDLIST OR ! RUJLIST
! 
!  This structure is used to return the list of recovery units outstanding
!  in a recovery unit to which the RUCNTR operation is done. This is an
!  internal QIO - not available to users, so this data structure is for
!  internal purposes only.
! 
!  NOTE that the status bit definitions must be the same as those for RUE.
! 
! --
literal RUS$M_PURGED = 1;
literal RUS$M_ROLL_BACK = 2;
literal RUS$M_ROLL_FORW = 4;
literal RUS$M_NOT_FLSHD = 8;
literal RUS$M_OVER_QUOTA = 16;
literal RUS$M_PHASE1 = 32;
literal RUS$M_PHASE2 = 64;
literal RUS$M_ABORT = 128;
literal RUS$M_P2$AB$2 = 256;
literal RUS$M_RESIDUAL = 512;
literal RUS$M_COMPLETED = 1024;
literal RUS$M_CLEANUP = 2048;
literal RUS$M_FROZEN = 4096;
literal RUS$M_RUSYNCEX = 8192;
literal RUS$M_RUSYNCWR = 16384;
literal RUS$M_NOFAC = 32768;
literal RUS$M_NOOBJ = 65536;
literal RUS$K_LENGTH = 48;              !  length of structure
literal RUS$C_LENGTH = 48;              !  length of structure
literal RUS$S_$RUSDEF = 48;
macro RUS$O_RUID = 0,0,0,0 %;
literal RUS$S_RUID = 16;                !  Recovery Unit ID
macro RUS$L_SEQNO = 16,0,32,0 %;        !  sequence number last entry written 
macro RUS$W_JNLCNT = 20,0,16,0 %;       !  count of journals touched by RU
macro RUS$w_spare1 = 22,0,16,0 %;       !  Spare word to keep longword boundary
macro RUS$L_INDEX = 24,0,32,0 %;        !  unique short RUE index
macro RUS$r_status_overlay = 28,0,32,0 %;
literal RUS$s_status_overlay = 4;
macro RUS$L_STATUS = 28,0,32,0 %;       !  status of the Recovery Unit
macro RUS$r_status_bits = 28,0,32,0 %;
literal RUS$s_status_bits = 4;
macro RUS$V_PURGED = 28,0,1,0 %;        !  entry is free indicator 
macro RUS$V_ROLL_BACK = 28,1,1,0 %;     !  there is at least one roll back entry 
macro RUS$V_ROLL_FORW = 28,2,1,0 %;     !  there is at least one roll forward entry 
macro RUS$V_NOT_FLSHD = 28,3,1,0 %;     !  there is at least one entry not flushed 
macro RUS$V_OVER_QUOTA = 28,4,1,0 %;    !  quota exceeded 
macro RUS$V_PHASE1 = 28,5,1,0 %;        !  phase1 done 
macro RUS$V_PHASE2 = 28,6,1,0 %;        !  phase2 done 
macro RUS$V_ABORT = 28,7,1,0 %;         !  abort done 
macro RUS$V_P2$AB$2 = 28,8,1,0 %;       !  phase2 or abort entry to be encountered 2* 
macro RUS$V_RESIDUAL = 28,9,1,0 %;      !  this is a residual RU in journal 
macro RUS$V_COMPLETED = 28,10,1,0 %;    !  RU has been completed (rolled forward) 
macro RUS$V_CLEANUP = 28,11,1,0 %;      !  vestigial entry for RU can be ignored 
macro RUS$V_FROZEN = 28,12,1,0 %;       !  frozen RU 
macro RUS$V_RUSYNCEX = 28,13,1,0 %;     !  RUSYNC entry expected
macro RUS$V_RUSYNCWR = 28,14,1,0 %;     !  RUSYNC entry written
macro RUS$V_NOFAC = 28,15,1,0 %;        !  Frozen due to missing facility
macro RUS$V_NOOBJ = 28,16,1,0 %;        !  Frozen due to missing object
!   before RU deletion
macro RUS$T_DEVNAM = 32,0,0,0 %;
literal RUS$S_DEVNAM = 16;              !  Counted ASCII device name
 
!*** MODULE $JENDEF ***
! 
! +
!  JEN - Journal Entry
! 
!  Contains a pointer to the journal entry, plus related attributes as 
!  returned by the JACP and passed to the recovery routines by the RCP. 
! -
literal JEN$K_LENGTH = 87;              !  length of data structure
literal JEN$S_$JENDEF = 87;
macro JEN$A_FLINK = 0,0,32,0 %;         !  Forward link
macro JEN$A_BLINK = 4,0,32,0 %;         !  Backward link
macro JEN$Q_TIME = 8,0,0,0 %;
literal JEN$S_TIME = 8;                 !  System time of journal entry
macro JEN$W_FACNO = 16,0,16,0 %;        !  Facility number of writer of journal entry
macro JEN$B_DIRECTION = 18,0,8,0 %;     !  Direction of recovery
macro JEN$B_TYPE = 19,0,8,0 %;          !  Type of journal (DT$_...)
macro JEN$L_SEQNO = 20,0,32,0 %;        !  Senquence number of journal entry
macro JEN$B_ENTMOD = 24,0,8,0 %;        !  Access mode of journal entry
macro JEN$B_JNLMOD = 25,0,8,0 %;        !  Access mode of journal
macro JEN$L_ENTUIC = 26,0,32,0 %;       !  UIC of journal entry
macro JEN$L_JNLUIC = 30,0,32,0 %;       !  UIC of journal
macro JEN$W_ENTPROT = 34,0,16,0 %;      !  Protection mask of journal entry
macro JEN$W_JNLPROT = 36,0,16,0 %;      !  Protection mask of journal
macro JEN$L_ENTATR = 38,0,32,0 %;       !  Journal entry attribute flags
macro JEN$r_ruidblock = 42,0,0,0 %;
literal JEN$s_ruidblock = 16;           !  Recovery Unit ID
macro JEN$O_RUID = 42,0,0,0 %;
literal JEN$S_RUID = 16;
macro JEN$L_MARKPT = 58,0,32,0 %;       !  MARKpointID for MARK/RESET control entries
macro JEN$W_CHANNEL = 62,0,16,0 %;      !  Channel assigned to journal
macro JEN$T_JNLNAME = 64,0,0,0 %;
literal JEN$S_JNLNAME = 13;             !  Journal name, counted ASCII string
macro JEN$W_ENTSIZE = 77,0,16,0 %;      !  Length of journal entry in bytes
macro JEN$A_ENTRY = 79,0,32,0 %;        !  Address of Journal Entry buffer
macro JEN$L_IOSB_DATA = 83,0,32,0 %;    !  copy of JLE second longword (RCP use only)
 
!*** MODULE $SGBDEF ***
! 
! ++
! 
!  SGB - Shadow Group Block
! 
! 	When a shadow group is mounted the user must pass this 
! 	structure to the CJF $MNTJMD service. This is a list of
! 	descriptors like the item list, which must be zero ended.
! 
! --
literal SGB$M_INIT = 1;
literal SGB$S_$SGBBIT = 1;
macro SGB$V_INIT = 0,0,1,0 %;           !  bits defined for FLAGS
literal SGB$C_GRPNAME = 255;            !  group logical name
literal SGB$C_COPIES = 254;             !  # of spool files
literal SGB$C_PROT = 253;               !  protection mask for shadow group
literal SGB$C_MAX_JNLS = 252;           !  max journals allowed in shadow group
literal SGB$C_FLAGS = 251;              !  flags 
literal SGB$C_UIC = 250;                !  uic for shadow group
literal SGB$C_SPLFILSIZ = 249;          !  blocks to allocate for spool file
literal SGB$C_SPLNAM = 248;             !  Spool file name
literal SGB$C_SPLRESNAM = 247;          !  Result spool file name
literal SGB$C_SPLRESLEN = 246;          !  Result spool file name length
literal SGB$C_MAX_VAL = 245;
literal SGB$K_LENGTH = 12;              !  Length of this structure
literal SGB$C_LENGTH = 12;              !  length of data structure
literal SGB$S_$SGBDEF = 12;
macro SGB$W_SIZE = 0,0,16,0 %;          !  size of field descriptor block
macro SGB$W_TYPE = 2,0,16,0 %;          !  type of SGB field
macro SGB$L_ADDR = 4,0,32,0 %;          !  address user buffer for attribute
macro SGB$L_SPARE = 8,0,32,0 %;         !  spare
! +
!  SGB codes
! -
 
!*** MODULE $CNVDEF ***
! +
!  Definitions for the create new version item list codes
! -
literal CNV$M_CLOSE = 1;
literal CNV$_MIN_VAL = 1;
literal CNV$_CURDEVNAM = 1;             !  Current journal copy device name
literal CNV$_NEWDEVNAM = 2;             !  Device name for new version of journal copy
literal CNV$_NEWVER = 3;                !  Version number for new version of copy
literal CNV$_FILDEVNAM = 4;             !  Device name for copy to connect/disconnect
literal CNV$_FILNAM = 5;                !  File name for copy to connect/disconnect
literal CNV$_FILVER = 6;                !  Version number for copy to connect/disconnect
literal CNV$_OLDFILNAM = 7;             !  File name for create new version rename
literal CNV$_ALQ = 8;                   !  Allocation quantity for new version
literal CNV$_FLAGS = 9;                 !  Flags
literal CNV$_IOSB = 10;                 !  Secondary status from create new version
literal CNV$_NVRSA = 11;                !  Result buffer address for new version spec.
literal CNV$_NVRSL = 12;                !  Result buffer size for new version file spec.
literal CNV$_OVRSA = 13;                !  Result buffer address for old version spec.
literal CNV$_OVRSL = 14;                !  Result buffer size for old version file spec.
literal CNV$_MAX_VAL = 14;
literal CNV$S_CNVDEF = 1;
macro CNV$R_CNVDEF_BITS = 0,0,8,0 %;
macro CNV$V_CLOSE = 0,0,1,0 %;
 
!*** MODULE $CJIDEF ***
! +
!  Definitions for the $GETCJI service item codes
! -
literal CJI$_MIN_VAL = 1;
literal CJI$_FILDSKNAM = 1;             !  Get the journal file disk name
literal CJI$_MAX_VAL = 1;
literal CJI$S_CJIDEF = 0;
