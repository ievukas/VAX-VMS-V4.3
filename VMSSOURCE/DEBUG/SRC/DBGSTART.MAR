	.TITLE	DBGSTART
	.IDENT	'V04-000'


;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: DEBUG
;
; ABSTRACT: 
;	Start-up module for DEBUG facility.
;
; ENVIRONMENT:
;	VAX/VMS User mode : Mapped and entered initially from the CLI. From
;	then on DEBUG runs as a (very complex) exception handler.
;
; VERSION:	4.00
;

; REVISION HISTORY:
;
;
;	MODIFIED BY:
;		John Francis, 30 November 1981
;		V. Holt, 2 June 1982
;		P. Sager, Oct. 1982
;		P. Sager, Aug. 1983
;+
; 1.01	05-OCT-78	DAR	Fixed bug in the way WINDOW_2 returns to VMS.
; 1.02	20-OCT-78	MCC	Changed size of writable storage to be
;				calculated at link time.
; 1.03	24-OCT-78	DAR	PROBER transfer address before initializing
;				the PSL's IV and DV bits.
; 1.04	10-NOV-78	DAR	Added routine DBG$THREAD_BPT for threaded BPT's.
; 1.05	07-DEC-78	DAR	Fixed exit handler to exit if SS$_CLIFRCEXT.
; 1.06	18-DEC-78	DAR	Added global label to threaded breakpoint routine
;				to enable "GO %line x" to work in threaded code.
; 1.07	23-MAR-79	MCC	Modified dbg$out_message to write error messages
;				to the LOG file
; 1.08	 6-AUG-79	MCC	Modified dbg$final_handl to check for error msgs
;				from shared msg file, before signaling "internal
;				DEBUG coding error"
; 1.09	 5-SEP-79	MCC	Made a fix to toggle system service failure
;				mode when user program has set it and DEBUG 
;				gets control
; 1.10	 7-APR-81	JF	Signal DBG$_SUPERDEBUG if testable debugger
;				and any unexpected errors are encountered
; 3.00	30-NOV-81	JF	Tidy up entry and exit sequences to fix bugs
;				with AST's and user termination handlers.
; 3.10   2-Jun-82	VJH	Removed all references to DBG$FAO_PUT and
;				DBG$OUT_PUT, as these routines are now obsolete.
;				Replaced them with calls to DBG$PRINT and
;				DBG$NEWLINE, respectively.
; 3.B0   12-Oct-82      PS      Added some code to DBG$PSEUDO_HANDLER to
;				release all the memory blocks for CALL command
; 3.B1	18-Jan-83	JF	Added DBG$GV_CONTROL state vector and modified
;				handling of 'SS$_DEBUG' exception.
; 4.0   31-Aug-83       PS      Fixed a read error infinite loop reported by
;                               user through SPR.  Set up a count in
;				DBG$COMMAND_PROC (DBGEXC), If we get bad
;				status from $GET/Key Pad input, after 20
;				tries, we'll force the DEBUG to take EXIT.
;				(See code added in DBG$FINAL_HANDL, label
;				 FINAL_7).
; 4.0   01-Feb-84       PS      Added SSI for watch pointing
;--

	.SBTTL	DECLARATIONS

; *****SSI
; SSI_USS is a privileged shareable image to set up system service 
; interception for watch pointing.  It must be installed in SYS$LIBRARY.
; DEBUG can link with/without SSI_USS on VMS V4, indicated by link flag
; DBG$GL_3B_SYSTEM and DBG$GL_SETSSI.  DBG$GL_3B_SYSTEM must be set to 1
; to indicate VMS V4 system, DBG$GL_SETSSI must be set to 1 to indicate to
; link with SSI_USS, set to 0 to indicate to link without SSI_USS.  On VMS
; V3 system, DBG$GL_3B_SYSTEM must be set to 0, there is no SSI_USS active.
; In this way, DEBUG will work both ways on VMS V4 and VMS V3.  Declare
; SSI_USS to be weak reference, so that we won't get linker warnings at
; link time.
    	.WEAK   SSI_USSK
    	.WEAK   SSI_USSU
    	.EXTRN	DBG$GL_3B_SYSTEM,DBG$GL_SETSSI
	.EXTRN	DBG$GL_INPRAB,DBG$GL_OUTPRAB,DBG$RUNFRAME,DBG$GV_CONTROL
	.EXTRN	DBG$GB_CALL_NORMAL_RET,DBG$SCR_SCREEN_TERM,PRT$C_UW
	.EXTRN	DBG$END_OF_LINE,DBG$EXC_HANDLER,DBG$PRINT,DBG$RST_INIT
	.EXTRN	DBG$REL_MEMORY,DBG$INIT_DEBUG,DBG$OUT_NUM_VAL,DBG$NEWLINE
	.EXTRN	DBG$PUTMSG,DBG$INS_OPCODES,LIB$SIGNAL,SYS$DCLEXH,SYS$EXIT
	.EXTRN	SYS$GETMSG,SYS$PUT,SYS$SETAST,SYS$SETPRT,SYS$UNWIND
	.EXTRN	DBG$GL_LOGRAB,DBG$GB_DEF_OUT,DBG$FLUSHBUF,DBG$GB_UNHANDLED_EXC
    	.EXTRN	EVENT$PAGE_QUEUE

;
; invoke data definitions
;
	$CHFDEF			; Condition handler mnemonics
	$CLIDEF			; CLI status bit definitions
	$DBGDEF			; Debug definitions
	$IFDDEF			; Image file definitions
	$PSLDEF			; Processor Status Longword bits
	$RABDEF			; RAB definitions
	$SFDEF			; Stack Frame offset definitions
	$SHRDEF			; Shared error messages
	$SSDEF			; System error codes
	$STSDEF			; Status code fields
;
; Equated symbols
;
	buf_siz		= 256		; length of getmsg, FAO, and $PUT buffers
	dbg_facility	= 2		; DEBUG facility code.

; *****SSI
; SSI_USS can be called by the user, or by the DBG (TDBG), or by the SDBG.
; Each level (user, DBG/TDBG, SDBG) delcares a interception routine which
; runs at a priority (user - priority 1, 2, DBG/TDBG - priority 3, SDBG -
; priority 4).  This vector is used to indicate which priority is active
; at the moment.
;
;       Definitions of bits in DBG$GV_SSI_CONTROL running state vector
;
    	dbg$v_ssi_routine_1 = 0         ; Set if user declared prio. 1 routine
    					;  is running
    	dbg$m_ssi_routine_1 = 1@dbg$v_ssi_routine_1

    	dbg$v_ssi_routine_2 = 1         ; Set if user declared prio. 2 routine
    					;  is running
    	dbg$m_ssi_routine_2 = 1@dbg$v_ssi_routine_2

    	dbg$v_ssi_routine_3 = 2         ; Set if user declared prio. 3 routine
    					;  is running
    	dbg$m_ssi_routine_3 = 1@dbg$v_ssi_routine_3

    	dbg$v_ssi_routine_4 = 3         ; Set if user declared prio. 4 routine
    					;  is running
    	dbg$m_ssi_routine_4 = 1@dbg$v_ssi_routine_4


;	Definitions of bits in DBG$GV_CONTROL state vector
;	****   THESE MUST MATCH DEFINITIONS IN DBGLIB   ****

	dbg$v_control_tdbg =  0		; Set if this is a testable DEBUG
	dbg$m_control_tdbg =  1@dbg$v_control_tdbg

	dbg$v_control_sdbg =  1		; Set if this is SUPERDEBUG
	dbg$m_control_sdbg =  1@dbg$v_control_sdbg

	dbg$v_control_kdbg =  2		;
	dbg$m_control_kdbg =  1@dbg$v_control_kdbg

	dbg$v_control_urun =  3		; Set if user program has been run
	dbg$m_control_urun =  1@dbg$v_control_urun

	dbg$v_control_exit =  4		; Set if DEBUG is about to EXIT
	dbg$m_control_exit =  1@dbg$v_control_exit

	dbg$v_control_fail =  5		; Set by DEBUG internal errors
	dbg$m_control_fail =  1@dbg$v_control_fail

	dbg$v_control_done =  6		; Set if user program completed
	dbg$m_control_done =  1@dbg$v_control_done

        dbg$v_control_allocate  =  7	; Set if OK to allocate more memory
					;      (e.g., SET MODULE/ALLOCATE)
    	dbg$m_control_allocate = 1@dbg$v_control_allocate

	dbg$v_control_user =  8		; Set if user program is running
	dbg$m_control_user =  1@dbg$v_control_user

	dbg$v_control_stop =  9		; Set by ^Y,DEBUG sequence
	dbg$m_control_stop =  1@dbg$v_control_stop

	dbg$v_control_tbit =  10	; Set during un-interruptable TBITs
	dbg$m_control_tbit =  1@dbg$v_control_tbit

	dbg$v_control_screen = 11	; Set if screen displays must be updated
					;      because user program has run
    	dbg$m_control_screen = 1@dbg$v_control_screen

    	dbg$v_control_version_4 = 12    ; Set if VMS 3B or 4.0 is running
    	dbg$m_control_version_4 = 1@dbg$v_control_version_4



;+
; Special vector that contains the beginning and end addresses of DEBUG's
; writable storage area.  The third address in the vector is the transfer
; address of DEBUG that is in this module.
;-
	.PSECT	DBG$ABS_ZERO LONG, PIC, SHR, NOWRT, EXE
virtual_zero:
	.LONG	0	;.ADDRESS writable_stor	; lowest writable location
	.LONG	0	;.ADDRESS end_write_stor; highest writable location
	.LONG	<beginhere+2> - virtual_zero	; start address of mapped DEBUG


	.PSECT	DBG$GLOBAL LONG, PIC, NOSHR, NOEXE

writable_stor:					; Define lowest writable address
dbg$gl_runframe::	.BLKL	1

	.PSECT	ZZZ$ZZZZZZ LONG, PIC, NOSHR, NOEXE

end_write_stor:					; Define highest writable address

    	.PSECT  DBG$SSI  PIC, NOSHR, NOEXE, PAGE
    	.ALIGN  PAGE
; *****SSI
; Allocate one page of storage for the following variables.  These variables
; are DEBUG variables, pass in SSI_USS as parameters, values are returned
; from SSI_USS.  If we set the watch point on these variables (page is
; write protected) will cause SSI_USS to fail (kernal mode accvio, PROBEW).
; Any DEBUG variables is on the same page will be affected.  So, we put
; these variables on a page all by themself, away from the other DEBUG
; variables.  Restriction has to be set: NO WATCH POINT CAN BE SET ON THESE
; VARIABLES.
;
SSI_VAR_BEG::
DATA:	.BLKB	512
SSI_VAR_END::

DBG_ROUTINE_ID==SSI_VAR_BEG		; An ID returned from SSI_USS to
    					;  indicate TDBG/DBG has declared its
    					;  interception routine
SDBG_ROUTINE_ID==SSI_VAR_BEG+4		; An ID returned from SSI_USS to
    					;  indicate SDBG has declared its
    					;  interception routine
SAVE_STATE==SSI_VAR_BEG+8		; An important communication state
    					;  variable to keep the interception
    					;  flow going between all the levels
DUMMY=SSI_VAR_BEG+12			; Dummy arg.

;
; OWN STORAGE
;
	.PSECT	DBG$OWN LONG, PIC, NOSHR, NOEXE

; *****SSI
; Variables are used in DEBUG to make SSI work.
DBG_SSI_CNT::			; A count to keep track how many SSV are seen
    	.LONG	0		;  by DBG/TDBG, or SDBG
DBG_ONCE_ONLY_CNT::		; Debug is highly re-entriant, is also hard
    	.LONG	0		;  to identify re-entriant point.  So we use
    				;  this count to keep track of the entry point
DBG_SETUP::			; An important state flag to control SSI's
    	.LONG	0		;  activities for DBG/TDBG
SDBG_SETUP::			; An important state flag to control SSI's
    	.LONG	0		;  activities for SDBG
PAGE_ENTRY::			; Pointer to watch variable's page list
    	.LONG	0
DBG$GB_SET_SSI_CNT::		; A flag to indicate watch pointing is active
    	.BYTE	0		;  DEBUG only intecepts if watch pointing is
    				;  trigged
DBG$GV_SSI_CONTROL::		; A state vector to control which interception
    	.BYTE	0		;  routine is active at the moment
SAVE_SSI_STATE::		; A state vector is used in helping to set the 
    	.BYTE	0		;  above state vector.  It serves the
    				;  communication gap between TDBG and SDBG

;
; OWN STORAGE
;
term_reason:
	.LONG	0		; Location for termination reason

term_block_one:
	.LONG	0		; Forward link
fix_1:	.ADDRESS term_handler	; Address of termination handler
	.LONG	1		; Argument count
fix_2:	.ADDRESS term_reason	; Address of termination reason

term_block_two:
	.LONG	0		; Forward link
fix_3:	.ADDRESS restore_context; Address of termination handler
	.LONG	1		; Argument count
fix_4:	.ADDRESS term_reason	; Address of termination reason

; **************** saved_AP and saved_FP must be contiguous ****************
; **************** saved_R0 and saved_R1 must be contiguous ****************

saved_AP:.LONG	0		; Original AP	
saved_FP:.LONG	0		; Original FP
saved_R0:.LONG	0		; R0 and R1 are saved contiguously so that
saved_R1:.LONG	0		;  they can be preserved across $EXIT_S

faobufdesc:
	.LONG	buf_siz		; length of FAO buffer
	.LONG	0		; address of FAO buffer
msg_length:
	.WORD	0		; holds temporary buffer lengths
fao_buf:
	.BLKB	buf_siz		; buffer for FAO messages
log_buf:
	.BLKB	buf_siz		; buffer for LOG file
term_buf:
	.BLKB	buf_siz		; buffer for EXIT reason messages

const_0:.LONG	0
const_1:
param_0:.LONG	1		; Parameter count
param_1:.BLKL	1		; Actual parameter value

user_pc:.BLKL	1		; Saved PC for fake LIB$SIGNAL entry
user_fp:.BLKL	1		; Saved FP for fake LIB$SIGNAL entry
handler:.BLKL	1		; Address of user handler (or zero)
dbg$gl_exit_status::.LONG 1	; Status to be returned to DCL on exit

	.PSECT	DBG$PLIT BYTE, PIC, SHR, NOWRT, EXE

routine_value:
	.ASCIC \value returned is \

	.SBTTL	BEGINHERE	- called by DCL via DBGBOOT
	.PSECT	DBG$CODE BYTE, PIC, SHR, NOWRT, EXE
;++
; FUNCTIONAL DESCRIPTION:
;
;	 Routine "beginhere" is where DEBUG is given control from the CLI,
;	either at the start of program execution or in response to the DCL
;	"DEBUG" command (in the case of RUN/NODEBUG).
;	The routine first resolves the two separate ways that DEBUG can be
;	entered from the CLI, and coerces them to a common format. It then
;	performs once-only DEBUG initialization, and finally it enters the
;	exception handler that initiates command processing.
;
;	AP --->	----------------------------
;		!                        6 !
;		----------------------------
;		! transfer vector address  ! (Exception args if RUN/NODEBUG)
;		----------------------------
;		! parsing information      !
;		----------------------------
;		! image header information ! 
;		----------------------------
;		!  image file information  !
;		----------------------------
;		! LINK status bits         !
;		----------------------------
;		!  CLI status bits         !
;		----------------------------
;
;	The transfer vector has three or less transfer addresses in it.
;	They are ordered as in the picture below:
;
;		----------------------------
;		! DEBUG transfer address   !
;		----------------------------
;		! OTS transfer address     !
;		----------------------------
;		! user transfer address    !
;		----------------------------
;
;	If the DEBUG or OTS transfer addresses are absent, the subsequent
;	addresses are moved upward in the list.

; *****SSI
; Since DEBUG is highly re-entriant, (ie, signal back to DEBUG via SS$_NORMAL,
; Error message, build call frame stack on the fly, or via Branch, JMP etc.),
; to be safe, at each label in this module (potential entry point) we DISABLE 
; SSI, so we won't intercept DEBUG'S own System Service calls.  DBG/TDBG
; watches user program's system service, SDBG watches TDBG and user program's
; system service calls.  But at each level DBG, TDBG or SDBG, one never
; intercepts its own system service calls.
;
	.ENTRY	BEGINHERE,^M<>		; Null entry mask
	CALLS	#0,DISABLE_SSI
	BISB2	#dbg$m_control_exit,dbg$gv_control; Exit on startup errors
	BSBW	fix_up_addresses	; [TEMP] until VMS bug is fixed
	MOVQ	AP,saved_AP		; Save pointer to CLI parameters
	BBC	#cli$v_dbgexcp,24(AP),3$; Branch if normal entry to DEBUG
;
; DEBUG has been entered after user program has been started. Find the
; call frame on the stack which will resturn control to SYS$IMGSTA and
; change the return address to point to dbg$user_exit so that DEBUG is
; given control if the user program exits via a RETURN.
;
	MOVL	4(AP),AP		; Get pointer to exception parameters
	MOVL	chf$l_mcharglst(AP),R0	; Get address of MECHANISM arguments
	MOVL	chf$l_mch_frame(R0),R0	; Get FP of establisher (SYS$IMGSTA)
	MOVL	R0,saved_FP		; Save for last-chance handler
	MOVL	FP,R1			; Get current frame pointer
1$:	MOVL	sf$l_save_fp(R1),R1	; Step back to previous frame
	PROBER	#0,#20,(R1)		; Can this stack frame be read ?
	BEQL	2$			; No  - stack is corrupted ?
	CMPL	sf$l_save_fp(R1),R0	; Do we point back to SYS$IMGSTA ?
	BNEQ	1$			; No  - go look at earlier frames
	MOVAB	W^dbg$user_exit,sf$l_save_pc(R1); Yes - change return PC
2$:	BRW	setup			; Go perform common initialization
;
; DEBUG has been given control directly at start of program execution.
; We need to build a fake call-frame on the stack,  so that it appears
; to the user as though DEBUG had been given control after the CALL of
; his program but before execution of any user instructions.
;
3$:	BBS	#dbg$v_control_sdbg,dbg$gv_control,4$;Use this vector if SDBG
	ADDL2	#4,4(AP)		; Otherwise step to OTS or USER entry
4$:	ASHL	#16,#1,R0		; Get all-zero default entry mask
	MOVL	@4(AP),R1		; Get address of user transfer vector
	PROBER	#0,#2,(R1)		; Can transfer address be read ?
	BEQL	5$			; If not, don't try to read it !
	MOVZWL	(R1),R0			; Get user entry mask bits in R0
5$:	MOVL	R0,saved_R0		; Save entry-mask and flag bit
	ADDL3	#2,R1,saved_R1		; Save transfer address as well
	EXTZV	#0,#2,SP,R1		; Get low two bits of stack pointer
	BICL2	#3,SP			; Force stack to longword alignment
	BICW2	#^XF000,R0		; Mask to just bits 0-11 (registers)
	PUSHR	R0			; Save registers given in entry mask
	PUSHAB	W^dbg$user_exit		; Set up fake return address
	PUSHR	#^M<FP,AP>		; Save current context registers
	ROTL	#-2,R1,-(SP)		; Set stack alignment bits
	BISW2	R0,2(SP)		; Include register save mask
	CLRL	-(SP)			; Initialize stack exception handler
	MOVAB	B^one_shot_handler,(FP)	; Establish handler in outer frame
	MOVL	SP,FP			; Frame established - set pointer
	MOVL	#dbg$_normal,-(SP)	; Stack special exception code
	CALLS	#1,G^LIB$SIGNAL		; SIGNAL into exception handler
;
;	Never returns here - PC changed within handler !

one_shot_handler:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Full save entry mask
    	CALLS	#0,DISABLE_SSI
	MOVL	chf$l_sigarglst(AP),R0	; Get address of SIGNAL arg list
	MOVZWL	#ss$_debug,4(R0)	; Change exception name to SS$_DEBUG
	SUBL3	#1,chf$l_sig_args(R0),R1; Get offset to saved PC value
	MOVAL	(R0)[R1],R0		; Get address of saved PC parameter
	MOVL	saved_R1,(R0)+		; Change to user program start address
	EXTZV	#15,#1,saved_R0,R1	; Get entry-mask decimal enable bit
	INSV	R1,#psl$v_dv,#1,(R0)	; Set decimal overflow bit in saved PSL
	EXTZV	#14,#1,saved_R0,R1	; Get entry-mask integer enable bit
	INSV	R1,#psl$v_iv,#1,(R0)	; Set integer overflow bit in saved PSL
;
; fall through into common DEBUG once-only initialization code
;
setup:	
    	BSBW	save_user_context	; Establish known state of the world
	MOVL	chf$l_mcharglst(AP),R0	; Get address of MECHANISM array
	MOVL	chf$l_mch_frame(R0),R1	; Get frame of our establisher
	MOVAL	W^dbg$final_handl,(R1)	; Establish final exception handler

	MOVAL	W^window_handler,(FP)	; Establish local exception handler
	BSBW	setup_exit_handler	; Establish DEBUGs final exit handler
	 BLBC	R0,1$			; Go EXIT with error-status on failure
	CALLS	#0,dbg$init_debug	; initialize DEBUG context.
	$SETEXV_S VECTOR=#2,ADDRES=last_chance; Declare last chance handler
	 BLBC	R0,1$			; Go EXIT with error-status on failure
	EXTZV	#dbg$v_control_tdbg,#1,dbg$gv_control,R0 ; Get TEST DEBUG flag
	$SETEXV_S VECTOR=R0,ADDRES=primary_handler; Declare 'primary' handler
	 BLBS	R0,2$			; Carry on if declaration successful
1$:	INSV	#4,#0,#3,R0		; Otherwise make this a fatal error
	$EXIT_S	R0			;  and report status via SYS$EXIT

2$:	MOVL	chf$l_sigarglst(AP),R0	; Get address of SIGNAL arg list
	SUBL3	#1,chf$l_sig_args(R0),R1; Get offset to saved PC value
	PUSHL	(R0)[R1]		; Stack PC value for dbg$rst_init
	MOVL	saved_AP,R0		; Get address of CLI vector
	PUSHL	cli$a_imghdadr(R0)	; Push address of image header info.
	MOVL	cli$a_imgfiled(R0),R0	; Get the address of the image file
	MOVZWL	ifd$w_filnamoff(R0),R1	; get offset to file name
	ADDL3	R0,R1,-(SP)		; Push address onto stack
    	MOVZWL	ifd$w_chan(R0),-(SP)	; Push channel number onto stack
	CALLS	#4,dbg$rst_init		; Initialize the symbol tables.
	BICB2	#dbg$m_control_exit,dbg$gv_control ; Turn off exit flag
	BRW	prim_4			; Act as though its a normal exception

;
;	When the user program runs to completion, then control runs back
;	to the label dbg$user_exit, and DEBUG forces a SYS$EXIT with the
;	user's value of R0. Our termination handler then reports this R0
;	as a system message.  The rest of this routine  (which starts at
;	beginhere_2) is jumped to from within the termination handler.
;	It recreates the original argument list	with a new R0,R1 pair to
;	preserve them across $EXIT_S, and moves back through the restart
;	logic to the command processor.

dbg$user_exit::
    	CALLS	#0,disable_ssi
	MOVL	R0,dbg$gl_exit_status	; Save user program's return status
	MOVQ	R0,saved_R0		; Stuff away for later restoration.
	$EXIT_S	R0			; Force SYS$EXIT with user's R0 value.
	RET				; Don't need to set R0 here !


reset_debug:
	MOVL	(SP)+,R0		; Get back return address
	MOVQ	saved_AP,AP		; Restore saved AP and FP
	MOVL	FP,SP			; Restore SP to be the saved FP
	PUSHAB	W^dbg$user_exit		; Set up fake return address
	PUSHR	#^M<FP,AP>		; Save current context registers
	CLRL	-(SP)			; Set register save mask & PSW
	MOVAB	term_window_handler,-(SP);Establish temporary window handler
	MOVL	SP,FP			; Point to current frame
	PUSHL	R0			; Stack return address again
	MNEGL	#1,-(SP)		; Replace all BPT's with their real
	CALLS	#1,dbg$ins_opcodes	;  opcodes, and unprotect all pages
	RSB				; Return to caller with a new frame

setup_exit_handler:
	$DCLEXH_S DESBLK=term_block_one	; Declare a termination handler
	 BLBC	R0,3$			; Return error-status to caller
	BLBS	dbg$gv_control,3$	; No re-arranging if TEST DEBUG
1$:	MOVL	term_block_one,R1	; Get link to first USER exit handler
	BEQL	3$			; Zero link means we are the last one
	PUSHL	R1			; Save address of control block
	$CANEXH_S DESBLK=(R1)		; Un-declare user exit handler
	 BLBC	R0,2$			; Return error status to caller
	BSBB	1$			; Repeat for all user exit handlers
2$:	MOVL	(SP)+,R1		; Get back address of control block
	BLBC	R0,3$			; Report error-status to caller
	$DCLEXH_S DESBLK=(R1)		; Re-establish handlers in LIFO order
3$:	RSB				; Return status in R0

	.SBTTL	DEBUG entry and exit routines - save/restore state of user
;
;  This routine is called on entry to DEBUG to save the user's registers
; and sundry other user context in the current RUNFRAME,  and to set the
; context of DEBUG to a known state (AST's disabled, etc.).
;
save_user_context:
	BLBS	dbg$gv_control+1,save_user_context_always
    					; Only do this if user was 'in control'
	RSB				; Otherwise return immediately
save_user_context_always:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>	; Save all registers we use
    	CALLS	#0,disable_ssi
	$SETAST_S #0			; Disable AST interrupts
	MOVAB	dbg$runframe,R6		; Get pointer to current RUNFRAME
	MOVQ	4(AP),R7		;  and to SIGNAL & MECHANISM arrays
	BICW2	#dbg$m_enab_fex+dbg$m_enab_ast,dbg$w_run_stat(R6)
	BBSC	#dbg$v_control_tbit,dbg$gv_control,2$; (set if ASTs held off)
	CMPL	#ss$_wasclr,R0		; Were ASTs enabled?
	BEQL	3$			; No - flag is already clear
2$:	BISW2	#dbg$m_enab_ast,dbg$w_run_stat(R6) ; Yes - remember to reenable
3$:	$SETSFM_S #0			; Disable sys service failure exception
	CMPL	#ss$_wasclr,R0		; Was it enabled?
	BEQL	4$			; No - flag is already clear
	BISW2	#dbg$m_enab_fex,dbg$w_run_stat(R6) ; Yes - remember to reenable
4$:	PUSHL	chf$l_sig_name(R7)	; Stack actual exception code
	CALLS	#1,dbg$exception_is_fault;Get type of exception (fault/trap)
	INSV	R0,#dbg$v_at_fault,#1,dbg$w_run_stat(R6) ; Remember exc type
	MOVAL	dbg$l_user_regs(R6),R3	; Get address for user's registers
	MOVQ	chf$l_mch_savr0(R8),(R3)+;Copy R0,R1 from MECHANISM array
	MOVC3	#40,20(FP),(R3)		; Save user registers R2 - R11
	MOVQ	sf$l_save_ap(FP),(R3)+	; Save user AP - FP
	ADDL3	(R7),#1,R0		; Get signal arg count plus 1
	MOVAL	(R7)[R0],R0		; Calculate value of user SP
	MOVL	R0,(R3)+		; Save user SP in RUNFRAME
	MOVQ	-(R0),(R3)+		; Save last 2 SIGNAL args (PC & PSL)
	$DCLEXH_S DESBLK=term_block_two	; Declare temporary exit handler
	BICB2	#dbg$m_control_user@-8,dbg$gv_control+1	; DEBUG is in control
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>	; Restore all used registers
	RSB				; Return with user context saved

restore_context:
	.WORD	^M<R2>			; Save contents of register R2
	BISW2	#dbg$m_control_user+dbg$m_control_urun,dbg$gv_control
	MOVAB	dbg$runframe,R2		; Get base of current run frame
	BBC	#dbg$v_enab_fex,dbg$w_run_stat(R2),1$	; Was SFM enabled ?
	$SETSFM_S #1			; Yes - reenable exceptions
1$:	BBC	#dbg$v_enab_ast,dbg$w_run_stat(R2),2$	; Were AST's enabled ?
	BBS	#dbg$v_control_tbit,dbg$gv_control,3$	;  and not postponed ?
	$SETAST_S #1			; Yes - reenable ASTs
2$:	BBCC	#dbg$v_control_tbit,dbg$gv_control,3$	; No ASTs postponed !
; *****SSI
; Time to leave DEBUG, ENABLE SSI, This is the only place we enable SSI.
;
3$:	CALLS	#0,enable_ssi
    	RET				; User context reset - return

	.SBTTL	DEBUG Termination  and last-chance handlers

TERM_HANDLER:
	.WORD	^M<>			; Null entry mask
DBG$TERM_HANDLR::
    	CALLS	#0,disable_ssi
	BLBC	DBG$GL_SCREEN_MODE,2$	; Set up screen refresh and set scrol-
	CALLS	#0,DBG$SCR_SCREEN_TERM	;      ling region back to normal
2$:	BBS	#DBG$V_CONTROL_EXIT,DBG$GV_CONTROL,3$	; Exit if exit flag set
	CMPL	#SS$_CLIFRCEXT,TERM_REASON		; Check the exit status
	BNEQ	5$			; Continue unless "CLI forced exit"
; Before we return to CLI, we check for this special case.
3$:    	BBS	#DBG$V_CONTROL_DONE,DBG$GV_CONTROL,4$
; In testable debugger, if the user program does not run to an end, if we
; reach here via DBG>EXIT, if there are break points set along the path
; such as PRIMARY_HANDLER, DBG$EXCEPTION_HANDLER in SDBG, causing super 
; debugger goes into an infinite loop.  ($EXIT calls all user declared
; handler after we reach RET instruction here, one of the user declared
; handler is the DBG$TERM_HANDLR in Super Debugger, Super debugger signals
; exit status, then causing break point faults to take place, note: at this
; point super debugger is no longer available).  So before we RET, we do
; some cleaning work.
	MOVL	TERM_REASON,DBG$GL_EXIT_STATUS	; Save the $EXIT status code
	BICB2	#dbg$m_control_user@-8,dbg$gv_control+1	; DEBUG is in control
	BISB2	#dbg$m_control_done,dbg$gv_control	; User program complete
	BSBW	reset_debug		; Re-establish a known context
    	MOVL	TERM_REASON,R0
4$:	RET				; Don't intercept - return to CLI

5$:	MOVL	TERM_REASON,DBG$GL_EXIT_STATUS	; Save the $EXIT status code
	BICL2	#sts$m_inhib_msg,term_reason		; Clear 'inhibit' bit
	BICB2	#dbg$m_control_user@-8,dbg$gv_control+1	; DEBUG is in control
	BISB2	#dbg$m_control_done,dbg$gv_control	; User program complete
	BSBW	reset_debug		; Re-establish a known context
	BSBW	setup_exit_handler	; Re-establish final exit handler
	MOVZWL	#buf_siz-1,faobufdesc	; Try to convert the status	
	MOVAB	term_buf+1,faobufdesc+4	; to a system message
	$GETMSG_S MSGID=term_reason,MSGLEN=msg_length,BUFADR=faobufdesc
	MOVB	msg_length,term_buf	; Make counted string in TERM_BUF
	PUSHAB	term_buf		; Address of counted string
	PUSHL	#1			; One FAO parameter for SIGNAL
	PUSHL	#dbg$_exitstatus	; Message number
	CALLS	#3,G^LIB$SIGNAL		; SIGNAL exit status back to DEBUG

last_chance:
	.WORD	^M<>			; Null entry mask
    	CALLS	#0,DISABLE_SSI
	BICB2	#dbg$m_control_user@-8,dbg$gv_control+1	; DEBUG is in control
	CALLG	(AP),dbg$putmsg		; Output signal message text
	MOVL	chf$l_mcharglst(AP),R0	; Get address of MECHANISM array
	MOVQ	chf$l_mch_savr0(R0),saved_R0 ; Save contents of user registers
	BSBW	reset_debug		; Reset stack to a known state
	PUSHL	#dbg$_lastchance	; Message number
	CALLS	#1,G^LIB$SIGNAL		; SIGNAL back in to DEBUG

term_window_handler:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Full entry mask
    	CALLS	#0,DISABLE_SSI
	MOVQ	chf$l_sigarglst(AP),R2	; Get SIGNAL & MECHANISM addresses
	MOVQ	saved_R0,chf$l_mch_savr0(R3)	; Set contents of user R0,R1
	CLRL	@chf$l_mch_frame(R3)	; Remove link to this handler
	CALLG	(AP),dbg$putmsg		; Output signal message text
	SUBL3	#1,(R2),R1		; Get offset to saved PC value
	CLRL	(R2)+[R1]		; Clear PC to make restart difficult
	MOVZWL	#ss$_debug,(R2)		; Change signal name to 'SS$_DEBUG'
	BISB2	#dbg$m_control_user@-8,dbg$gv_control+1	; User was in control
	BRW	prim_3			; Go save context & issue DEBUG prompt

	.SBTTL	DBG$PSEUDO_PROG	- Structure to implement CALL

dbg$pseudo_prog::
	CALLG	@dbg$runframe+dbg$l_frame_ptr,@dbg$runframe+dbg$l_call_addr

dbg$pseudo_exit::; Label to detect STEPping off the end of the CALLed routine.
    	CALLS	#0,disable_ssi
	MOVQ	R0,saved_R0		; Save return value from user procedure
	$SETAST_S #0			; Disable AST interrupts
	$DCLEXH_S DESBLK=term_block_two	; Declare temporary exit handler
	BICB2	#dbg$m_control_user@-8,dbg$gv_control+1	; DEBUG is in control
	MOVL	(FP),AP			; Get pointer to current handler
	MOVAW	B^pseudo_handler,(FP)	; Get handler to bootstrap into DEBUG
	PUSHL	#dbg$_normal		; Get phony exception value
	CALLS	#1,G^LIB$SIGNAL		; SIGNAL back to proper context
;	point of no return !

pseudo_handler:	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Full save mask

	MOVQ	chf$l_sigarglst(AP),R10	; Get pointers to SIGNAL & MECHANISM
	MOVL	sf$l_save_ap(FP),@chf$l_mch_frame(R11)	; Restore handler
	CALLS	#0,dbg$flushbuf		; Initialize print buffer.
	PUSHAL	routine_value		; Report the value returned
	CALLS	#1,dbg$print		; Insert text in buffer
	PUSHL	saved_R0		;  call of DBG$OUT_NUM_VAL
	CALLS	#1,dbg$out_num_val	; Insert returned numeric value
	CALLS	#0,dbg$newline		; Output buffer contents
	MOVAB	dbg$runframe,R11	; Get address of routine's runframe
	MOVL	dbg$l_next_link(R11),R6	;  and address of previous runframe
	MOVL	dbg$l_frame_ptr(R11),R5	; get address of routine argument list
	MOVL	(R5),R4			; Get number of parameters passed
	BEQL	3$			; No data structure if no parameters !
	MOVAL	@dbg$l_save_fld(R11)[R4],R3	; Otherwise get MEMUSE vector
1$:	MOVL	-(R3),param_1		; Get memory used for this parameter
	BEQL	2$			; Zero means none allocated !
	CALLG	param_0,G^dbg$rel_memory; Otherwise release memory again
2$:	SOBGTR	R4,1$			; Loop for all parameters
	PUSHL	R3			; Then point to MEMUSE vector area
	CALLS	#1,G^dbg$rel_memory	;  and release that space as well
3$:	PUSHL	R5			;  Push address of block.
	CALLS	#1,G^dbg$rel_memory	; Free space used for argument list
	MOVC3	#dbg$k_runfr_len,(R6),(R11); Restore previous context
	PUSHL	R6			; Push address of runframe
	CALLS	#1,G^dbg$rel_memory	; Free this storage too
	CLRL	R2			; Pop "unhandled exc" stack
4$:	MOVB	DBG$GB_UNHANDLED_EXC+1[R2],DBG$GB_UNHANDLED_EXC[R2]
	AOBLEQ	#8,R2,4$
	CMPB	#1,DBG$GB_CALL_NORMAL_RET; Set CALL flag to indicate a normal
	BNEQ	5$			;      return from a CALL command call
	INCB	DBG$GB_CALL_NORMAL_RET	;      (used to suppress screen update)
5$:	SUBL3	#1,(R10),R1		; Get offset to saved SIGNAL PC
	MOVAL	(R10)[R1],R1		; Get actual address for PC & PSL
	MOVZWL	#ss$_debug,4(R10)	; Change signal name to 'SS$_DEBUG'
	MOVQ	dbg$l_user_pc(R11),(R1)	; Restore PC & PSL to SIGNAL array
	BRB	prim_4			; Rejoin common exception flow

	.SBTTL	PRIMARY_HANDLER
;++
; FUNCTIONAL DESCRIPTION:
;	Exception handler declared in the primary vector. Simply resignals
;	if the exception occurred during the execution of a debug command.
;	If the exception occurred in the user program being debugged, this
;	routine disables ASTs (if they were enabled),  saves the registers
;	from the user program at the time of the exception, and then calls
;	a routine to handle the exception.
;	When the called routine returns, the registers are restored,  ASTs
;	are re-enabled (if they were disabled),  and the exception handler
;	returns with the resignal value received from the called routine.
;
; CALLING SEQUENCE:
;	4(AP)	- Address of SIGNAL ARRAY
;	8(AP)	- Address of MECHANISM ARRAY
;
; IMPLICIT INPUTS:
;	The global flag dbg$v_control_user, which indicates whether the
;	user program was running, or DEBUG was executing a debug command.
;
; IMPLICIT OUTPUTS:
;	The "dbg$v_enab_ast" flag indicates whether asts were enabled
;	at the time of the interrupt
;
; ROUTINE VALUE:
;	SS$_RESIGNAL or the value returned by DBG$EXC_HANDLER
;
; SIDE EFFECTS:
;	The user may get control under DEBUG
;--

	.ENTRY	PRIMARY_HANDLER,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
prim_handl_2::
    	CALLS	#0,disable_ssi
	MOVZWL	#ss$_resignal,R0	; We usually want to resignal exception
	MOVL	chf$l_sigarglst(AP),R1	; Get address of SIGNAL argument list
	CMPL	#dbg$_normal,4(R1)	; Fake DEBUG-generated signal ?
	BEQL	2$			; Yes - just resignal it at once
	CMPL	#ss$_debug,4(R1)	; Generated by ^Y,DEBUG sequence ?
	BNEQ	1$			; No  - pass on to next handler
	MOVZWL	#ss$_continue,R0	; Get ready to ignore 'SS$_DEBUG'
	BLBS	dbg$gv_control,2$	; Always ignore if testable debugger
	BBCS	#dbg$v_control_stop,dbg$gv_control,1$	; Set STOP flag
	BLBS	dbg$gv_control+1,3$	; Continue unless DEBUG was running
	BISB2	#dbg$m_control_fail,dbg$gv_control ; and the STOP flag was set
	MOVZWL	#ss$_resignal,R0	;  when we resignal to final handler
1$:	BLBS	dbg$gv_control+1,3$	; Are debug commands being executed?
2$:    	RET				; Yes - return to exception dispatch

3$:	BBC	#dbg$v_control_sdbg,dbg$gv_control,prim_3 ; If SUPERDEBUG,
	CMPL	#dbg$_superdebug,4(R1)	; See if this SUPERDEBUG signal
	BNEQ	prim_3			; Some other signal - look at it
	MOVZWL	#ss$_debug,4(R1)	; SUPERDEBUG gets changed to DEBUG
prim_3:	BSBW	save_user_context	; Establish known state of the world
prim_4:	MOVAL	W^window_handler,(FP)	; Establish temporary exception handler
	CALLG	(AP),dbg$exc_handler	; Call inner exception handler
	BLBC	R0,return_to_user	; Just return if re-signalling
	BBS	#dbg$v_control_tbit,dbg$gv_control,return_to_user; Single-Step ?
	BBC	#dbg$v_control_stop,dbg$gv_control,return_to_user; ^Y, DEBUG ?
	MOVL	dbg$runframe+dbg$l_user_regs+60,user_pc		 ; Yes - save PC
	MOVAB	W^Pseudo_Signal,dbg$runframe+dbg$l_user_regs+60	 ;  & set new PC
return_to_user:
	MOVQ	4(AP),R10		; Get address of SIGNAL & MECHANISM
	PUSHR	#^M<R0>			; Save resignal value
	MOVAL	dbg$runframe+dbg$l_user_regs,R1	; Get address of user regs
	MOVQ	(R1)+,12(R11)		; And restore R0 - R1,
	MOVC3	#40,(R1),20(FP)		;  user R2 - R11
	MOVQ	(R1)+,8(FP)		;   and user AP - FP
	SUBL3	#1,(R10),R2		; Get offset to saved SIGNAL PC
	MOVAL	(R10)[R2],R2		; Get actual address for PC & PSL
	MOVQ	4(R1),(R2)		; Restore PC & PSL to SIGNAL array
	CLRL	(FP)			; Remove stack-frame exception handler
	$CANEXH_S DESBLK=term_block_two	; Un-declare temporary exit handler
	CALLS	#0,restore_context	; Go reset user AST/SFM enables
	POPR	#^M<R0>			; Get the resignal value back
	RET				;  and return

	.SBTTL	DBG$THREAD_BPT	- Entry to DEBUG for threaded BPT's
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is called by a "JMP @(R11)+" instruction when the "thread"
;	processor encounters the thread where the user has set a breakpoint.
;	An exception frame is built on the stack to describe the breakpoint
;	using R11 -4 as the address of the "PC".  The PRIMARY_HANDLER is called
;	which will announce the breakpoint and process user commands.
;
;	When the user issues a GO or STEP command the actual thread is moved
;	onto the stack from R11 and the exception frame is removed.  The user
;	program is then restarted by an REI to the next thread.
;
; CALLING SEQUENCE:
;	R11	- Contains the address after the thread where the breakpoint
;		  was set.
;
; IMPLICIT INPUTS:
;	The routine was called with a JMP @(R11)+ instruction.
;
; IMPLICIT OUTPUTS:
;	R11 is still the thread pointer.
;
; ROUTINE VALUE:
;	None.
;
; SIDE EFFECTS:
;	None.
;
;--

dbg$thread_bpt::
	MOVPSL	-(SP)			; Save the current PSL
	PUSHAL	-(R11)			; Treat R11 as the PC, and set it to
					; the address of the thread.
	PUSHL	#ss$_break		; This is a breakpoint exception.
	PUSHL	#3			; Exception frame has 3 longwords
	MOVQ	R0,-(SP)		; Save R0,R1
	CLRQ	-(SP)			; next 2 longwords of mechanism array
	PUSHL	#4			; Mechanism array has 4 longwords.
	PUSHAL	(SP)			; Build arg list for primary handler
	PUSHAL	24(SP)			;
	CALLS	#2,primary_handler	; Call primary handler
dbg$thread_ret::			; Label where threaded breakpoint returns
	MOVL	(R11)+,28(SP)		; Save user's actual thread in case
					; he changed it during the breakpoint
	ADDL2	#12,SP			; Get address of new R0,R1
	MOVQ	(SP)+,R0		; Restore R0,R1
	ADDL2	#8,SP			; Remove all but new PC - PSL pair
	REI				; Transfer control to "thread" routine

	.SBTTL	WINDOW_HANDLER	- Call frame exception handler
;++
; FUNCTIONAL DESCRIPTION:
;	This handler is put up by the primary handler to be used during the
;	"window" during the processing of an exception and before the DEBUG
;	prompt is output. SS$_DEBUG signals are ignored (we are trying hard
;	to get back to DEBUG command level). everything else causes a jump
;	to FINAL_HANDLER to report the error.
;
; CALLING SEQUENCE:
;	4(AP)	- Address of SIGNAL ARRAY
;	8(AP)	- Address of MECHANISM ARRAY
;
; IMPLICIT INPUTS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	NONE
;
; SIDE EFFECTS:
;	Errors reported by FINAL_HANDLER
;--
window_handler:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
    	CALLS	#0,DISABLE_SSI
	MOVL	4(AP),R0		; Get address of SIGNAL ARRAY
	CMPL	4(R0),#ss$_debug	; Is this the DEBUG exception ?
	BNEQ	dbg$final_handl+2	; No  - transfer to the final handler
	MOVZWL	#ss$_continue,R0	; Yes - load CONTINUE code
	RET				; Ignore extra 'SS$_DEBUG' signals

	.SBTTL	DBG$FINAL_HANDL	- Call frame exception handler
;
; Functional description:
;	This handler is the ultimate exception handler for exceptions
;	that occur under DEBUG control or during execution of the user
;	program. Any exception that gets here has already passed thru
;	primary handlers, secondary handlers, and user-declared
;	stack handlers. This handler stops the exception from causing
;	an exit to the operating system, and drops the user back at
;	DEBUG command level.
;
;	This routine first determines whether it was called because of
;	a hard/software exception condition, or because of a software
;	generated SIGNAL. The identification of the error is from the
;	signal-arg-list.
;
;	The handler outputs DEBUG generated messages and operating
;	system generated conditions in distinct manners. The latter
;	conditions are reported, analyzed for source of error, and
;	then the user regains control. DEBUG messages are output, and
;	control is returned to the user or to CLI according to the
;	severity of the message.
;
; Calling sequence:
;	4(AP)	- Address of SIGNAL ARRAY for an exception. Contains the
;		  exception name, the PC of the exception, and the PSL
;		  and any additional FAO arguments required by the
;		  particular message to be generated.
;	8(AP)	- Address of MECHANISM ARRAY for an exception. Contains
;		  R0 and R1.
;
; Implicit inputs:
;	The global flag DBG$V_CONTROL_USER says whether DEBUG or the user
;	was running when the exception occurred. The severity of the error
;	is determined by the low three bits in the error identifier.
;
; Implicit outputs:
;	The name of the exception is changed if PRIMARY_HANDLER is
;	called.
;
; Routine value:
;	SS$_RESIGNAL is returned when the exception was SS$_UNWIND.
;	SS$_CONTINUE is returned when the exception occurred in DEBUG
;		code (unless the error was fatal).
;	Otherwise, this code JMPs to primary_handler and the return is
;		dependent upon many subsequent things.
;
; Side effects:
;	An error message is output to the terminal.
;

	.ENTRY	DBG$FINAL_HANDL,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
    	CALLS	#0,disable_ssi
	MOVL	CHF$L_SIGARGLST(AP),R2	; Get address of signal argument list
	CMPL	4(R2),#SS$_UNWIND	; Is this a SYSTEM unwind exception ?
	BNEQ	1$			; If not unwind, look at it further.
	MOVZWL	#SS$_RESIGNAL,R0	; if unwind, just resignal condition
	RET

1$:	MOVAB	B^DBG$FINAL_HANDL,(FP)	; Establish ourselves as a handler
	MOVZBL	DBG$GV_CONTROL+1,R3	; Save current state of DEBUG/USER flag
	BSBW	SAVE_USER_CONTEXT	; Establish known state of the world
	BISL2	#RAB$M_CCO,DBG$GL_OUTPRAB+RAB$L_ROP ; Cancel control-O
	CMPL	4(R2),#SS$_DEBUG	; Is this the DEBUG exception ?
	BEQL	2$			; Yes - suppress message output
	CMPL	4(R2),#DBG$_NORMAL	; Special DEBUG initialization ?
	BEQL	3$			; Yes - suppress message output
	CALLG	(AP),DBG$PUTMSG		; Write system message to DBG$OUTPUT
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,4(R2),#DBG_FACILITY	;
	BNEQ	2$			; Skip if facility is not DEBUG
	CMPW	4(R2),#SHR$_APPENDEDB	; Not DEBUG if bit 15 is clear unless
    	BLSSU	2$			;      this is a "shared" message
	JMP	FINAL_2			

; Come here if not a DEBUG-specific exception (System or User generated).
; If the user was running, jump into the register saving exception handler.
; If DEBUG was running, output a message saying that DEBUG caused the error.
;
2$:	BLBS	R3,3$			; Report error if DEBUG was running
	BRW	FINAL_3			;      by branching to FINAL_3
3$:	SUBL3	#1,(R2),R4		; Get address of saved PC
	PUSHAB	DBG$PSEUDO_EXIT		; Get address of DBG$PSEUDO_EXIT
	CMPL	(R2)[R4],(SP)+		; See if CALLed routine has finished
	BEQL	4$			; If so, just return CONTINUE
	BLBS	4(R2),4$		; Continue if INFORMATION or SUCCESS
	MOVL	(R2)[R4],USER_PC	; Save actual user PC for error
	MOVL	4(R2),DBG$GL_EXIT_STATUS; Remember error status (for EXIT)
    	CMPZV	#0,#3,4(R2),#4		; Check for severe error
    	BNEQ	35$			; If not, don't fill in global
    	MOVB	#1,DBG$GB_UNHANDLED_EXC ; Remember that an unhandled exception
    					;      has occured in the user program
35$:	$UNWIND_S  DEPADR=CONST_0,NEWPC=PSEUDO_SIGNAL	; Unwind the stack
;
; After the UNWIND, return to the user, but do so without restoring the
; registers.  The Exception-Handling Facility requires that we not change
; the saved PC, and in any event there is no need to restore any registers
; since they cannot be changed (via DEPOSIT, etc.) in the Final Handler.
;
4$:	MOVZWL	#SS$_CONTINUE,R0	; Return status "CONTINUE"
	BLBS	R3,6$			; Restore registers on user exit
	TSTL	DBG$GL_SCREEN_ERROR	; Do not purge type-ahead if error msg
	BNEQ	5$			;      went to a screen display
	BLBS	4(R2),5$		; Do not purge type-ahead if severity
	BISL2	#RAB$M_PTA,DBG$GL_INPRAB+RAB$L_ROP	;   is INFO or SUCCESS
5$:	BICL2	#RAB$M_CCO,DBG$GL_OUTPRAB+RAB$L_ROP	; Un-cancel Ctrl-O
	RET				; Return to exception mechanism
6$:	PUSHR	#^M<R0>			; Save resignal value
	CLRL	(FP)			; Remove stack-frame exception handler
	$CANEXH_S DESBLK=TERM_BLOCK_TWO	; Un-declare temporary exit handler
	CALLS	#0,RESTORE_CONTEXT	; Go reset user AST/SFM enables
	POPR	#^M<R0>			; Get the resignal value back and
	RET				;      return from the Final Handler
;
; Arrive here because the error was generated by a DEBUG signal.
;
FINAL_2:
	BLBC	DBG$GV_CONTROL,6$	; Only SIGNAL if testable DEBUG
	CMPZV	#STS$V_SEVERITY,#STS$S_SEVERITY,4(R2),#STS$K_SEVERE ; Fatal ?
	BEQL	5$			; If so, signal condition
	CMPL	4(R2),#DBG$_INTERR	; Check for either of the two
	BNEQ	6$			;  'DEBUG internal coding error'
5$:	PUSHL	#DBG$_SUPERDEBUG	; Get special signal for SUPERDEBUG
	CALLS	#1,G^LIB$SIGNAL		; Alert the superdebugger
6$:	BLBC	4(R2),FINAL_4		; Exit, but allow DEBUG to continue
	BRW	FINAL_5			;      if message is 'INFORMATION'

FINAL_3:
	CMPL	4(R2),#SS$_DEBUG	; Is this the DEBUG exception ?
	BEQL	FINAL_4			; Yes -  UNWIND to DEBUG command level
	BBSS	#DBG$V_CONTROL_FAIL,DBG$GV_CONTROL,8$	; Set failure flag
	PUSHL	#DBG$_DBGERR		; Message blaming DEBUG for the error
	PUSHL	#1			; Number of parameters
	PUSHL	#0			; No facility string
	PUSHAB	W^DBG$OUT_MESSAGE	; Action routine name to output message
	PUSHAB	8(SP)			; Address of argument list
	CALLS	#3,G^SYS$PUTMSG		; Get message formatted and output
	ADDL2	#8,SP			; Remove temporary argument list
8$:	BLBC	DBG$GV_CONTROL,FINAL_4	; Are we a testable DEBUG ?
	PUSHL	#DBG$_SUPERDEBUG	; Yes - get special signal
	CALLS	#1,G^LIB$SIGNAL		; Alert the superdebugger
;
; The messages are all out. Unless the exit flag is set, do end-of-command
; processing and unwind the stack to the caller of the command processor,
; (or whoever established DBG$FINAL_HANDL as the exception handler)
; and return a continue code.
;
FINAL_4:
	BBS	#DBG$V_CONTROL_EXIT,DBG$GV_CONTROL,FINAL_6 ; EXIT if flag is set
    	MULL3	#2, #65536, R0		; Get DEBUG facility code in R0
    	ADDL2	#SHR$_READERR, R0    	; Change SHR$_READERR to DBG$_READERR
    	BISL2	#^X0004, R0		; Set the fatal bit on.
    	CMPL	4(R2), R0		; If the message is DBG$_READERR
    	BEQL	FINAL_4_1   	
    	CMPL	4(R2), #DBG$_INPREADERR ; Keypad input error?
    	BNEQ	FINAL_4_2		; No, continue
FINAL_4_1:
    	CMPL	DBG$GL_READERR_CNT, #20 ; Tried 20 times, get the same error
    	BGEQ    FINAL_7			; Yes, force exit
FINAL_4_2:
	CALLS	#0,DBG$END_OF_LINE	; Clean up DEBUG internal status
	MOVL	8(AP),R0		; Get address of mechanism array
	CLRL	CHF$L_MCH_SAVR0(R0)	; Make sure returned value is 0 !!
	$UNWIND_S			; Unwind to caller of the routine
					;      that declared this handler
FINAL_5:
	MOVZWL	#SS$_CONTINUE,R0	; Return status "CONTINUE"
	BLBS	R3,12$			; Restore registers on user exit
	TSTL	DBG$GL_SCREEN_ERROR	; Do not purge type-ahead if error msg
	BNEQ	11$			;      went to a screen display
	BLBS	4(R2),11$		; Do not purge type-ahead if severity
	BISL2	#RAB$M_PTA,DBG$GL_INPRAB+RAB$L_ROP	;   is INFO or SUCCESS
11$:	BICL2	#RAB$M_CCO,DBG$GL_OUTPRAB+RAB$L_ROP	; Un-cancel Ctrl-O
	RET				; Return to exception mechanism
12$:	BRW	RETURN_TO_USER		; Go restore user context

    	
FINAL_6:
	MOVL	4(R2),R0		; Unrecoverable error - get code
	INSV	#4,#0,#3,R0		; Change severity to FATAL
	$EXIT_S	R0			;  and take an exit.

FINAL_7:
	BISB2	#DBG$M_CONTROL_EXIT,DBG$GV_CONTROL; Set Exit bit on
    	MOVL	#DBG$_READERR, R0	; Set the exit status
    	INSV	#4,#0,#3,R0		; Change severity to FATAL
    	$EXIT_S R0			;  and take an exit.

PSEUDO_SIGNAL:
    	CALLS	#0,disable_ssi
	BISL2	#RAB$M_PTA,DBG$GL_INPRAB+RAB$L_ROP	; Purge type-ahead
	MOVL	FP,USER_FP		; Save user's frame pointer
	MOVL	(FP),HANDLER		; Save pointer to stack handler
    	MOVAB   DBG$RUNFRAME,R0		; Restore 
    	MOVAL	DBG$L_USER_REGS(R0),R0  ;  user registers 
    	MOVQ	(R0),R0			;  R0 and R1.
	MOVAB	B^LOCAL_HANDLER,(FP)	; Set up a one-shot handler
	PUSHL	#DBG$_NORMAL		; Get special exception value
	CALLS	#1,G^LIB$SIGNAL		; SIGNAL back to DEBUG context

LOCAL_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
    	CALLS	#0,disable_ssi
	MOVL	HANDLER,@USER_FP	; Restore user's original handler
	MOVL	CHF$L_SIGARGLST(AP),R0	; Get address of signal argument list
	MOVZWL	#SS$_DEBUG,4(R0)	; Change signal name to SS$_DEBUG
	SUBL3	#1,(R0),R1		; Get offset to PC in SIGNAL args
	MOVL	USER_PC,(R0)[R1]	; Restore actual User Error PC
	BRW	PRIM_3			; Go save context & issue DEBUG prompt

	.SBTTL	DBG$OUT_MESSAGE	- Write SYS$PUTMSG output to DBG$OUTPUT

;++
; FUNCTIONAL DESCRIPTION:
;	This routine is called as an action routine from EXE$PUTMSG to output
;	the string that EXE$PUTMSG has just formatted.  The string is output
;	to the logical device DBG$OUTPUT, and a value of zero is returned to
;	EXE$PUTMSG preventing it from outputing the message also.
;
; CALLING SEQUENCE:
;	4(AP)	- Address of a quadword string descriptor
;
; IMPLICIT INPUTS:
;	The output RAB for DBG$OUTPUT at location DBG$GL_OUTPRAB
;
; ROUTINE VALUE:
;	R0 = 0	- To inhibit further typing of the message
;
;--

	.ENTRY	DBG$OUT_MESSAGE,^M<>

	MOVAB	@4(AP),R0		; Get address of string descriptor
	MOVW	 (R0),dbg$gl_outprab+rab$w_rsz	; Load string length into RAB
	MOVL	4(R0),dbg$gl_outprab+rab$l_rbf	; Load address of string
	BLBC	dbg$gb_def_out,1$	; Check if LOG file being written
	MOVB	#^A"!",log_buf		; Put "!" into first byte of LOG buf
	MOVC5	dbg$gl_outprab+rab$w_rsz,@<dbg$gl_outprab+rab$l_rbf>, -
		#^A" ",#buf_siz-1,log_buf+1	; Copy message to LOG buffer
	ADDW3	#1,dbg$gl_outprab+rab$w_rsz,dbg$gl_lograb+rab$w_rsz ; Length
	MOVAB	log_buf,dbg$gl_lograb+rab$l_rbf	; Load address of string
	$PUT	RAB = dbg$gl_lograb	; Write string to LOG file
1$:	TSTL	dbg$gl_screen_error	; If errors are redirected to a screen
	BEQL	2$			;      display, call screen WRITE_ERROR
	PUSHAB	dbg$gl_outprab		;      routine instead of $PUT to out-
	CALLS	#1,dbg$scr_write_error	;      put the message
	BLBS	R0,3$			; On success, skip the $PUT call
2$:	$PUT	RAB = dbg$gl_outprab	; Write string to DBG$OUTPUT
	BLBC	R0,4$			; Exit if we encountered an error
3$:	CLRL	R0			; Otherwise return 0
	RET				;
4$:	INSV	#4,#0,#3,R0		; Change severity to FATAL
	$EXIT_S	R0			;  and take an exit.

	.SBTTL	DBG$CHECK_PROT	- Makes page writable
;++
; FUNCTIONAL DESCRIPTION:
;	 Probes a single byte to see whether it can be written.  If it can,
;	the value dbg$k_no_reset is returned.  Otherwise, the SETPRT system
;	service is called to change the protection of the page in which the
;	byte is located to user read/write and we return dbg$k_reset_prt as
;	the value of this routine.  If the system service returns an error,
;	zero is returned.
;
; CALLING SEQUENCE:
;	4(AP)	- The address of the byte to make writeable
;	8(AP)	- The address of a byte in which the system service can put
;		  the previous protection of the page
;
; IMPLICIT INPUTS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	dbg$k_no_reset	- Protection was already writeable, no change made
;	dbg$k_reset_prt	- Protection changed, old protection stored
;	0		- Error in system service call
;
; SIDE EFFECTS:
;	NONE
;--

	.ENTRY	DBG$CHECK_PROT,^M<>

	PROBEW	#0,#1,@4(AP)		; See if this byte can be written
	BEQL	1$			; No, must change protection
	MOVL	#dbg$k_no_reset,R0	; Yes, set return value
	RET				;  to no change, and return

1$:	PUSHL	4(AP)			; Get address passed as argument
	PUSHL	4(AP)			; Same address for end of area
	MOVL	SP,R0			; Save stack address
	$SETPRT_S INADR=(R0),PROT=#prt$c_uw,PRVPRT=@8(AP); Change protection
	BLBC	R0,2$			; Return error if service failed
	MOVL	#dbg$k_reset_prt,R0	; Service succeeded, set return value
	RET				; And return

2$:	CLRL	R0			; Set error return value
	RET


	.SBTTL	DBG$REDO_PROT	- Sets page to read only
;++
; FUNCTIONAL DESCRIPTION:
;	Sets the protection of a page to a specified protection.
;
; CALLING SEQUENCE:
;	4(AP)	- Address of byte whose protection must be changed
;	8(AP)	- Address of byte which contains the new protection
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUTS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	NONE
;
; SIDE EFFECTS:
;	SIGNAL "DBG$_NOWPROT" if page cannot be write protected.
;--

	.ENTRY	DBG$REDO_PROT,^M<>	; Null entry mask

	PUSHL	4(AP)			; Get address passed as argument
	PUSHL	4(AP)			; Same address for end of area
	MOVL	SP,R0			; Save stack address
	MOVZBL	@8(AP),R1		; Get protection of this page
	$SETPRT_S INADR=(R0),PROT=R1	; Reset protection
	BLBS	R0,1$			; Return if service succeeded
	PUSHL	#dbg$_nowprot		; If not, tell user that protection
	CALLS	#1,G^LIB$SIGNAL		; Resetting did not work
1$:	RET				; And return

fix_up_addresses:
	MOVAB	term_handler,fix_1	; [TEMP]
	MOVAB	term_reason,fix_2	; [TEMP]
	MOVAB	restore_context,fix_3	; [TEMP]
	MOVAB	term_reason,fix_4	; [TEMP]
	MOVAB	dbg$runframe,dbg$gl_runframe
	RSB


; *****SSI
;
; Abstract:
;
; In VAX DEBUG, watchpoints are implemented by write-protecting the page  
; containing the watched variable.  An access violation on that page signals
; to DEBUG that the watched variable may be changed.  The problem with this 
; implementation is that it can cause system services that write to locations
; on the write-protected page to fail.  
;
; The way we have solved this problem is to intercept system services.  We have
; changed the System Service vector to jump into intercept code, which then 
; calls a interception DEBUG routine.  In the DEBUG routine, we unprotect the 
; write-protected page and set bit 15 of the saved PSW in the system service
; call frame on the stack. The system service then executes.  When the system 
; service returns, the bit in the saved PSW caused a reserved operand fault
; which DEBUG catches.  DEBUG can then check for changes to the watched 
; variables and reset the page protections.
;
; In DEBUG, the code itself to take to implement this scheme is not much.
; The difficulty is to put all the interactions together and make it all to
; work properly.  Both DEBUG and System Service Intercept code are highly
; re-entriant in an unpredicatable way.  System service can originated
; from user program, from DBG/TDBG or from SDBG, System service can call
; system service.  DEBUG has it own events (Break points, Stepping, Go, 
; RET, etc.) at DBG/TDBG and SDBG levels.  The communication between the levels 
; is important (in the past, TDBG/SDBG acts quite seperately), the orderring of
; the instruction sequences is important.  It is likely things are working
; fine in 2 levels' interactions (user and DBG), one should really test
; 3 levels interactions by hand (user, TDBG and SDBG).
;
; DBGSSISHR.EXE is a priveleged shareable image at the moment which sets up
; the system service interception.  This is the communication path between
; user program, DBG/TDBG, and SDBG.  It is important to call this image
; to find out what are the others doing at the moment and to tell the others
; what am I doing at the moment.  It is not necessary to activate the 
; interception each time this image is called.  This image is intended to be 
; an unsupported system service in the future (or never will be).
; In the meantime, this image is part of the DEBUG source.  This image runs
; in kernal mode, so any changes made to this image should be tested on
; stand alone machine.
;
;
; There are things still not working correctly:
;
; 1. If one sets watch points in both TDBG and SDBG (interceptions are 
;    active), system service is originated from user:
; 
;    user         dbg_ssi_routine           sdbg_ssi_routine
;    sys$xxx  --> sees it (set bit 15)  --> sees it (bit 15 set)  -->|
;                                                                    |
;             <-- RET     (bit 15 off,  <-- RET     (bit 15 set)  <--V
;                          t-bit over)
;
;    At each level, normal DEBUG interactions are going on.  The problem
;    here is after sdbg_ssi_routine is called, bit 15 is off (where it
;    should have been set), SDBG went into a loop.
;
;  2. If one sets same watch point on a user variable from both TDBG and SDBG.
;     This variable is changed by a system service originated from user.
;     Because the problem I mentioned above, I have changed the picture
;     a bit, so the SDBG won't go into a loop:
;
;    user         dbg_ssi_routine           sdbg_ssi_routine
;    sys$xxx  --> sees it (set bit 15)  --> sees it (pass)        -->|
;                                                                    |
;             <-- RET     (bit 15 off,  <-- RET     (pass)        <--V
;                          t-bit over)
;
;      Now the problem is not be able to report the watched variable correctly
;      in this case.  (I consider this is a feature for now).
;
;  3. One can step into user program from SDBG level, this can confuse the
;     things.
;
;  4. Unknown problems?
;

; Main interface to enable the intercept system service.
;
    	.ENTRY	ENABLE_SSI,^M<>
    	cmpl	#1,#dbg$gl_3b_system	; VMS 4 system? (link flag check)
    	beql	enable_ssi_3b		; Yes, next check
    	ret				; No, simply return
enable_ssi_3b:
    	cmpl	#1,#dbg$gl_setssi	; VMS 4 system linked with 
    					;  DBGSSISHR.EXE? (link flag check)
    	beql    enable_start		; Yes, things start to happen
    	ret				; No, simply return
ENABLE_START:
    	PUSHR	#^M<R0>			; R0 is used randomly in DBGSTART
    					;  for purpose, save it to be safe
    	CLRL	DBG_ONCE_ONLY_CNT	; Since we are leaving DEBUG, clear
    					;  this re-entriant count
	JSB	TRIGGER_SSI		; Is any watch point active?
	BBS	#DBG$V_CONTROL_SDBG,DBG$GV_CONTROL,2$; If SDBG is running

; DBG/TDBG is running now.
;
    	MOVL	#^X03000300,DBG_SETUP   ; Initialize the variable, from
    					;  left to right, user mode, not
    					;  active, priority 3, SSI disabled.
    	TSTL	DBG_SSI_CNT		; Have we intercepted before?
    					;  (DBG_SSI_ROUTINE called?)
    	BEQL	1$			; No
    	BISB2	SAVE_SSI_STATE,DBG$GV_SSI_CONTROL; Yes, merge (OR) running 
    					;  status from intercept code in P0,
    					;  we got to make sure the info. has
    					;  flowed through all levels during
    					;  one service call, regardless the
    					;  interactions happen in the back.
1$:    	BISB2	DBG$GV_SSI_CONTROL,DBG_SETUP+2; Merge (OR) again into state
    					;  vector 3rd byte now
    	BLBS	DBG$GB_SET_SSI_CNT,11$  ; Any watch pointing active at this
    					;  level?
    	BICB2	#DBG$M_SSI_ROUTINE_3,DBG_SETUP+2; No, Tell the 3rd bit in 3rd 
    					;  byte in state vector that priority
    					;  3 is not active
    	BRB	12$
11$:	BISB2	#DBG$M_SSI_ROUTINE_3,DBG_SETUP+2; Yes, Tell the 3rd bit in 3rd
    					;  byte in state vector that priority
    					;  3 is active
12$:	BISB2	DBG$GB_SET_SSI_CNT,DBG_SETUP; Now, finally set the enable/disable
    					;  bit depending on whether the watch
    					;  point is set or not
    	PUSHAB	SAVE_STATE		; Save old state, not used here
	PUSHAB	DBG_ROUTINE_ID		; Must keep this ID around, retunred
					;  ID value from SSI_USS
	PUSHAB	G^DBG_SSI_ROUTINE	; user supplied routine to be called
					;  at the time system service is
					;  intercepted
	PUSHL	DBG_SETUP		; Enable/Disable DEBUG routine
	CALLS	#4,G^SSI_USSU		; Invoke routine in privileged library
					;  to setup intercept system service
	BRB	4$			; Join the common code


; SDBG is running now.
;
2$:	
    	MOVL	#^X03000400,SDBG_SETUP	; Initialize the variable, from left
    					;   to right, user mode, not active,
    					;   priority 4, SSI disabled
    	TSTL	DBG_SSI_CNT		; Have intercept before?
    	BEQL	3$			; No
    	BISB2	SAVE_SSI_STATE,DBG$GV_SSI_CONTROL; Yes, merge (OR) running
    					;   status from intercept code in P0
3$:    	BISB2	DBG$GV_SSI_CONTROL,SDBG_SETUP+2; Merge (OR) again into state
    					;   vector
    	BLBS	DBG$GB_SET_SSI_CNT,31$	; Any watch pointing active at this
    					;   level?
    	BICB2	#DBG$M_SSI_ROUTINE_4,SDBG_SETUP+2; No
    	BRB	32$
31$:	BISB2	#DBG$M_SSI_ROUTINE_4,SDBG_SETUP+2; Yes
32$:	BISB2	DBG$GB_SET_SSI_CNT,SDBG_SETUP; Finally, enable/disable SSI
    	PUSHAB  SAVE_STATE		; Save old state, not used here
	PUSHAB	SDBG_ROUTINE_ID		; Must keep this ID around, retunred
					;  ID value from SSI_USS
	PUSHAB	G^DBG_SSI_ROUTINE	; user supplied routine to be called
					;  at the time system service is
					;  intercepted
	PUSHL	SDBG_SETUP		; Enable/Disable SDBG routine 
	CALLS	#4,G^SSI_USSU		; Invoke routine in privileged library
					;  to setup intercept system service
4$:
    	BLBS	R0,5$			; Test to see if SSI_USS failed
    	$EXIT_S R0			; Yes, out!!!

5$:	
    	POPR	#^M<R0>			; Pop R0, RET
	RET

; Main interface to disable the intercept system service.
; NOTE: DEBUG interception routine is always not active.  SSI is enabled
; only if there is a watch point set.
;
    	.ENTRY	DISABLE_SSI,^M<>
    	cmpl	#1,#dbg$gl_3b_system	; VMS 4 system? (link flag check)
    	beql	disable_ssi_3b		; Yes, next check
    	ret				; No, simply return
disable_ssi_3b:
    	cmpl	#1,#dbg$gl_setssi	; VMS 4 system linked with 
    					;  DBGSSISHR.EXE? (link flag check)
    	beql    disable_start		; Yes, things start to happen
    	ret				; No, simply return
DISABLE_START:
    	PUSHR	#^M<R0,R1>
    	INCL	DBG_ONCE_ONLY_CNT	; Keep track of re-entriant times
    	JSB	TRIGGER_SSI		; Is any watch point active?
	BBS	#DBG$V_CONTROL_SDBG,DBG$GV_CONTROL,2$
					; If SDBG is running

; DBG or TDBG is running
    	MOVL	#^X03000300,DBG_SETUP   ; Initialize the variable, from
    					;   left to right, user mode, not
    					;   active, priority 3, SSI disabled
    	BISB2	DBG$GB_SET_SSI_CNT,DBG_SETUP; Enable/Disable SSI depending on
    					; whether watch point is set or not
    	PUSHAB  SAVE_STATE		; Save the old state, must remember
    					;  the state when DEBUG is first time
    					;  entered
	PUSHAB	DBG_ROUTINE_ID		; Must keep this ID around, retunred
	PUSHAB	G^DBG_SSI_ROUTINE	; user supplied routine to be called
					;  at the time system service is
					;  intercepted
					; ID value from SSI_USS
	PUSHL	DBG_SETUP		; Setup the SSI_USS
	CALLS	#4,G^SSI_USSU		; Invoke routine in privileged library
					;  to setup intercept system service
	BRB	4$

; SDBG is running
2$:
    	MOVL	#^X03000400,SDBG_SETUP  ; Initialize the variable, from left
    					;   to right, user mode, not active,
    					;   priority 4, SSI disabled
    	BISB2	DBG$GB_SET_SSI_CNT,SDBG_SETUP; Enable SSI if watch point set
    	PUSHAB  SAVE_STATE		; Save the old state, must 
	PUSHAB	SDBG_ROUTINE_ID		; Must keep this ID around, retunred
					;  ID value from SSI_USS
	PUSHAB	G^DBG_SSI_ROUTINE	; user supplied routine to be called
					;  at the time system service is
					;  intercepted
	PUSHL	SDBG_SETUP		; Setup the SSI_USS
	CALLS	#4,G^SSI_USSU		; Invoke routine in privileged library
					;  to setup intercept system service
4$:
    	BLBS	R0,5$			; Test to see if SSI_USS failed
    	$EXIT_S R0			; Yes, out!!!
5$:
    	CMPL	DBG_ONCE_ONLY_CNT,#1    ; First time enter DEBUG
    	BNEQ    6$			; No
    	MOVB	SAVE_STATE,DBG$GV_SSI_CONTROL; Yes, remember its original state
6$:
    	POPR	#^M<R0,R1>
	RET

; This routine is used to determine whether a watch point is set or not.
;
TRIGGER_SSI::
    	CLRB	DBG$GB_SET_SSI_CNT	; Assume there is no watch point active
    	TSTL	EVENT$PAGE_QUEUE	; A list of watched pages is there?
    	BEQL	3$			; No
    	MOVL	EVENT$PAGE_QUEUE,PAGE_ENTRY; Loop through the list
1$:    	MOVAB	EVENT$PAGE_QUEUE,R0	;
    	CMPL	PAGE_ENTRY,R0		; End of list?
    	BEQL	2$			; Yes
    	INCB	DBG$GB_SET_SSI_CNT	; There is one watch point
    	MOVL	@PAGE_ENTRY,PAGE_ENTRY	; Next
    	BRB	1$
2$:	TSTB	DBG$GB_SET_SSI_CNT	; Any watched page found?
    	BEQL	3$			; No
   	MOVB	#1,DBG$GB_SET_SSI_CNT	; Yes, flag it
    	PUSHAB	DUMMY
    	CALLS	#1,G^SSI_USSK		; Call the Kernel mode routine to
3$:    	RSB				;  Set up the interception, if 
    					;  interception is already setup
    					;  call simply returns


; DEBUG Interception routine.
;
	.ENTRY	DBG_SSI_ROUTINE,^M<>
DBG$PSEUDO_SSI::
	MOVAL	DBG_SSI_ROUTINE_HANDLER,(FP)
    					; Declare its own stack handler
    					;   so primary handler can resignal
    					;   DBG$_NORMAL, so stack handler
    					;   has a chance to catch this signal
    					;   and change it to DBG$_SS_INT
	INCL	DBG_SSI_CNT		; Mark the fact we see one
    	MOVB	24(AP),SAVE_SSI_STATE	; Get the communication variable
    					;   at the time this routine is called
	PUSHL	20(AP)			; Pass in Address of the system service
    					;   count (this system service may be
    					;   nested)
	PUSHL	16(AP)			; Pass in Address of the system service
    					;   RET count (this system service may
    					;   return from SDBG, then TDBG)
	PUSHL	12(AP)			; FP of the system service
	PUSHL	8(AP)			; AP of the system service
	PUSHL	4(AP)			; System service index
	PUSHL	#5			; # of arguments
	PUSHL	#DBG$_NORMAL		; A way to get back into DEBUG
	CALLS	#7,G^LIB$SIGNAL		; Signal it.
	MOVL	#1,R0			; Interception done, return
    	CLRB	SAVE_SSI_STATE		; No use for the communication variable
    					;   clear it, make sure there is no
    					;   side facts after using it
	RET

; DEBUG Interception routine handler
;
	.ENTRY	DBG_SSI_ROUTINE_HANDLER,^M<>
    	BSBW	SAVE_USER_CONTEXT_ALWAYS; Save user context
    	MOVL	CHF$L_SIGARGLST(AP),R2	; Change DBG$_NORMAL to
	MOVL	#DBG$_SS_INT,4(R2)	; DBG$_SSI_INT
	BRW	PRIM_4			; Act as though its a normal exception

	.END  	beginhere	
