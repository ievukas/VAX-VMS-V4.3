	.TITLE	RTTDRIVER - Remote Terminal Driver
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS Remote Terminal Driver
;
; ABSTRACT:
;
;	This module contains the remote terminal driver routines.  This driver
;	is used by the application process side of the operation.  In other
;	words, it receives the QIO requests from the process that does not
;	have local access to the terminal.
;
;	This driver's primary function is to receive QIO system service
;	requests, repackage the QIO arguments, and hand the new package to
;	the tranport mechanism for delivery to the remote terminal
;	handler process on the system with local access to the terminal.
;	The transport mechanism is DECnet.  Netdriver is called directly
;	via the internal IRP mechanism.
;
; AUTHOR:
;
;	Len Kawell, 01-AUG-1979
;
; MODIFICATION HISTORY:
;
;	V03-014	JLV0390		Jake VanNoy		25-JUL-1984
;		Return ILLIOFUNC for FMS when PICSTRING is seen.
;
;	V03-013	LMP0275		L. Mark Pilant,		12-Jul-1984  12:42
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-012 EMD0088		Ellen M. Dusseault	30-Apr-1984
;		Add DEV$M_NNM characteristic to DEVCHAR2 so that these
;		devices will have the "node$" prefix.
;
;	V03-011	LMP0221		L. Mark Pilant,		27-Mar-1984  11:53
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-010	JLV0320		Jake VanNoy		18-DEC-1983
;		Remoe SS$_INCOMPAT from read fdt routine.  This error
;		is preventing set host from RSX and TOPS20.
;		Change write routine to send broadcast type message
;		if IO$M_BREAKTHRU is seen.  Remove RTT_BROADCAST routine
;		as it is obsolete.  Redo SET_MODE FDT to use case statement.
;		Clear io$m_extend bit in read routine. Remove CTRLC
;		and outband from SENSE_SPAWN.
;
;	V03-009	JLV0299		Jake VanNoy		30-JUL-1983
;		Add DEV$M_RTT to DPT_STORE's.
;
;	V03-008	JLV0252		Jake VanNoy		13-MAY-1983
;		Remove references to IO$M_ENABL_ALT and IO$M_DSABL_ALT.
;
;	V03-007	JLV0241		Jake VanNoy		20-APR-1983
;		Change ASSUME regarding TRM$_LASTITM.
;
;	V03-006	JLV0239		Jake VanNoy		29-MAR-1983
;		Add code to do new itemlist, remove V3.2 code to
;		handle read verify.
;
;	V03-005	JLV0227		Jake VanNoy		 9-FEB-1983
;		Bug fix in error path of ALLOC_MESSAGE that caused
;		system crash. Another bug fix to the read fdt routine
;		that crashed system with large prompt size.
;
;	V03-004	JLV0215		Jake VanNoy		 6-OCT-1982
;		Mods to SBL3007 to do parameter checking correctly.
;
;	V03-003	SBL3007		Steve Long	6-Aug-1982
;		Read verify support and permit IO$M_ENABL_ALT &
;		IO$M_DSABL_ALT to be processed in SETMODE
;
;	V03-002	DJD3007		Darrell Duffy	5-April-1982
;		Trap IO$M_ESCAPE and IO$M_EXTEND with reads to V2 systems.
;		Trap IO$M_ENABL_ALT IO$M_DSABL_ALT in SETMODE.
;
;	V03-001	DJD3006		Darrell Duffy	31-March-1982
;		Fix SENSEMODE TYPAHDCNT to return correct status.
;		Insert setting of mode bits for fixing spawn.
;
;	V02-016	DJD3005		Darrell Duffy	13-January-1982
;		Fix flushing of CTRL/Y to occur at deassign.
;		Use new cancel interface to distinguish cancel and deassign.
;
;	V02-015	DJD3004		Darrell Duffy	20-December-1981
;		Revert to use of attn ast processing for CTRL C and Y.
;		Remove privileges associated with declaring a ctrl/y ast.
;
;	V02-014	DJD3003		Darrell Duffy	24-November-1981
;		Add out-of-band ast support.  Fix bug in delivery
;		of hangup ast when the link has broken before it
;		was enabled.
;
;	V02-013	DJD3002		Darrell Duffy	12-November-1981
;		More of the same.
;
;	V02-012 DJD3001		Darrell Duffy	21-October-1981
;		Update for changes to terminal driver for V3.0
;
;	V02-011	DJD2004		Darrell Duffy	31-July-1981
;		Change broadcast interface to return failure on
;		terminal set for NOBROADCAST
;
;	V02-010 DJD2003		Darrell Duffy	2-May-1981
;		Fix double deallocate of rtt ucb.
;
;	V02-009 RLRLBCNT	Robert L. Rappaport	8-April-1981
;		Changes associated with IRP modifications to all BCNT
;		fields which have grown to longwords.  Also fix old bug
;		in RTT_WRITE which sometimes left garbage in R1.
;
;	V02-008 DJD2002		Darrell Duffy	8-Apr-1981
;		Fix race condition with broadcast messages after hangup.
;
;	V02-007	DJD2001		Darrell Duffy	5-Mar-1981
;		Change to call network driver directly to read and
;		write packets.
;
;	V02-006	LMK0006		Len Kawell	27-Feb-1981
;		Fix problem with immediate delivery of hangup AST when
;		AST is being cancelled.
;
;	1.05	LMK0005		Len Kawell	18-Mar-1980
;		Change broadcast to call EXE$ALONONPAGED.
;
;	1.04	LMK0004		Len Kawell	29-Feb-1980
;		Change adapter type in DPTAB to be NULL.
;
;	1.03	LMK0003		Len Kawell	25-Feb-1980
;		Change broadcast to not wait for completion to avoid
;		causing issuing process to indefinitely wait if delays
;		occur during remote delivery.
;
;	1.02	LMK0002		Len Kawell	21-Jan-1980
;		Add UCB$M_HANGUP flag so hangup is never lost.
;
;--

	.SBTTL	External and local symbol definitions

;
; External symbols
;

	$ACBDEF				; AST control block
	$AQBDEF				; ACP queue block
	$CANDEF				; Cancel interface codes
	$CRBDEF				; Channel request block
	$DCDEF				; Device classes and types
	$DDBDEF				; Device data block
	$DEVDEF				; Device characteristics
	$DYNDEF				; Buffer type codes
	$IDBDEF				; Interrupt data block
	$IODEF				; I/O function codes
	$IPLDEF				; Hardware IPL definitions
	$IRPDEF				; I/O request packet
	$JIBDEF				; Job Information block
	$MSGDEF				; Mailbox message types
	$ORBDEF				; OBJECT'S RIGHTS BLOCK OFFSETS
	$PCBDEF				; Process control block
	$PRDEF				; Processor registers
	$PRVDEF				; Privilege bits
	$PSLDEF				; Processor status longword
	$RBFDEF				; Remote Device Buffer definitions
	$RDPDEF				; Remote device packet
	$REMDEF				; General constants
	$SSDEF				; System status codes
	$TRMDEF				; Item list definitions
	$TTDEF				; Terminal definitions
	$TT2DEF				; More definitions
	$TTYDEF				; Terminal driver definitions
	$UCBDEF				; Unit control block
	$VCBDEF				; Volume control block
	$VECDEF				; Interrupt vector block

;
; Local symbols
;

;
; Argument list (AP) offsets for device-dependent QIO parameters
;

P1	= 0				; First QIO parameter
P2	= 4				; Second QIO parameter
P3	= 8				; Third QIO parameter
P4	= 12				; Fourth QIO parameter
P5	= 16				; Fifth QIO parameter
P6	= 20				; Sixth QIO parameter



;
; Other constants
;

RTT$K_FIPL = 8				; IPL to synchronize

;
; Definitions that follow the standard UCB fields
;

	$RTTUCBEXT			; UCB Extensions

UCB$W_RTT_READERR = UCB$W_CT_QCTPCNT	; unused cterm UCB field

;
; Redefinitions of the irp fields
;

IRP$W_RTT_COMPAT = IRP$Q_TT_STATE	; Set for compatiblity error


	.SBTTL	Standard tables

;
; Driver prologue table
;

	DPTAB	-				; DPT-creation macro
		END=RTT_END,-			; End of driver label
		ADAPTER=NULL,-			; Adapter type
		UCBSIZE=<UCB$K_RTT_LEN>,-	; Length of UCB
		NAME=RTTDRIVER			; Driver name
	DPT_STORE INIT				; Start of load
						; initialization table
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\REM\> 	; Default ACP name
	DPT_STORE DDB,DDB$L_ACPD+3,B,3		; ACP class
	DPT_STORE UCB,UCB$B_FIPL,B,RTT$K_FIPL	; Device fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,RTT$K_FIPL	; Device interrupt IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-	; Device characteristics
		DEV$M_REC!-			;   record device
		DEV$M_AVL!-			;   available
		DEV$M_IDV!-			;   input device
		DEV$M_ODV!-			;   output device
		DEV$M_TRM!-			;   terminal device
		DEV$M_CCL>			;   carriage control device
	DPT_STORE UCB,UCB$L_DEVCHAR2,L,<-	; Device characteristics
		DEV$M_RTT!-			; remote terminal UCB extension
    		DEV$M_NNM>			; prefix with "node$"
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM	; Terminal device
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN ; Unknown type
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF ; Default buffer size
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR ; Default characteristics
	DPT_STORE ORB,ORB$B_FLAGS,B,-		; Protection block flags
			   <ORB$M_PROT_16>	; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,@W,TTY$GW_PROT ; Default allocation protection
	DPT_STORE ORB,ORB$L_OWNER,@L,TTY$GL_OWNUIC ; Default owner UIC

	DPT_STORE REINIT			; Start of reload
						; initialization table
	DPT_STORE DDB,DDB$L_DDT,D,RTT$DDT	; Address of DDT
	DPT_STORE CRB,CRB$L_INTD+4,D,-		; Address of interrupt
		RTT_INTERRUPT			; service routine

	DPT_STORE END				; End of initialization
						; tables

;
; Driver dispatch table
;

	DDTAB	-				; DDT-creation macro
		DEVNAM=RTT,-			; Name of device
		FUNCTB=RTT_FUNCTABLE,-		; FDT address
		UNSOLIC=RTT_UNSOLIC,-		; Unsolicited attention routine
		CANCEL=RTT_CANCEL		; Cancel I/O routine

;
; Function dispatch table
;

RTT_FUNCTABLE:					; FDT for driver
	FUNCTAB	,-				; Valid I/O functions
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		READPROMPT,-			; Read with prompt
		TTYREADALL,-			; Read passall
		TTYREADPALL,-			; Read with prompt passall
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK,-			; Write physical
		SENSEMODE,-			; Sense device mode
		SENSECHAR,-			; Sense device characteristics
		SETMODE,-			; Set device mode
		SETCHAR>			; Set device characteristics
	FUNCTAB	,-				; Buffered functions
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		READPROMPT,-			; Read with prompt
		TTYREADALL,-			; Read passall
		TTYREADPALL,-			; Read with prompt passall
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK,-			; Write physical
		SENSEMODE,-			; Sense device mode
		SENSECHAR,-			; Sense device characteristics
		SETMODE,-			; Set device mode
		SETCHAR>			; Set device characteristics
	FUNCTAB	RTT_READ,-			; FDT read routine for
		<READVBLK,-			; read virtual,
		READLBLK,-			; read logical,
		READPBLK,-			; read physical,
		READPROMPT,-			; read with prompt
		TTYREADALL,-			; read passall,
		TTYREADPALL>			; and read with prompt passall
	FUNCTAB	RTT_WRITE,-			; FDT write routine for
		<WRITEVBLK,-			; write virtual,
		WRITELBLK,-			; write logical,
		WRITEPBLK>			; and write physical.
	FUNCTAB	RTT_SENSEMODE,-			; FDT sense mode routine
		<SENSECHAR,-			; for sense characteristics
		SENSEMODE>			; and sense mode.
	FUNCTAB	RTT_SETMODE,-			; FDT set mode routine
		<SETCHAR,-			; for set characteristics and
		SETMODE>			; set mode.

	.SBTTL	RTT_WRITE - Function Decision Routine for WRITE Functions
;++
; RTT_WRITE - Function Decision Routine for WRITE Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a WRITE
;	I/O request.
;
;	The QIO parameters for terminal WRITES are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	P3 = (unused)
;	P4 = carriage control specifier
;
;	The buffer is validated for access, the process's quota checked and
;	decremented, the data and carriage control are copied to a message
;	block, the address of the message block is stored in the IRP,
;	and the IRP is queued to the ACP for delivery to the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;	IRP$W_BCNT(R3) = size of user buffer
;
;	The routine preserves all registers except R0-R2, and
;	R9-R11.
;
;--
RTT_WRITE:				; WRITE FDT routine
	MOVL	P1(AP),R6		; Get user buffer virtual address
	MOVL	R6,R0			; Set up for write check call
	MOVZWL	P2(AP),R7		; Get buffer size
	MOVL	R7,R1			; Set up for write check call
	BEQL	10$			; Skip check if zero
	JSB	G^EXE$WRITECHK		; Check buffer access
					; (no return means no access)
;
; Allocate the message buffer
;
10$:
	ADDL	#RBF$T_TT_WDATA,R1	; Add header to request size 
	BSBW	ALLOC_MESSAGE		; Allocate the message buffer
;
; Copy the data and carriage control to the message
;
	MOVZWL	R7,RBF$L_TT_BCNT(R2)	; Set requested byte count
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVZWL	IRP$W_FUNC(R3),R4	; save function code and modifiers
	MOVL	P4(AP),R10		; save carriage control
	BBC	#IO$V_BREAKTHRU,R4,20$	; Branch if not breakthru
;
; Format message so that it looks like the old broadcast message. Note
; carriage control is cleared. This is a shortcoming
; in this implementation, but this code will be obsolete shortly...
;	
	MNEGW	#1,RBF$W_OPCODE(R2)	; Set function code for broadcast
	CLRW	RBF$W_MOD(R2)		; No modifier bits here
	CLRL	R10			; set no carriage control
20$:
	MOVC3	R7,(R6),RBF$T_TT_WDATA(R2) ; Copy data
	MOVL	R3,R1			; Save adr beyond data
	POPR	#^M<R2,R3,R4,R5>	; Restore the registers
	MOVL	R10,RBF$L_TT_CARCON(R2) ; Copy carriage control
;
; Send the message to the remote device and exit QIO service
;
	MOVL	R1,R2			; Pointer beyond data in message
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatibility error
	BRW	RTT_NETMSGSENDX		;

	.SBTTL	RTT_READ - Function Decision Routine for READ Functions

;++
; RTT_READ - Function Decision Routine for READ Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a READ
;	I/O request.
;
;	The QIO parameters for terminal READS are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	P3 = number of seconds to wait for characters
;	P4 = address of terminator class bitmask or 0 if standard
;	P5 = address of prompt string for IO$_READPROMPT or IO$_TTYREADPALL
;	P6 = size of prompt string for IO$_READPROMPT or IO$_TTYREADPALL
;
;	The buffer is validated for access, the process's quota checked and
;	decremented, the timeout, terminator mask, and prompt are copied to a
;	message block, the address of the message block is stored in the IRP,
;	and the IRP is queued to the ACP for delivery to the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;	IRP$L_MEDIA(R3) = address of user buffer
;	IRP$W_BCNT(R3) = size of user buffer
;
;	The routine preserves all registers except R0-R2, and
;	R9-R11.
;
;--

; Local storage offsets on stack:

bufaddr = 0
bufsize = 4
prmaddr = 8
prmsize = 12
trmaddr = 16
trmsize = 20
iniaddr = 24
inisize = 28
timeout = 32
inioffset = 36

read_local = 40

RTT_READ:				; READ FDT routine
;
; Set up stack locals
;
	SUBL2	#READ_LOCAL,SP		; Allocate local storage
	MOVL	SP,R8			; Save pointer
	CLRQ	(R8)			; clear buf ***
	CLRQ	8(R8)			; clear prm ...
	CLRQ	16(R8)			; clear trm ...
	CLRQ	24(R8)			; clear ini ...
	CLRQ	32(R8)			; clear other ...
;
; Check access to user's buffer
;
	MOVL	P1(AP),R0		; Get user buffer virtual address
	MOVL	R0,IRP$L_MEDIA(R3)	; Save address in packet
	MOVZWL	P2(AP),R1		; Get buffer size
	BEQL	10$			; Skip check if zero
	MOVQ	R0,BUFADDR(R8)		; Set up for read check call
	JSB	G^EXE$READCHK		; Check buffer access
					; (no return means no access)
;
; Check for extended itemlist read
;
10$:
	BBCC	#IO$V_EXTEND,-		; If this is not item list
		IRP$W_FUNC(R3),15$	; then continue
	BSBW	RT_READ_ITMLST		; process item list
	BRW	200$			; continue	
;
; Get prompt, if specified
;
15$:
	CMPB	R7,#IO$_READPROMPT	; Read prompt?
	BEQL	20$			; Branch if yes
	CMPB	R7,#IO$_TTYREADPALL	; Read prompt?
	BNEQ	50$			; Branch if not
20$:	MOVZWL	P6(AP),R1		; Get size of prompt
	BEQL	50$			; If eql then make this normal read
	MOVL	P5(AP),R0		; Get prompt buffer address
;
; Check access to prompt string
;
	MOVQ	R0,PRMADDR(R8)		; Save address and size 
	JSB	G^EXE$WRITECHK		; Check prompt access
;
; Get terminator bitmask and check access
;
50$:
	CLRL	R2			; Assume no terminator specified
	MOVL	P4(AP),R1		; Get address of terminator desc
	BEQL	65$			; If eql none specified
	MOVZWL	#SS$_ACCVIO,R0		; Assume no access
	IFNORD	#8,(R1),63$		; Descriptor accessible?
	MOVZWL	(R1),R2			; Get bitmask size
	BNEQ	60$			; If neq long format
	MOVL	#4,R2			; Size of short format
	ADDL	#4,R1			; Set address of bitmask
	BRB	65$			;
60$:
	MOVL	4(R1),R1		; Get address of long format bitmask
	IFNORD	R2,(R1),63$		; Bitmask accessible?
	CMPW	R2,#32			; Bitmask greater than allowed size?
	BLEQU	65$			; If gtru yes
	MOVZWL	#SS$_BADPARAM,R0	; bad parameter
63$:	BRB	READ_ERROR
65$:
	MOVQ	R1,TRMADDR(R8)		; terminator address and size
	MOVL	P3(AP),TIMEOUT(R8)	; Set timeout value
200$:
;
; Commom code again, Allocate the message buffer
;
	MOVL	BUFSIZE(R8),R11		; Set size of read
	MOVW	R11,IRP$W_BCNT(R3)	; Reset read buffer size
					; (modified by EXE$WRITECHK)

	MOVL	#RBF$T_TT_TERM+3,R1	; Set header + overhead size
	ADDL	PRMSIZE(R8),R1		; Prompt size
	ADDL	TRMSIZE(R8),R1		; terminator size
	BSBW	ALLOC_MESSAGE		; Allocate the message buffer
;
; Copy the timeout, terminator bitmask, and prompt string to the message
;
	MOVL	R11,RBF$L_TT_BCNT(R2)	; Set requested byte count
	MOVL	TIMEOUT(R8),-
		RBF$L_TT_TIMOUT(R2) 	; Set timeout value
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers

	MOVQ	TRMADDR(R8),R0		; Set terminator addr and size
	MOVB	R1,RBF$T_TT_TERM(R2)	; Set terminator bitmask size
	MOVC	R1,(R0),RBF$T_TT_TERM+1(R2) ; Copy terminator bitmask

	MOVQ	PRMADDR(R8),R0		; Set prompt addr and size
	MOVW	R1,(R3)+		; Set size of prompt
	MOVC	R1,(R0),(R3)		; Copy prompt string

	MOVL	R3,R1			; Save adr beyond data
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
;
; Send the message the remote device and exit the QIO service
;
	MOVL	R1,R2			; Set address beyond data
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatiblity error
	BRW	RTT_NETMSGSENDX		;
;
; Error in processing
;
READ_ERROR:				; READ FDT error
	JMP	G^EXE$ABORTIO		; Abort the I/O request

	.SBTTL	RT_READ_ITMLST - FDT routine for read with item list
;++
;
;
;
; *** a clean up pass is needed to here to verify that the paranoia
;     checks made by TTDRIVER and this driver are the same.
;
;--

RT_READ_ITMLST:

	;
	; Set up probe of itemlist with P3 as access mode
	;
	MOVL	R3,R6			; Save IRP
	EXTZV	#0,#2,P3(AP),R0		; fetch low 2 bits of parameter
	JSB	G^EXE$MAXACMODE		; maximize with mode of caller
	MOVL	R0,R3			; Set input to probe routine

	MOVL	P5(AP),R0		; Address of itemlist
	MOVL	P6(AP),R1		; size of item list
	BEQL	10$			; can't be zero?
	MOVQ	R0,R10			; save both
	BRB	30$			; ok, continue
10$:	MOVZWL	#SS$_BADPARAM,R0	; status
20$:	MOVL	R6,R3			; Restore IRP
	BRB	READ_ERROR		; abort

30$:	JSB	G^EXE$PROBER		; Can it be read?
	BLBC	R0,20$			; branch if not 
	MOVL	R11,R0			; size
	;
	; Verify that size is multiple of 12
	;
	MOVL	R6,R3			; Restore IRP
	CLRL	R1			; quadword r0/r1
	EDIV	#12,R0,R11,R0		; divide
	TSTL	R0			; must be zero remainder
	BNEQ	10$			; error
	;
	; Now loop and conquer item list, item by item
	;
40$:
	MOVZWL	(R10)+,R1		; Length
	MOVZWL	(R10)+,R2		; item code
	MOVL	(R10)+,R0		; address or immediate value
	TSTL	(R10)+			; Must be zero field
	BNEQ	10$			; error if not

	CASE	R2,-			; case on message type
		<100$,-			; TRM$_MODIFIERS	(0)
		200$,-			; TRM$_EDITMODE		(1)
		300$,-			; TRM$_TIMEOUT		(2)
		400$,-			; TRM$_TERM		(3)
		500$,-			; TRM$_PROMPT		(4)
		600$,-			; TRM$_INISTRING	(5)
		700$,-			; TRM$_PICSTRING	(6)
		800$,-			; TRM$_FILLCHR		(7)
		900$,-			; TRM$_INIOFFSET	(8)
		1000$-			; TRM$_ALTECHSTR	(9)
		>,-			; TRM$_LASTITM		(10)
		TYPE = W

	ASSUME	TRM$_LASTITM EQ 10	; Break assembly if not right
	BRB	10$	

100$:			; TRM$_MODIFIERS

	BICW	#IO$M_EXTEND,R0		; clear extend bit
	BISW	R0,IRP$W_FUNC(R3)	; Set read flags
	BRB	2000$			; Loop

200$:			; TRM$_EDITMODE
	BRB	2000$			; ignore

300$:			; TRM$_TIMEOUT
	
	MOVL	R0,TIMEOUT(R8)		; Set timeout
	BISW	#IO$M_TIMED,IRP$W_FUNC(R3) ; set read timed bit
	BRB	2000$			; loop

400$:			; TRM$_TERM
	TSTL	R1			; test length
	BNEQ	410$			; If neq long format
	MOVL	#4,R1			; Size of short format
	MOVAB	-8(R10),R0		; Address of immediate data *** hack
	BRB	430$			; skip
410$:
	IFNORD	R1,(R0),420$		; Bitmask accessible?
	CMPW	R1,#32			; Bitmask greater than allowed size?
	BLEQU	430$			; If less than or equal, no
	BRB	10$			; bad param *** other status?
420$:	MOVZWL	#SS$_ACCVIO,R0		; access violation
	BRW	READ_ERROR		; branch to read error
430$:
	MOVQ	R0,TRMADDR(R8)		; save address and size of terminators
	BRB	2000$			; continue
	
500$:			; TRM$_PROMPT
	MOVQ	R0,PRMADDR(R8)		; save address and length
	INSV	#IO$_READPROMPT,-
		#IRP$V_FCODE,#IRP$S_FCODE,-
		IRP$W_FUNC(R3)		; Set Read with prompt
	BRB	650$			; continue

700$:			; TRM$_PICSTRING
	MOVZWL	#SS$_ILLIOFUNC,R0	; for FMS...
	BRW	READ_ERROR

1000$:			; TRM$_ALTECOSTR
600$:			; TRM$_INISTRING
	MOVQ	R0,INIADDR(R8)		; save address and length
650$:	TSTL	R1			; no need to check if zero
	BEQL	2000$			; Skip parameter
	BSBB	CHK_READERR		; check for read error
	BRB	2000$			; continue

800$:			; TRM$_FILLCHR
900$:			; TRM$_INIOFFSET
	TSTW	R0			; test to see if present
	BEQL	2000$			; branch if not
	BSBB	CHK_READERR		; check for read error

2000$:
	SOBGTR	R11,2010$		; loop
	RSB

2010$:	BRW	40$			; 

CHK_READERR:

	MOVZWL	UCB$W_RTT_READERR(R5),R0 ; set status
	MOVW	#SS$_NORMAL,-
		UCB$W_RTT_READERR(R5)	; set success if this happens again
	BLBC	R0,10$			; branch if error
	RSB				; continue without error
10$:	BRW	READ_ERROR		; abort


	.SBTTL	RTT_SETMODE, Function Decision Routine for SETMODE/SETCHAR
;++
; RTT_SETMODE, Function Decision Routine for SETMODE/SETCHAR Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a SETMODE
;	or SETCHAR I/O request.
;
;	The QIO parameters for terminal SETMODE or SETCHAR are:
;
;
;		P1 = address of 8 byte characteristics buffer
;		P2 = 0, 8 or 12
;		P3 = speed specifier
;		P4 = fill specifier
;		P5 = parity flags
;
;	IO$V_CTRLYAST -
;		P1 = AST routine address or zero to cancel
;
;	IO$V_CTRLCAST -
;		 P1 = AST routine address or zero to cancel
;
;	IO$V_HANGUP -
;		NONE
;
;	The buffer (if any) is validated for access, the process's quota
;	checked and decremented, a message block is allocated, the parameters
;	(if any) are stored in the  message block, the address of the message
;	block is stored in the IRP, and the IRP is queued to the ACP for
;	delivery to the remote system.
;
;	If an AST is to be enabled, an AST control block is allocated locally
;	hung off the UCB for later delivery upon receipt of a corresponding
;	attention message from the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;
;	The routine preserves all registers except R0-R2, R7, and R9-R11
;--
RTT_SETMODE:				; SETMODE/SETCHAR FDT routine
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatibility error
	MOVZWL	IRP$W_FUNC(R3),R0	; Fetch function code and modifers
	FFS	#IO$V_MAINT,#9,R0,R1	; Find first set modifier
	BEQL	SET_CHAR		; if none then simple set mode.

	BITW	#<IO$M_CTRLCAST!-
		IO$M_CTRLYAST!-
		IO$M_HANGUP>,R0		; Always legal functions
	BNEQ	30$			; branch if any of these

	TSTB	UCB$B_RTT_PROECO(R5)	; Previous version
	BNEQ	30$			; Nope
	MOVZWL	#SS$_INCOMPAT+3, R0	; Abort maintenance, outband, etc.
	BRW	ABORT			; with an error not success
30$:
	CASE	R1,TYPE=B,LIMIT=#IO$V_MAINT,<-
		SET_MAINT,-		; IO$M_MAINT
		SET_CTRLY,-		; IO$M_CTRLYAST
		SET_CTRLC,-		; IO$M_CTRLCAST
		SET_HANGUP,-		; IO$M_HANGUP
		SET_OUTBAND,-		; IO$M_OUTBAND
		SET_CONNECT,-		; IO$M_CONNECT
		SET_DISCONNECT,-	; IO$M_DISCONNECT
		SET_PID,-		; IO$M_SETPID
		SET_BRDCST>		; IO$M_BRDCST
;
; invalid characteristic if CASE falls though
;
	MOVZWL	#SS$_ILLIOFUNC, R0	; Return as illegal operation
	BRW	ABORT			; with an error not success

SET_CHAR:
	BSBW	GET_PARAMS		; validate and fetch parameters
	MOVL	UCB$L_DEVDEPND2(R5),R11	; Extended word is defaulted
	MOVQ	(R1)+,R9		; Get characteristics
	CMPL	R2, #12			; Do we get another longword?
	BLSS	20$			; Nope
	MOVL	(R1)+, R11		; Obtain the third longword
20$:	MOVQ	R9,UCB$B_DEVCLASS(R5)	; Set local copy of characteristics
	MOVL	R11,UCB$L_DEVDEPND2(R5)	; And extended longword

	TSTB	UCB$B_RTT_PROECO(R5)	; If old version
	BNEQ	30$			; Nope
	BITL	# <<<1@24>-1>-<<1@TT$V_HALFDUP>-1>>,-
		UCB$L_DEVDEPEND(R5)	; If extra bits set, then
	BEQL	30$			; return incompat error
	MOVW	#SS$_INCOMPAT,-		; but carry on with function
		IRP$W_RTT_COMPAT(R3)	;
30$:
	BRW	SET_MESSAGE		; send message
	;
	; The following types of modifiers are not allowed on remote terminals
	;
SET_MAINT:
SET_CONNECT:
SET_DISCONNECT:

	MOVZWL	#SS$_DEVREQERR, R0	; Return as device request error
	BRW	ABORT			; with an error not success

SET_BRDCST:
	BSBW	GET_PARAMS		; Get parameters
	MOVQ	(R1),UCB$Q_TL_BRKTHRU(R5); Set bits
	BRB	SET_NOP			; Set done

SET_PID:
	MOVL	PCB$L_PID(R4),-
		UCB$L_TL_CTLPID(R5)	; Set controlling PID
SET_NOP:
	BRW	FDT_FINISHIOC_OK	; Complete I/O

SET_CTRLY:
	MOVAL	UCB$L_RTT_CTRLY(R5),R7	; Get address of CNTRL/Y AST list
	JSB	G^COM$SETATTNAST	; Enable an attention AST
	BBC	#UCB$V_TT_HANGUP,-
		UCB$W_DEVSTS(R5),CTRL_CY ; Branch if no hangup
	MOVL	(R7),R0			; Get address of AST block
	BEQL	CTRL_CY			; If eql, no AST to deliver
	MOVL	R7,R4			; Set address of AST listhead
	MOVZWL	#SS$_HANGUP,ACB$L_KAST+4(R0) ; Set AST parameter to hangup
	JSB	G^COM$DELATTNAST	; Deliver the AST immediately
	BRB	SET_NOP			; finish I/O

SET_CTRLC:
	MOVAL	UCB$L_RTT_CTRLC(R5),R7	; set CNTRL/C AST enable
	JSB	G^COM$SETATTNAST	; Enable an attention AST

CTRL_CY:
	MOVL	P1(AP),R9		; Get address of AST routine
					; fall htrough to send message
;
; Create SET message and send to remote device
;
SET_HANGUP:
SET_MESSAGE:				; Create and queue SET message
	MOVL	#RBF$L_TT_CHAR2+4,R1	; Set size of message buffer
	BSBW	ALLOC_MESSAGE		; Allocate a message buffer
	MOVQ	R9,RBF$Q_TT_CHAR(R2)	; Set characteristics or AST parameter
	MOVL	R11, RBF$L_TT_CHAR2(R2)	; And the next longword
	MOVL	P3(AP),RBF$L_TT_SPEED(R2) ; Set speed
	MOVL	P4(AP),RBF$L_TT_FILL(R2) ; Set fills
	MOVL	P5(AP),RBF$L_TT_PARITY(R2) ; Set parity
	CMPB	UCB$B_RTT_PROECO(R5), -	; How long should the message be?
		#REM$C_CURECO		; Long or short
	BNEQ	10$			; Shorter message
	MOVAB	RBF$L_TT_CHAR2+4(R2),R2	; Address of longer message
	BRB	20$
10$:	MOVAB	RBF$L_TT_PARITY+4(R2),R2; Set address beyond data
20$:	BRW	RTT_NETMSGSENDX		; Send message to remote and exit service

;
; Process a setmode for an outofband ast
;

SET_OUTBAND:
	BBS	#IO$V_INCLUDE, -	; Include list?
		IRP$W_FUNC(R3), 10$	;
	MOVAB	UCB$L_RTT_BANDEXCL(R5),- ; Address of exclude ast list
		R7			;
	MOVAB	UCB$L_RTT_BANDEXMSK(R5),- ; Address of the exclude mask
		R2			;
	BRB	20$

10$:	MOVAB	UCB$L_RTT_BANDINCL(R5),- ; Address of include ast list
		R7			;
	MOVAB	UCB$L_RTT_BANDINMSK(R5),- ; Address of the include mask
		R2			;
20$:
	JSB	G^COM$SETCTRLAST	; Enable the asts
	MOVL	#RBF$B_TT_OUTBAND+1+4+1+4,-;
		R1			; Set size of message
	BSBW	ALLOC_MESSAGE		; Allocate a message
	MOVAB	RBF$B_TT_OUTBAND(R2),-	; Address of data in message
		R2			;
	MOVB	#4, (R2)+		; Count for include mask
	MOVL	UCB$L_RTT_BANDINMSK(R5),-; Include mask
		(R2)+			;
	MOVB	#4, (R2)+		; Count for exclude mask
	MOVL	UCB$L_RTT_BANDEXMSK(R5),- ; Now the exclude mask
		(R2)+			;
	BRW	RTT_NETMSGSENDX		; Send the message

	.SBTTL	ABORT, Transfer to EXE$ABORTIO

;
; Error processing - abort I/O request
;
ABORT:					;
	JMP	G^EXE$ABORTIO		;

;
; Finish I/O, clear R1
;
FDT_FINISHIOC_OK:
	MOVZWL	#SS$_NORMAL,R0		; Set status OK
FDT_FINISHIOC:
	JMP	G^EXE$FINISHIOC		; Complete I/O request

	.SBTTL	GET_PARAMS - Get set mode parameters

;++
; GET_PARAMS
;
; inputs
;	AP -> qio argument list
;
; outputs
;	r1 = address of parameters
;	r2 = 8 or 12 for size of characteristics buffer
;
; ABORT if P2(ap) is not 0, 8, 12.
; Return ss$_incompat if not current system and size is 12.
;--

GET_PARAMS:

	MOVL	P1(AP),R1		; Get address of characteristics
	BSBB	RTT_CHARSIZE		; Obtain the size of the char buffer
	MOVZWL	#SS$_ACCVIO,R0		; Assume access violation
	IFNORD	R2,(R1),10$		; Characteristics accessible?
	RSB				; return
10$:
	BRB	ABORT			; error 

	.SBTTL	RTT_CHARSIZE, Size of characteristics buffer

RTT_CHARSIZE:
	MOVL	P2(AP), R2	; Size of characters buffer
	BEQL	10$		; Zero is for 8
	CMPL	R2, #8		; 8 is allowed
	BEQL	20$		; Ok
	BLSSU	30$		; Less is no good
	BSBB	RTT_ECOQ	; If greater then we must be latest
	CMPL	R2, #12		; Must be 12 and nothing else
	BNEQ	30$		; No good
	RSB			; Ok
10$:	MOVL	#8, R2		; Use 8 if zero
20$:	RSB

30$:	MOVZWL	#SS$_BADPARAM, R0	; Abort qio with an error
	BRW	ABORT

	.SBTTL	RTT_ECOQ, Validate latest eco number
;++
; RTT_ECOQ
;
; inputs
;	r3 -> irp
;	r5 -> ucb
; outputs
;	return if eco is latest,
;	else abort QIO with ss$_badparam
;--

RTT_ECOQ:
	CLRW	IRP$W_RTT_COMPAT(R3)	; Make sure its zero
	TSTB	UCB$B_RTT_PROECO(R5)	; Latest for now is just a one
	BNEQ	10$			; zero is last eco level
	MOVW	#SS$_INCOMPAT,-		; Return quiet error
		IRP$W_RTT_COMPAT(R3)	; message
10$:	RSB

	.SBTTL	RTT_SENSEMODE, Function Decision Routine for SENSEMODE/SENSECHAR
;++
; RTT_SENSEMODE, Function Decision Routine for SENSEMODE/SENSECHAR Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a SENSEMODE
;	or SENSECHAR I/O request.
;
;	The QIO parameters for terminal SENSEMODE/SENSECHAR are:
;
;	P1 = address of 8 or 12 byte characteristics buffer
;	P2 = 0, 8 or 12
;
;	The buffer is validated for access, the process's quota checked and
;	decremented, a message block is allocated, the address of the message
;	block is stored in the IRP, and the IRP is queued to the ACP for
;	delivery to the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;	IRP$L_MEDIA(R3) = address of user characteristics buffer
;	IRP$W_BCNT(R3) = size of user characteristics buffer, 8
;
;	The routine preserves all registers except R0-R2, and R9-R11
;--
RTT_SENSEMODE:				; SENSEMODE/SENSECHAR FDT routine
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatibility error

	MOVZWL	IRP$W_FUNC(R3),R9	; Fetch function code
	BBC	#IO$V_RD_MODEM,R9,5$	; skip if not read modem
	MOVZWL	#SS$_DEVREQERR, R0	; Return as device request error
	BRW	ABORT			; with an error not success
5$:
	MOVL	P1(AP),R1		; Get address of characteristics buffer
	BSBW	RTT_CHARSIZE		; Size of chars buffer (return in R2)
	MOVZWL	#SS$_ACCVIO,R0		; Assume access violation
	IFWRT	R2,(R1),10$		; Buffer accessible?
7$:	BRW	ABORT			; Branch if not
10$:
	BBC	#IO$V_BRDCST,R9,15$	; Branch if not brdcst bit request
	MOVQ	UCB$Q_TL_BRKTHRU(R5),(R1) ; read bits (no remoting of this?)
	BRW	FDT_FINISHIOC_OK	; Complete I/O
15$:
	MOVL	P1(AP),R1		; Get address of characteristics buffer
	BSBB	RTT_CHARSIZE		; Size of chars buffer
	MOVZWL	#SS$_ACCVIO,R0		; Assume access violation
	IFNOWRT	R2,(R1),7$		; Buffer accessible?
	TSTB	UCB$B_RTT_PROECO(R5)	; Previous version
	BNEQ	20$			; Nope
	BICW3	#IRP$M_FCODE,-		; Obtain the modifiers
		IRP$W_FUNC(R3), R0	; to look for bad ones
	CMPW	R0, #IO$M_TYPEAHDCNT	; Only good one
	BEQL	20$			; Ok
	MOVW	#SS$_INCOMPAT,-		; Return quiet error
		IRP$W_RTT_COMPAT(R3)	; to signal the incompatibility
20$:	MOVL	R1,IRP$L_MEDIA(R3)	; Save address in packet
	MOVW	R2,IRP$W_BCNT(R3)	; Set size in packet
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; Set READ type function
	MOVL	#RBF$K_HEADERLEN,R1	; Set size of message buffer
	BSBW	ALLOC_MESSAGE		; Allocate the message buffer
	MOVAB	RBF$L_PARAM1(R2),R2	; R2 points to end of data
	BRW	RTT_NETMSGSENDX		; Send the message and exit service

	.SBTTL	ALLOC_MESSAGE, Allocate a message buffer
;++
; ALLOC_MESSAGE, Allocate a message buffer to send to remote process
; SET_MSGHDR,    Setup a message header for broadcast
;
; Functional description:
;
;	This routine checks that the process has sufficient buffered I/O
;	byte count quota for the message buffer, and then allocates the
;	buffer from non-paged pool.  The process's buffered I/O byte count
;	quota is decreased by the size of the allocated buffer and the
;	message header information is stored.
;
; Inputs:
;
;	R1 = size of message required
;	R3 = address of IRP
;	R4 = address of PCB
;
; Outputs:
;
;	R1 = size of buffer
;	R2 = address of buffer 
;
;	IRP$L_SVAPTE(R3) = address of buffer
;	IRP$W_BOFF(R3) = size of buffer
;
;	RBF$B_TYPE(R2)	= Block type
;	RBF$W_SIZE(R2) = size of message buffer
;	RBF$W_OPCODE(R2) = I/O function
;	RBF$W_MOD(R2) = I/O function modifiers
;	RBF$L_REFID(R2) = Reference id of function
;	RBF$W_UNIT(R2) = Set to SVPN of the ucb (?? not used really)
;
;	If process does not have sufficient quota, the I/O request
;	is aborted.
;--
ALLOC_ABORT:
	POPL	R3			; Restore IRP
	BRW    	ABORT			; and abort the I/O

ALLOC_MESSAGE:				; Allocate message buffer
	PUSHL	R3			; Save packet address
	JSB	G^EXE$BUFFRQUOTA	; Check quota
	BLBC	R0,ALLOC_ABORT		; Branch if error
;
; Allocate the message buffer
;
	JSB	G^EXE$ALLOCBUF		; Allocate the buffer	
	BLBC	R0,ALLOC_ABORT		; Branch if error
	POPL	R3			; Restore packet address
;
; Adjust process's quota
;
	MOVL	PCB$L_JIB(R4),R0	; Get Job Information Block address
	SUBL	R1,JIB$L_BYTCNT(R0)	; Adjust buffered I/O byte count quota
	MOVW	R1,IRP$W_BOFF(R3)	; Save buffer size as quota

;
; Store message header information
;

;
;	R0	= Clobbered
;	R1	= Buffer size
;	R2	= Buffer address
;	R3	= IRP address
;

SET_MSGHDR:

	MOVL	IRP$L_SEQNUM(R3), -	; Sequence number of the operation
		RBF$L_REFID(R2)
	MOVL	IRP$L_UCB(R3), R0	; Unit control block address
	MOVW	UCB$L_SVPN(R0), -	; Bogus unit number, not used
		RBF$W_UNIT(R2)
	EXTZV	#IRP$V_FCODE,-		; Set requested function code
		#IRP$S_FCODE,IRP$W_FUNC(R3),RBF$W_OPCODE(R2)
	BICW3	#IRP$M_FCODE,IRP$W_FUNC(R3),RBF$W_MOD(R2) ; Set requested modifiers

;
; Setup a message header but don't depend on the irp address
; except for svapte.
;

SET_MSGHDRX:

	MOVL	R2,IRP$L_SVAPTE(R3)	; Save buffer address in packet
	MOVW	R1,RBF$W_SIZE(R2)	; Save buffer size in message
	MOVB	#DYN$C_BUFIO,-		; Set block type
		RBF$B_TYPE(R2)
	MOVAB	RBF$W_OPCODE(R2),-	; Set address of data
		RBF$L_MSGDAT(R2)
	CLRL	RBF$L_USRBFR(R2)	; Set user buffer address
	RSB				;

	.SBTTL	RTT_INTERRUPT Interrupt handler
;++
; RTT_INTERRUPT, I/O completion interrupt handler
;
; Functional description:
;
;	This routine handles an I/O completion "interrupt" from the ACP.
;	The I/O status and data is obtained from the response packet from 
;	the remote terminal handler process, and the I/O request is completed.
;
; Inputs:
;
;	R3 = address of the IRP
;	R5 = address of UCB
;	IRP$L_SVAPTE(R3) = address of response message
;
;	IPL = 0
;
; Outputs:
;
;	I/O status copied to IRP$L_IOST and I/O request posted.
;
;	This routine only needs to preserve R11.
;--
RTT_INTERRUPT:				; I/O completion interrupt handler
	MOVL	IRP$L_SVAPTE(R3),R2	; Get address of message
	MOVL	(R2),R1			; Address of data in buffer
	BBC	#IRP$V_FUNC,-		; If clr not READ/SENSE/BROADCAST
		IRP$W_STS(R3),POST 
	EXTZV	#IRP$V_FCODE,-		; Get original function code
		#IRP$S_FCODE,-
		IRP$W_FUNC(R3),R0
	BEQL	POST_BROADCAST		; If eql BROADCAST function
	CMPB	R0,#IO$_SENSEMODE	; SENSEMODE function?
	BEQL	POST_SENSE		; If eql yes
	CMPB	R0,#IO$_SENSECHAR	; SENSECHAR function?
	BEQL	POST_SENSE		;If eql yes - else read function
;
; Set up buffer to post READ
;
	MOVAB	RDP$T_TT_RDATA+2(R1),(R2) ; Set address of data
	MOVL	IRP$L_MEDIA(R3),4(R2)	; Set address of user buffer
	CMPW	RDP$T_TT_RDATA(R1),-	; Size of data greater than user buffer?
		IRP$W_BCNT(R3)		;
	BGTRU	POST			; If gtru yes - leave user's size
	MOVW	RDP$T_TT_RDATA(R1),-	; Else, set size to actual data size
		IRP$W_BCNT(R3)		;
	BRB	POST			;
;
; Set up buffer to post SENSEMODE/CHAR
;
POST_SENSE:				;
;
;	Note that for the latest protocol, either 8 or 12 bytes will come
;	from this part of the message.  Size is already in IRP.
;
	MOVAB	RDP$Q_TT_SCHAR(R1),(R2)	; Set address of data
	MOVL	IRP$L_MEDIA(R3),4(R2)	; Set address of user data
	TSTB	UCB$B_RTT_PROECO(R5)	; Latest version
	BNEQ	10$			; Yes
	MOVL	UCB$L_DEVDEPND2(R5),-	; Return additional characters if
		RDP$L_TT_SCHAR2(R1)	; they are requested
10$:
	BITW	#^CIRP$M_FCODE,-	; Check for spawn bits only if no
		IRP$W_FUNC(R3)		; modifier on the sensemode
	BNEQ	20$			; We have modifiers
	BSBB	SENSE_SPAWN		; Set the three bits for spawn
20$:
POST:					; Post the I/O
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3) ; Set terminal I/O completion
	MOVQ	RDP$Q_STATUS(R1),-	; Set I/O status
		IRP$L_IOST1(R3)		;
	CMPW	IRP$L_IOST1(R3),-	; If normal return
		#SS$_NORMAL		; 
	BNEQ	10$			; Nope
	TSTW	IRP$W_RTT_COMPAT(R3)	; Check for compatibility error
	BEQL	10$			; Nope
	MOVW	IRP$W_RTT_COMPAT(R3),-	; Return compatibility error
		IRP$L_IOST1(R3)		; to user
10$:	JMP	G^COM$POST		; Post the I/O
;
; Post a BROADCAST completion
;
POST_BROADCAST:				;
	BUG_CHECK BRDMSGLOST		; NOT supposed to get here...
	RSB

	.SBTTL	SENSE_SPAWN  Sense for spawn

;	Sense special characteristics bits for DCL spawn command.
;	Return bits for ctrl/c ast, outofband ast and associated mailbox.
;	These bits may be reused later and are not for customer application
;	consumption.
;
; inputs:
;	r1 -> RDP message
;

SENSE_SPAWN:
	MOVAB	RDP$L_TT_SCHAR2(R1), R0	; Address of the characteristics
	BICW	#TT2$M_DCL_MAILBX,(R0)	; Reset 
	TSTL	UCB$L_AMB(R5)		; Any associated mailbox?
	BEQL	10$			; No
	BISW	#TT2$M_DCL_MAILBX,(R0)	; Yes, so set characteristic
10$:
	RSB

	.SBTTL	RTT_CANCEL, Cancel I/O routine
;++
; RTT_CANCEL, Cancels an I/O operation in progress
;
; Functional description:
;
;	This routine cancels any CTRL/C or CTRL/Y AST's that were
;	requested by the cancelling process on the cancelling channel.
;
;	If there are no more references remaining to the device, the UCB
;	is queued to the ACP to notify it that the device is no longer in
;	use.  The ACP will then check that the reference count is still zero
;	and remove the UCB from I/O database and deallocate it.
;
; Inputs:
;
;	R2 = negated value of the channel index number
;	R3 = address of the current IRP (I/O request packet)
;	R4 = address of the PCB (process control block) for the
;		  process canceling I/O
;	R5 = address of the UCB (unit control block)
;
;	IPL = driver fork IPL
;
; Outputs:
;
;	DEV$M_DMT is set in UCB$L_DEVCHAR to prevent a race if someone
;	assigns and deassigns another channel to the UCB before the ACP 
;	dequeues the UCB.
;
;	The routine preserves all registers except R0-R3.
;--
.ENABLE	LOCAL_BLOCK

ASSUME	CAN$C_CANCEL EQ 0
ASSUME	CAN$C_DASSGN EQ 1

10$:	BRW	50$
20$:	BRW	40$

RTT_CANCEL:				; Cancel an I/O operation
	PUSHR	#^M<R4,R5,R6,R7>	; Save registers
	BBC	#UCB$V_ONLINE,-		; If clr unit offline - probably template
		UCB$W_STS(R5),10$	;
	TSTW	UCB$W_REFC(R5)		; Any more references to device?
	BEQL	20$			; Nope all done.

	MOVL	R2,R6			; Make a copy of channel number
	TSTL	R8			; Cancel or deassign
	BEQL	25$			; Cancel

	MOVAL	UCB$L_RTT_CTRLY(R5),R7	; Get address of CTRL/Y AST list
	JSB	G^COM$FLUSHATTNS	; Flush all cancelled AST's

25$:	MOVAL	UCB$L_RTT_CTRLC(R5),R7	; Get address of CTRL/C AST list
	JSB	G^COM$FLUSHATTNS	; Flush any cancelled AST's
	MOVAB	UCB$L_RTT_BANDINCL(R5), R7 ; Flush any outofband asts
	MOVAB	UCB$L_RTT_BANDINMSK(R5), R2 ; mask address
	JSB	G^COM$FLUSHCTRLS	; Flush them by channel etc
	MOVAB	UCB$L_RTT_BANDEXCL(R5), R7 ; Flush any outofband asts
	MOVAB	UCB$L_RTT_BANDEXMSK(R5), R2 ; mask address
	JSB	G^COM$FLUSHCTRLS	; Flush them by channel etc
;
; If we are talking to new version, tell him the new masks.
;
	TSTB	UCB$B_RTT_PROECO(R5)	; Nonzero for latest
	BEQL	30$			; Old version
	MOVL	#RBF$B_TT_OUTBAND+1+4+1+4,- ; Size of the outband message
		R1			; buffer
	PUSHL	R3			; Save across dirty routine
	JSB	G^EXE$ALONONPAGED	; Get me some memory
	POPL	R3			; restore packet address
	BLBC	R0, 30$			; Hang it up for lack of space?

;
; Here comes an incredible hack.  We are going to build a message to be
; transmitted which has no irp context.  It will have a REFID of zero.
; To do this we need an irp address with a svapte field to save the
; packet address.  We make an "irp" by passing the address of a cell in
; the ucb which can be used.  The address is backed up by the svapte offset
; so that for this purpose it looks like an irp.
;

	PUSHL	R3			; Save the bad r3
	MOVAB	<UCB$L_SVAPTE - -	; Make a bogus irp address
		IRP$L_SVAPTE>(R5), R3	; with only a good svapte
	BSBW	SET_MSGHDRX		; Set up the message header
	CLRL	RBF$L_REFID(R2)		; Ref id is zero
	CLRW	RBF$W_UNIT(R2)		; No unit specified
	MOVW	#RDP$B_TT_OUTBAND+1+4+1+4,- ; Size of data to be sent
		RBF$W_DATSIZE(R2)	; to the server
	MOVW	#IO$_SETMODE, -		; Set the op
		RBF$W_OPCODE(R2)	; code of the message
	MOVW	#IO$M_OUTBAND, -	; and the modifier
		RBF$W_MOD(R2)		; for the message
	MOVAB	RBF$B_TT_OUTBAND(R2), R2; Now build the message itself
	MOVB	#4, (R2)+		; Count for include mask
	MOVL	UCB$L_RTT_BANDINMSK(R5),-; Include mask
		(R2)+			;
	MOVB	#4, (R2)+		; Count for exclude mask
	MOVL	UCB$L_RTT_BANDEXMSK(R5),- ; Now the exclude mask
		(R2)+			;
	BSBW	RTT_NETCANSEND		; Send the message to the server
	POPL	R3			; Restore the bogus irp address
30$:

	BSBW	RTT_CANIRPS		; Cancel outstanding IRPs
	BRB	50$

40$:
;
; Clean up the ucb after all references have gone
;
	BSBW	RTT_ABORTIRPS		; Flush all irps from queue
					; Insert UCB in ACP queue
50$:
	POPR	#^M<R4,R5,R6,R7>	; Restore registers
	RSB				; Return

.DISABLE LOCAL_BLOCK

	.SBTTL	RTT_UNSOLIC Unsolicited interrupt handler
;++
; RTT_UNSOLIC, Unsolicted interrupt handler
;
; Functional description:
;
;	This routine handles unsolicted attention messages from the remote
;	terminal handler process.  If the message is:
;
;		Unsolicited data: If device has any references, deliver message
;				  to associated mailbox; if no references,
;				  deliver a message to the Job Controller.
;
;		Hang-up:	  Deliver any CNTRL/Y AST's, specifying hang-up;
;				  deliver a hangup message to associated mailbox.
;
;		CTRL/C or CTRL/Y: Any corresponding AST's are delivered.
;
;		STARTRCV	 Start the receive to the net.
;
; Inputs:
;
;	R3 = address of attention message
;	R5 = address of UCB
;
;	IPL = 0
;
; Outputs:
;
;	Message or AST(s) delivered and attention message block deallocated.
;
;--
RTT_UNSOLIC:				; Unsolicted interrupt handler
	PUSHL	R3			; Save address of mesage block
	DSBINT	UCB$B_FIPL(R5)		; Synchronize access to UCB
	MOVL	(R3),R1			; Obtain the address of the data
	CASE	RDP$W_MOD(R1),<-	; Case on message modifier type
		UNSOL_DATA,-		;  Unsolicited data
		HANGUP,-		;  Hangup
		CTRLC,-			;  CNTRL/C
		CTRLY,-			;  CNTRL/Y
		STARTRCV,-		;  Start network receive
		RTT_BRDCST,-		; Broadcast message for mailbox
		RTT_OUTBAND,-		; Out of band ast character
		>,LIMIT=#RBF$C_TT_UNSOL	;
	BRW	UNSOLIC_EXIT		;
;
; Deliver unsolicited data notification
;
UNSOL_DATA:				; Unsolicited data
	MOVZBL	#MSG$_TRMUNSOLIC,R4	; Set mailbox message type
	TSTW	UCB$W_REFC(R5)		; Any references to device?
	BEQL	10$			; If eql no - notify Job Controller
	MOVL	UCB$L_AMB(R5),R3	; Get address of associated mailbox
	BEQL	20$			; If eql none - forget it
	JSB	G^EXE$SNDEVMSG		; Deliver notification to mailbox
	BLBC	R0,20$			; If lbc failure
	BRB	20$			;
10$:
	MOVL	G^TTY$GL_JOBCTLMB,R3	; Get address of Job Controller mailbox
	BBS	#UCB$V_JOB,UCB$W_DEVSTS(R5),20$ ; Branch if notified already
	JSB	G^EXE$SNDEVMSG		; Deliver notification to mailbox
	BLBC	R0,20$			; If lbc failure
	BISW	#UCB$M_JOB,UCB$W_DEVSTS(R5) ; Set Job Controller notified
20$:
	BRB	UNSOLIC_EXIT		;

;
; Deliver hangup notification
;

HANGUP:					; Dataset hangup
	BSBW	RTT_HANGUP		; Do the hangup stuff
	BRB	UNSOLIC_EXIT		;

;
; Start network receive
;

STARTRCV:
	BSBW	RTT_STARTNETRCV		; Start it out of line
	BRB	UNSOLIC_EXIT

;
; Deliver any CNTRL/C AST's
;

CTRLC:					; Deliver CNTRL/C AST's
	MOVAL	UCB$L_RTT_CTRLC(R5),R4	; Get address of CNTRL/C AST list
	BRB	DELAST			;

;
; Deliver any CNTRL/Y AST'S
;

CTRLY:					; Deliver CNTRL/Y AST's
	MOVAL	UCB$L_RTT_CTRLY(R5),R4	; Get address of CNTRL/Y AST list
DELAST:					; 
	JSB	G^COM$DELATTNAST	; Deliver the AST's
					;
UNSOLIC_EXIT:				; Exit unsolicited message handler
	ENBINT				; Re-enable interrupts
	POPL	R0			; Get address of message block
	MOVB	#DYN$C_BUFIO,IRP$B_TYPE(R0) ; Be sure buffer type is valid
	JSB	G^EXE$DEANONPAGED	; Deallocate the message block
	RSB


;+
; RTT_BRDCST
;
; Deliver broadcast message to the mailbox.
;
; The unit number and name of the device is fixed up in the packet first.
;
;-

RTT_BRDCST:

	BBC	#TT2$V_BRDCSTMBX, -		; If we are allowing mailbox
		UCB$L_DEVDEPND2(R5),10$		; to receive the messages
	TSTL	UCB$L_AMB(R5)			; and we have a mailbox
	BEQL	10$				; Nope
	MOVW	UCB$W_UNIT(R5), -		; Then fix the unit number
		RDP$W_TT_BRDUNIT(R1)		; in the message
	MOVL	UCB$L_DDB(R5), R2		; and get the proper name of
	EXTZV	#0, #4, DDB$T_NAME(R2), R0	; this device for the message
	INCL	R0				; including the count

	PUSHR	#^M<R0, R1, R2, R3, R4, R5>	; Copy the new name and
	MOVC5	R0, DDB$T_NAME(R2), #0, -	; clobber the remainder of the
		#RDP$C_TT_BRDNAME, -		; stuff in the fixed length
		RDP$T_TT_BRDNAME(R1)		; field
	POPR	#^M<R0, R1, R2, R3, R4, R5>	; restore the regs

	PUSHR	#^M<R3, R4, R5>			; Save a few
	MOVZWL	RDP$W_TT_BRDTOTSIZE(R1), R3	; Size of the message
	MOVAB	RDP$W_TT_BRDMSG(R1), R4		; Address of the message
	MOVL	UCB$L_AMB(R5), R5		; Mailbox ucb address
	JSB	G^EXE$WRTMAILBOX		; Write the message to it
	POPR	#^M<R3, R4, R5>			; and ignore the errors

10$:	BRW	UNSOLIC_EXIT			; Go clean up the packet.


;+
; RTT_OUTBAND
;
; Deliver an out of band ast
;-

RTT_OUTBAND:
	MOVZBL	RDP$B_TT_OUTBAND(R1), R3	; Deliver the asts (char)
	PUSHL	R3				; Save the character
	MOVAB	UCB$L_RTT_BANDINCL(R5), R4	; List address
	JSB	G^COM$DELCTRLAST		; Deliver the asts
	POPL	R3				; Recover the character
	MOVAB	UCB$L_RTT_BANDEXCL(R5), R4	; List address
	JSB	G^COM$DELCTRLAST		; Deliver the asts
	BRW	UNSOLIC_EXIT			; Thats all done

	.SBTTL	RTT_HANGUP  - Perform hangup functions
	.SBTTL	RTT_ABORTIRPS - Abort irps outstanding
;++
; RTT_HANGUP  Perform hangup functions
; RTT_ABORTIRPS
;
; Functional description:
;
;	Deliver any CNTRL/Y AST's, specifying hang-up;
;	deliver a hangup message to associated mailbox.
;	Post any irps outstanding with abort.
;	Set hangup status in device status.
;	The ucb is passed on to the acp if there are no more
;	channels open to it.
;	HANGUP is called by net device errors and hangup operations
;	from the line on the other end.
;	ABORTIRPS is called on net device cancels and channel deassigns.
;
; Inputs:
;
;	R5 = address of UCB
;
;
; Outputs:
;
;	Message or AST(s) delivered.
;
;--
RTT_HANGUP:
	MOVAL	UCB$L_RTT_CTRLY(R5),R4	; Get address of CTRL/Y AST list
	MOVL	R4,R0			; Copy list address
10$:
	MOVL	(R0),R0			; Get address of next entry
	BEQL	20$			; If eql none
	MOVZWL	#SS$_HANGUP,-		; Insert new parameter for AST
		ACB$L_KAST+4(R0)	;
	BRB	10$			;
20$:
	JSB	G^COM$DELATTNAST	; Deliver the AST's
	MOVL	#MSG$_TRMHANGUP,R4	; Set mailbox message type
	MOVL	UCB$L_AMB(R5),R3	; Get associated mailbox address
	BEQL	30$			; If eql none - forget it
	JSB	G^EXE$SNDEVMSG		; Deliver notification to mailbox
30$:
	BISW	#UCB$M_TT_HANGUP,-	; Save hangup status
		UCB$W_DEVSTS(R5) 	;

;
;	Clean up the outstanding iirp read to network so it completes
;	without calling driver again.  Post all outstanding irps with
;	abort.
;

RTT_ABORTIRPS:

;
;	We must be at ipl 7 or above here
;
	DSBINT	UCB$B_FIPL(R5)		; Synchronize owth other entries

;
;	Fix the interlock with the receive iirp so it will be deallocated
;	when it completes.  We must say we did so here.  The condition is
;	NETIRP = 1 and IRP$L_AST = 0 means that its gone.  If NETIRP = 0
;	it has never been allocated and given to netdriver.
;

	MOVL	UCB$L_RTT_NETIRP(R5),R0	; Look at address of receive iirp
	BEQL	10$			; Nope not here
	BLBS	R0,10$			; Dummy, all done?
	CLRL	IRP$L_AST(R0)		; Nope so tell receive iirp
10$:	MOVL	#1,UCB$L_RTT_NETIRP(R5)	; Clobber address here

;
;	Now we abort all of the irps that we have at this time.
;

20$:	REMQUE	@UCB$L_RTT_IRPFL(R5), R3; Obtain an irp from queue
	BVS	30$			; No more
	MOVZWL	#SS$_ABORT, -		; Complete with abort status
		IRP$L_IOST1(R3)		;
	CLRL	IRP$L_IOST2(R3)		;
	JSB	G^COM$POST		; and poast
	BRB	20$			; and back for more irps

;
;	If there are no more channels to this device, then pass it on
;	to the acp for disposal.
;

30$:	TSTW	UCB$W_REFC(R5)		; Any channels to device?
	BNEQ	50$			; Yes

	BICW	#UCB$M_JOB,-		; Clear Job Controller notified
		UCB$W_DEVSTS(R5)	;
	BBSS	#DEV$V_DMT,-		; If set, UCB already queued
		UCB$L_DEVCHAR(R5),50$	;
	MOVL	R5,R3			; Set up ucb as the packet
	MOVL	UCB$L_VCB(R5),R2	; Get address of VCB
	MOVL	VCB$L_AQB(R2),R2	; Get address of ACP AQB
	JSB	G^EXE$INSERTIRP		; Insert UCB in ACP queue
	BNEQ	40$			; If neq, not first entry in queue
	MOVL	AQB$L_ACPPID(R2),R1	; Get ACP process ID
	JSB	G^SCH$WAKE		; Wake the ACP process
40$:
50$:	ENBINT				; Restore IPL
	RSB				;

	.SBTTL RTT_NETMSGSEND  - Send message to net driver
;
; RTT_NETMSGSENDX  -  Send message to netdriver and exit qio
; RTT_NETMSGSEND   -  Send message to netdriver
; RTT_NETCANSEND   -  Send message for cancel
; RTT_NETQUEPKT    -  Queue message to net driver
;
; inputs:
;	r2 -> address beyond message data (NETMSGSEND)
;	r3 -> rtt irp
;	r4 -> pcb
;	r5 -> rtt ucb
;

RTT_NETMSGSENDX:
	BSBB	RTT_NETMSGSEND		; Send the message and
	JMP	G^EXE$QIORETURN		; Return from the qio

RTT_NETMSGSEND:
	MOVL	IRP$L_SVAPTE(R3),R0	; The buffer address
	BEQL	10$			; none
	SUBL3	(R0),R2,R1		; Make the length of the data
	MOVW	R1,RBF$W_DATSIZE(R0)	; save in the buffer
10$:	BLBS	UCB$L_RTT_NETIRP(R5),-	; We do not have a receive posted
		RTT_NETHUNGUP		; so this cannot work. We have hungup.
	INSQUE	(R3), -			; Queue the irp on the ucb
		@UCB$L_RTT_IRPBL(R5)
	CLRL	IRP$L_IOST2(R3)		; No cancel has been sent yet

RTT_NETCANSEND:				; Send cancel message

	BSBW	RTT_MAKEIIRP		; Make iirp for this message
	BLBC	R0,RTT_CLEANUP		; No memory, hangup and goaway
	MOVAB	W^RTT_NETWRTDONE,-	; Place to post io
		IRP$L_PID(R2)		;
	MOVL	IRP$L_SVAPTE(R3), -	; Move buffer to iirp
		IRP$L_SVAPTE(R2)	;
	CLRL	IRP$L_SVAPTE(R3)	; drop it from rtt irp
	MOVL	IRP$L_SVAPTE(R2),R1	; fix the byte count in the iirp
	MOVW	RBF$W_DATSIZE(R1), -	; from the size in the buffer
		IRP$W_BCNT(R2)		;

RTT_NETQUEPKT:				; Queue a packet to the netdriver

;
;	r2 -> net iirp
;	r3 -> rtt irp
;	r5 -> rtt ucb
;

	PUSHR	#^M<R3,R4,R5>		; Save the magic three
	MOVL	R2,R3			; Point to iirp
	MOVL	IRP$L_UCB(R3),R5	; The netucb from this packet
	JSB	G^EXE$ALTQUEPKT		; Queue iirp to netdriver
	POPR	#^M<R3,R4,R5>		; restore magic three
	MOVL	#1,R0			; return success
	RSB



;
;	R5 -> RTT UCB
;	R3 -> RTT IRP
;
;
; The net connection is broken, so we must post the irps that come
; in with an error code.
;

RTT_NETHUNGUP:
	MOVL	IRP$L_SVAPTE(R3),R0	; Do we have a buffer
	BEQL	10$			; Nope
	PUSHL	R3			; Push address we care about
	CLRL	IRP$L_SVAPTE(R3)	; Forget we had buffer
	JSB	G^EXE$DEANONPAGED	; Get rid of the buffer
	POPL	R3			; Restore irp address
10$:	MOVQ	#SS$_LINKABORT,-	; Return a nasty error
		IRP$L_IOST1(R3)		; 
	JSB	G^COM$POST		; Post the irp since we don't have
	CLRL	R0			; a link anymore and return error here
	RSB


	.SBTTL	RTT_CLEANUP  - Hangup terminal
;
; RTT_CLEANUP
;
;	We are in deep trouble.  Hangup the terminal to run it down
;	and return failure in r0.  This is done when we cannot obtain
;	memory for an iirp or any thing else.  IPL can be anything.
;
; inputs:
;	r5 -> rtt ucb
;

RTT_CLEANUP:

	BSBW	RTT_HANGUP		; Post irps and attn asts
	CLRL	R0			; return failure
	RSB

	.SBTTL	RTT_STARTNETRCV  - Start receive to net driver
;
; RTT_STARTNETRCV
;
;	Start the first receive iirp to the netdriver.  We make an iirp
;	and queue it to the netdriver with a read function in it.
;
; inputs:
;	r5 -> rtt ucb
;

RTT_STARTNETRCV:

	TSTL	UCB$L_RTT_NETIRP(R5)	; Is the iirp already out?
	BNEQ	20$			; Yes, then ignore it
	MOVW	#SS$_INCOMPAT,UCB$W_RTT_READERR(R5) ; set initial error
	BSBW	RTT_MAKEIIRP		; Make an iirp for use
	BLBC	R0, RTT_CLEANUP		; No good, clean it all up
	MOVL	R2, UCB$L_RTT_NETIRP(R5); Save the address of the iirp
	MOVAB	W^RTT_NETREADDONE, -	; Stuff the post address
		IRP$L_PID(R2)		;
	MOVW	#IO$_READLBLK, -	; Set the function
		IRP$W_FUNC(R2)		;
	CLRL	IRP$L_SVAPTE(R2)	; Yes we have no buffer
	MOVW	G^IOC$GW_MAXBUF,-	; Set the requested size
		IRP$W_BCNT(R2)		;
	BBSS	#IRP$V_FUNC, -		; Say this is a read function
		IRP$W_STS(R2), 10$	;
10$:	BSBB	RTT_NETQUEPKT		; and queue the packet to the net
20$:	RSB

	.SBTTL	RTT_NETREADDONE  - Post routine for net receive
;
; RTT_NETREADDONE  Post net receive
;
;	This is the post routine for receives from the netdriver.
;	We look at the packet and send it to the unsolic or interrupt
;	routine based on the type of the message.  If the type is
;	not recognised or we can't find the irp, we hangup the terminal.
;
;	We are going to run this code at rtt driver ipl.
;
; inputs:
;	r5 -> net iirp
;	ipl = iopost
;

RTT_NETREADDONE:

	PUSHR	#^M<R3,R4,R5>		; Save the magic three
	DSBINT	#RTT$K_FIPL		; Do this work at driver ipl
	MOVL	R5,R3			; The iirp address is here
	MOVL	IRP$L_AST(R3),R5	; The rtt ucb?
	BEQL	10$			; Its gone, we are hung up
	BLBC	IRP$L_IOST1(R3), 60$	; Error? if so then hang up
	MOVL	IRP$L_SVAPTE(R3), R2	; The buffer address
	MOVL	(R2),R1			; Point to message
	ADDW3	#1,RDP$W_OPCODE(R1),R0	; Look at the opcode
	BNEQ	20$			; Its not attention packet
	CLRL	IRP$L_SVAPTE(R3)	; Buffer not in net packet now
	MOVL	R2,R3			; Point to buffer with r3
	BSBW	RTT_UNSOLIC		; Unsolicited input attention message
	BRB	40$			; Requeue a read

10$:	ENBINT				; Restore ipl
	POPR	#^M<R3,R4,R5>		; Restore all the regs we saved
	BSBW	RTT_NETWRTDONE		; Dispose of the iirp and its buffer
	RSB				;

20$:	INCW	R0			; Is this an end message?
	BNEQ	60$			; Nope, hangup the terminal
	MOVL	(R2),R0			; Point to data
	MOVL	RDP$L_REFID(R0),R0	; Obtain the reference id
	BEQL	40$			; ** Ignore refids of zero to make
					; ** cancel of outofband work
	MOVAQ	UCB$L_RTT_IRPFL(R5),R4	; Look through the irps for ours
	MOVL	R4,R1			; head of queue here
30$:	MOVL	(R4),R4			; Link through chain
	CMPL	R4,R1			; end of irps?
	BEQL	60$			; Yes, could not find it, hangup
	CMPL	R0,IRP$L_SEQNUM(R4)	; Match? on ref id
	BNEQ	30$			; nope
	CLRL	IRP$L_SVAPTE(R3)	; Buffer not in net iirp now
	REMQUE	(R4),R3			; Remove the rtt irp from queue
	MOVL	R2,IRP$L_SVAPTE(R3)	; stick buffer there
	BSBW	RTT_INTERRUPT		; and call interrupt routine
40$:
;
;	16(SP)	RTNADR
;	12(SP)	R5 (iirp address)
;	8(SP)	R4
;	4(SP)	R3
;	0(SP)	SAVED IPL (iopost)
;
	MOVL	12(SP),R3		; Obtain the net iirp
	MOVL	IRP$L_UCB(R3),R5	; Set the net ucb address up
	MOVL	IRP$L_SVAPTE(R3),R0	; dump the buffer
	BEQL	50$			; if there is one to dump
	PUSHL	R3			; Save possibly clobbered register
	JSB	G^EXE$DEANONPAGED	; back into swimming pool
	POPL	R3			; Restore register
	CLRL	IRP$L_SVAPTE(R3)	; forget it
50$:	MOVW	G^IOC$GW_MAXBUF,-	; setup for another read from net
		IRP$W_BCNT(R3)		; with requested buffer size
	JSB	G^EXE$ALTQUEPKT		; queue to net driver
	BRB	70$			; Now we are done here

;
;	If we had on io error in the packet, then hangup the terminal
;	deallocate the packet and any buffer and exit.
;	If there is no rtt ucb left anymore, just deallocate the packet
;	and buffer and get out.
;

60$:	BSBW	RTT_HANGUP		; Bad error - hangup the terminal
	MOVL	12(SP),R5		; Net iirp to r5
	BSBB	RTT_NETWRTDONE		; Dump the buffer and the iirp
70$:	ENBINT				; Restore the ipl
	POPR	#^M<R3,R4,R5>		; restore registers of iopost
	RSB

	.SBTTL	RTT_NETWRTDONE  - Post routine for net write
;
; RTT_NETWRTDONE
;
;	Enter here to post writes to net also.
;	Deallocate the iirp and the message if any.
;
;	r5 -> iirp
;	ipl = iopost or higher
;

RTT_NETWRTDONE:

	MOVL	IRP$L_SVAPTE(R5),R0	; Buffer on this iirp?
	BEQL	10$			; nope
	BSBB	20$			; deallocate the buffer
10$:	MOVL	R5,R0			; Now for the iirp itself
20$:	JSB	G^EXE$DEANONPAGED	; back to the pool
	RSB

	.SBTTL	RTT_CANIRPS  - Cancel irps
;
; RTT_CANIRPS
;
;	Cancel irps by sending a message to the terminal system.
;
; inputs:
;	r4 -> pcb for process
;	r5 -> rtt ucb
;	r6 -> channel
;

RTT_CANIRPS:

	PUSHR	#^M<R2,R3,R4,R5,R6>
	MOVAQ	UCB$L_RTT_IRPFL(R5),R6	; Point to the irp queue
	PUSHL	R6			; save its address
;
;	20(SP)	R6
;	16	R5
;	12	R4
;	8	R3
;	4	R2
;	0	IRP LIST HEAD

10$:	MOVL	(R6),R6			; Point to next irp
	CMPL	R6,(SP)			; End of queue?
	BEQL	20$			; Yes
	CMPW	20(SP),IRP$W_CHAN(R6)	; Is this the correct channel?
	BNEQ	10$			; Nope, try next?
	CMPL	PCB$L_PID(R4), -	; Do the pids match?
		IRP$L_PID(R6)		;
	BNEQ	10$			; Nope, try next
	MOVL	R6,R3			; Set up as the irp of choice
	TSTL	IRP$L_IOST2(R3)		; Did we send a cancel?
	BNEQ	20$			; We are done. just return
	MOVL	#RBF$W_UNIT+2, R1	; Get a message buffer for cancel
	PUSHL	R3			; Save across call
	JSB	G^EXE$ALONONPAGED	;
	POPL	R3			; Its clobbered if quick irps are gone
	BLBC	R0,15$			; If error, just say we did it
	BSBW	SET_MSGHDR		; build the message
	ASSUME	RBF$W_MOD EQ -
		RBF$W_OPCODE+2
	MOVL	#IO$_ACPCONTROL,-	; The message opcode and modifier
		RBF$W_OPCODE(R2)	;
	MOVW	#RDP$W_UNIT+2,-		; The datasize
		RBF$W_DATSIZE(R2)	;
;	MOVL	R2,IRP$L_SVAPTE(R3)	; Save the buffer address **
	BSBW	RTT_NETCANSEND		; Send the message
	BLBC	R0,20$			; Error, IRPS are all gone
15$:	MOVL	#1,IRP$L_IOST2(R3)	; Mark for we sent it
	BRB	10$			; try another irp

20$:	POPR	#^M<R1,R2,R3,R4,R5,R6>	; Restore regs and return
	RSB				; Discard stack longword to r1

	.SBTTL RTT_MAKEIIRP  - Manufacture an internal irp
;
; RTT_MAKEIIRP
;
;	Make an internal IRP for sending to the netdriver.
;	If we can't get the space, return failure.
;
; inputs:
;	r3 -> rtt irp
;	r5 -> rtt ucb
;
; outputs:
;	r0 = success or fail
;

RTT_MAKEIIRP:

	MOVZBL	#IRP$C_LENGTH,R1	; Obtain a buffer of correct size
	PUSHL	R3			; Save across call to get memory
	JSB	G^EXE$ALONONPAGED	; from dynamic memory
	POPL	R3			; Restore irp address
	BLBC	R0,10$			; No memory left, so return error
	MOVB	#DYN$C_IRP, -		; Set the type and size fields
		IRP$B_TYPE(R2)		;
	MOVW	R1,IRP$W_SIZE(R2)	;
	CLRL	IRP$L_PID(R2)		; No pid here
	MOVL	R5,IRP$L_AST(R2)	; Save the rtt ucb field
	MOVL	UCB$L_RTT_NETWIND(R5),-	; Set up the window
		IRP$L_WIND(R2)		;
	MOVL	UCB$L_RTT_NETUCB(R5),-	; and the ucb for the net
		IRP$L_UCB(R2)		;
	MOVW	#IO$_WRITELBLK,-	; the function
		IRP$W_FUNC(R2)		;
	MOVB	#4,IRP$B_PRI(R2)	; priority of this in queue
	MOVW	#IRP$M_BUFIO,-		; Its a buffered io function
		IRP$W_STS(R2)		; and assume a write
	CLRW	IRP$W_BOFF(R2)		; no quota to return for iirp
	CLRQ	IRP$L_IOST1(R2)		; no status yet
	ASSUME	IRP$L_OBCNT -
		EQ -
		IRP$L_ABCNT+4
	CLRQ	IRP$L_ABCNT(R2)		; Some more byte counts
	MOVL	IRP$L_SEQNUM(R3),-	; Grab a quick sequence number
		IRP$L_SEQNUM(R2)	;
	MOVL	IRP$L_ARB(R3),-		; Access rights block, incase needed
		IRP$L_ARB(R2)		;
10$:	RSB

	.SBTTL	RTT_END, End of driver

;
; Label that marks the end of the driver
;
RTT_END:
	.END
