MODULE mcrrpclnt (IDENT='V04-000',
	ADDRESSING_MODE(NONEXTERNAL=LONG_RELATIVE,
			EXTERNAL=GENERAL)) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  Command language interface routines
!
! ABSTRACT:
!
!	These routines are used to enable a newly activated
!	image to obtain the command parameters and qualifiers
!	from the command language interpreter.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Tim Halvorsen, Mar 1980
!
! Modified by:
!
!	V03-003	MAJ0004		Melanie Johnson	08-Mar-1983
!		Convert to new table structure.
!		Use PTR_B_NUMBER to get qualifier or keyword number.
!
!	V03-002	MAJ0003		Melanie Johnson	04-Jan-1983
!		Second re-integration of RPCLNT into MCR as MCRRPCLNT.
!
!	V03-007	PCG0017		Peter George	27-Dec-1982
!		Be smarter about using old get value contexts.
!
!	V03-006	PCG0016		Peter George	13-Dec-1982
!		Fix bug in multiple nested value fetch.
!		Clean up some more code.
!		Return CLI$_ABSENT instead of false when no value is found.
!
!	V03-005	PCG0015		Peter George	11-Nov-1982
!		Be smarter about when to return CLI$_COMMA for
!		parameter values.  Do not return a default value
!		if a qualifier or keyword has been explicitly
!		negated.
!
!	V03-004	PCG0014		Peter George	14-Oct-1982
!		Return CLI$_COMMA for default values.
!		Add DCL$NEXTQUAL.
!
!	V03-003	PCG0013		Peter George	01-Sep-1982
!		Support keyword parsing.
!
!	V03-002	PCG0012		Peter George	03-Aug-1982
!		Redo the previous fix in a different manner.
!
!	V03-001	PCG0011		Peter George	14-Jun-1982
!		Differentiate between local and global presence
!		in CLI$PRESENT.
!--


!
! Include files
!
LIBRARY 'SYS$LIBRARY:LIB';					! VMS common definitions
REQUIRE 'SHRLIB$:UTILDEF';					! Common VMS BLISS definitions
REQUIRE 'SHRLIB$:CLITABDEF';					! CLI definitions
REQUIRE 'SHRLIB$:INTDEF';					! CLI definitions
REQUIRE 'LIB$:MCRDEF';						! MCR definitions

!
! Table of contents
!
LINKAGE								! Common linkage
    entity_linkage = call : GLOBAL(block=9,number=10,type=11);

EXTERNAL ROUTINE						! Callback entry point
    sys$cli;

FORWARD ROUTINE
    initialize : NOVALUE,					! Initialize own storage
    mcr$present,						! Determine if entity present
    parameter_present : entity_linkage,				! Determine if parameter is present
    qualifier_present : entity_linkage,				! Determine if qualifier is present
    mcr$getvalue,						! Get value of entity
    parameter_value,						! Get next parameter value
    qualifier_value,						! Get next qualifier value
    reserved_value,						! Get a reserved entity value
    verify_entities : entity_linkage,				! Verify all the specified entities
    find_main_entity : entity_linkage,				! Find qual, param, or reserved entity in database
    verify_keywords,						! Verify legal keyword path
    find_keyword_entity : entity_linkage, 			! Find keyword in database
    find_entity : entity_linkage,				! Find generic entity in database
    guess_entity : entity_linkage,				! Search horizontally for keyword
    guess_keyword_entity,					! Search vertically for keyword
    process_keyword_list,					! Process the specified keyword list
    get_param_token,						! Find next parameter value on line
    get_next_value,						! Get next value
    get_explicit_value,						! Get next explicit value in the list
    get_specified_value,					! Get specified value
    get_default_value,						! Get default vluae
    insert_next_level,						! Get next level of default values
    insert_string,						! Put string in default value
    insert_char,						! Put character in default value
    allocate_default_buffer,					! Allocate space for default value
    local_qualifier,						! Find local occurrence of qualifier
    global_qualifier,						! Find global occurrence of qualifier
    token_string :	NOVALUE,				! Copy token string to descriptor
    upcase :		NOVALUE,				! Upcase a string
    batch_job,							! True if batch job or not
    convert_keyword_list,					! Convert the keyword list to an array
    mcr$nextqual;						! Find the next qualifier

!
! Change name of the PSECT's to conform to MCR standards.
!
PSECT PLIT = MCR$ZCODE(EXECUTE, ALIGN(0));			! PLIT psect
PSECT CODE = MCR$ZCODE(EXECUTE, ALIGN(0));			! Code psect

!
! Get values of status messages.
!
EXTERNAL LITERAL
    cli$_comma,							! Value is terminated with a comma
    cli$_concat,						! Value is terminated with a plus
    cli$_present,						! Entity is explicitly present
    cli$_negated,						! Entity is explicitly not present
    cli$_locpres,						! Qualifier is locally present
    cli$_locneg,						! Qualifier is explicitly not locally present 
    cli$_defaulted,						! Entity is implicitly present
    cli$_absent,						! Entity is implicitly not present
    cli$_invrout;						! Invalid routine

$shr_messages(msg,3,						! Prefix MSG$_ with CLI facility
	(syntax,severe));

LITERAL
    msg$_noentity = msg$_syntax;				! Provide temporary definition

!
! Define entity type numbers (for internal classification of entities)
!
LITERAL
    min_entity = 1,						! Minimum entity type number
    param_entity = 1,						! Entity is a parameter
    qual_entity = 2,						! Entity is a qualifier
    reserved_entity = 3,					! Entity is a reserved word
    max_entity = 3;						! Maximum entity type number

!
! Macros to get the address of a token descriptor given a token index,
! and to get a token index given the address of a token descriptor.
!
MACRO token_desc(index) =					! Index -> Token
    wrk [wrk_g_result] + (index-1)*ptr_c_length%;
MACRO table_index(token) =					! Token -> Index
    (token - wrk [wrk_g_result])/ptr_c_length + 1%;

!
! Macro to zero the unused portions of the context arrays.
!
MACRO zero_context_arrays(index) =
    BEGIN
    CH$FILL (0, 4*(mcr_c_context-(index)), entity_context [index]);
    CH$FILL (0, 4*(mcr_c_context-(index)), token_context [index]);
    END%;

!
! Cells containing addresses of CLINT own storage and command work area.
! Since these addresses were not defined by DCL$DCL_PARSE because this is
! MCR, we are parsing a supervisor mode command and they are initialized here.
!
EXTERNAL
    ctl$gl_clintown : REF BBLOCK,				! Address of pointer to own storage
    ctl$gl_dclprsown : REF BBLOCK;				! Address of pointer to wrk area

!
! Table of reserved entity names
!
BIND
    reserved_words = UPLIT BYTE(
	%ASCIC '$LINE',						! Returns entire command line
	%ASCIC '$VERB',						! Returns verb name (as defined)
	0);							! -- End of list


ROUTINE initialize (get_vm, free_vm) : NOVALUE =

!---
!
!	This routine is called on the first call to this
!	interface package.  It initializes the own storage
!	and sets up for result parsing.
!
! Inputs:
!
!	get_vm = Address of LIB$GET_VM routine
!	free_vm = Address of LIB$FREE_VM routine
!
! Outputs:
!
!	OWN storage initialized.
!---

BEGIN

BUILTIN
    PROBEW,							! True if location writable
    PROBER;							! True if location readable

LOCAL
    index,							! Token index
    plm :	REF BBLOCK,					! Address of parameter limit block
    req_desc :	BBLOCK [cli$c_reqdesc],				! Callback request descriptor
    req_flags : BITVECTOR [32],					! Callback request flags
    rpw :	BBLOCK [cli$c_workarea],			! Result parse work area
    token :	REF BBLOCK,					! Address of token descriptor
    wrk :	REF BBLOCK,					! Address of WRK block
    status;


!
! Get memory for parse routines' own storage.  Store address of own storage
! in CTL$GL_CLINTOWN.  If LIB$GET_VM is unsuccessful, then abort.
!
IF NOT (status = (.get_vm) (%REF(mcr_c_size), ctl$gl_clintown))	! Get memory for CLINT own storage
   THEN SIGNAL (.status);					! Signal error if failed

!
! If the WRK block pointer is zero, then make an old fashioned INITPRS
! callback to get it.
!
IF .ctl$gl_dclprsown EQL 0					! If we have no WRK block pointer
   THEN BEGIN							! Then get one now
	CH$FILL (0,cli$c_reqdesc,req_desc);			! Zero request desc block
	req_desc [cli$b_rqtype] = cli$k_initprs;		! Set request type
	IF NOT (status = SYS$CLI (req_desc, rpw, req_flags))	! Init result parsing solely to get
	   THEN SIGNAL (.status);				! rpw [rpw_l_mcrwrk]
	ctl$gl_dclprsown = .rpw [rpw_l_mcrwrk];			! Store address of WRK area
	END;

!
! Get the address of the command WRK block from CTL$GL_DCLPRSOWN.
!
wrk = .ctl$gl_dclprsown;					! Get address of WRK area

!
! Verify the validity of the CLI WRK area pointer, to ensure that we aren't
! trying to deal with a mismatched WRK structure.
!
ctl$gl_clintown [mcr_v_nowrkarea] = true;			! Assume invalid WRK area

!
! Check first result parse descriptor.
!
token = wrk [wrk_g_result];					! Point to first entry in array
IF NOT PROBER(%REF(psl$c_user),%REF(ptr_c_length),.token) 	! If not readable,
    OR .token [ptr_v_type] GTRU ptr_k_ignore			! Or invalid type code,
    OR .token [ptr_v_term] GTRU ptr_k_lparen			! Or invalid terminator code,
    OR .token [ptr_v_term] LSSU ptr_k_blank
    OR .wrk [wrk_l_rslnxt] LSSA wrk [wrk_g_result] 		! Or invalid RSL pointer,
    OR .wrk [wrk_l_rslnxt] GTRA wrk [wrk_g_result] + wrk_c_rslbufsiz
   THEN RETURN;							! Return with invalid WRK

!
! Check first parameter entity block and first qualifier entity block.
!
token = .wrk [wrk_l_proptr];					! Get address of param entities
IF .token NEQ 0							! If invalid pointer,
   THEN IF NOT PROBER(%REF(psl$c_user),%REF(10),.token) 
	   THEN RETURN;						! Return with invalid WRK

token = .wrk [wrk_l_quablk];					! Get address of qual entities
IF .token NEQ 0							! If invalid pointer,
   THEN IF NOT PROBER(%REF(psl$c_user),%REF(10),.token) 
	   THEN RETURN;						! Return with invalid WRK

!
! If we've gotten this far, then indicate that the WRK area is valid.
!
ctl$gl_clintown [mcr_v_nowrkarea] = false;			! Indicate valid WRK area

!
! Initialize the CLINT own storage area.
!
! Clear all information about the default value buffer.
!
ctl$gl_clintown [mcr_w_buflen] = 0;				! Clear length of buffer
CH$FILL (0, dsc$c_s_bln, ctl$gl_clintown [mcr_w_deflen]);	! Zero default value descriptor

!
! Save the addresses of the LIB$GET_VM and LIB$FREE_VM routines.
!
ctl$gl_clintown [mcr_l_getvm] = .get_vm;			! Store LIB$GET_VM
ctl$gl_clintown [mcr_l_freevm] = .free_vm;			! Store LIB$FREE_VM

!
! Clear all context information.
!
ctl$gl_clintown [mcr_v_nextqual] = false;			! Assume normal qualifier parse
CH$FILL(0, 4*mcr_c_context, ctl$gl_clintown [mcr_l_entity]);	! Set no entities processed yet    
CH$FILL(0, 4*mcr_c_context, ctl$gl_clintown [mcr_l_token]);	! Set no tokens processed yet
CH$FILL(0, 16*plm_c_size, ctl$gl_clintown [mcr_l_prmlim]);	! Zero parameter limit descs (plms)
ctl$gl_clintown [mcr_b_param] = 0;				! Set no parameters processed yet
ctl$gl_clintown [mcr_l_qual] = 0;				! Set no qualifier processed yet

!
! Initialize the parameter list markers in the clint own storage.
!
! For each parameter type, a plm longword is filled in.  Each byte
! contains the index of a result parse descriptor, as follows.
!
!	plm_b_nxtdesc = next parameter value to examine
!	plm_b_fstdesc = first parameter in the list
!	plm_b_lstdesc = last parameter value before next parameter type
!	plm_b_quadesc = first possible local qualifier token
!
index = 0;							! Start at first token descriptor
plm = ctl$gl_clintown [mcr_l_prmlim];				! Point to first plm longword

status = get_param_token(index,token);				! Get first parameter token

WHILE (.status)							! Until no more parameters
DO BEGIN							!
   plm [plm_b_fstdesc] = .index;				! Save starting token for parameter
   plm [plm_b_nxtdesc] = .index;				! and set next value to process
   plm [plm_b_quadesc] = .index;				! and set first possible qualifier token

   WHILE (status = get_param_token(index,token))		! Scan for next parameter value
   DO BEGIN							!
      BIND preceeding_token = .token - ptr_c_length: BBLOCK;	!
      IF .preceeding_token [ptr_v_term] EQL ptr_k_blank 	! If start of next parameter
	 THEN EXITLOOP;						! then stop for a second
      END;							!

   plm [plm_b_lstdesc] = .index-1;				! Save ending token for prev. parameter
   plm = .plm + plm_c_size;					! Skip to next plm
   END;

RETURN true;
END;

GLOBAL ROUTINE mcr$present (rqdesc, rqwork, rqbits) =

!---
!
!	Determine if an entity is present on the command line.
!
! Inputs:
!
!	rqdesc = Address of request descriptor data structure
!	rqword, rqbits = ignored
!
! Outputs:
!
!	Routine value:
!
!		success = cli$_present
!			  cli$_locpres
!			  cli$_defaulted
!
!		failure = cli$_absent
!			  cli$_negated
!			  cli$_locneg
!		  
!	All errors are signalled.
!---

BEGIN

MAP 
   rqdesc : REF BBLOCK;

GLOBAL REGISTER
    block=9:	REF BBLOCK,					! Address of entity descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

LOCAL
    keyword_array : VECTOR [2*(mcr_c_context+1)+1];		! Keyword array

!
! Initialize CLINT if necessary.
!
IF .ctl$gl_clintown EQL 0					! If not yet initialized,
   THEN initialize (.rqdesc [int_l_getvm], 			! then initialize parsing
			.rqdesc [int_l_freevm]);		!

!
! Verify that valid entities were specified.
!
return_if_error (verify_entities (rqdesc [int_w_entlen], 	! Verify all specified entities
			keyword_array));			!

!
! If the entity is reserved then it is alwyas present.  If it is
! a parameter or qualifier, then check it out.
!
CASE .type FROM min_entity TO max_entity			! Process each entity type differently
OF SET								!
   [reserved_entity]: RETURN cli$_present;			! Process reserved entity
   [param_entity]: RETURN parameter_present (keyword_array [2]);! Process parameter entity
   [qual_entity]: RETURN qualifier_present (keyword_array [2]);	! Process qualifier entity
   TES;								!

END;

ROUTINE parameter_present (keyword_list) : entity_linkage =

!---
!
!	Determine if a parameter value is present.
!
! Inputs:
!
!	keyword_list = Address of list of keyword descriptors
!
!	block = Address of parameter entity descriptor block
!	number = Parameter number
!	type = Always paramter
!
! Outputs:
!
!	routine value = status indicating presence
!
!---

BEGIN

MAP
    keyword_list : REF VECTOR;

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter number
    type=11;							! Entity type (param_entity)

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK,			! Address of command wrk area
    prmlim = ctl$gl_clintown [mcr_l_prmlim] : VECTOR;		! Parameter context array

LOCAL
    default,							! Defaut values flag
    plm :	REF BBLOCK;					! Address of parameter limit

!
! Set parameter state variables
!
plm = prmlim [.number-1];					! Find limits of this parameter
ctl$gl_clintown [mcr_b_param] = .number;			! Save last parameter # requested
								! (for local qualifier search)

!
! If the parameter is not explicitly present, then check to see if it 
! has a default value or is present by default.  If not, return CLI$_ABSENT.
!
IF .plm [plm_b_fstdesc] EQL 0					! If parameter is missing
   THEN IF (.block [ent_w_defval] EQL 0) AND			! And has no default value
		NOT .block [ent_v_deftrue]			! And it is not present by default
	   THEN RETURN cli$_absent				! Then indicate not present
	   ELSE default = true					! Else set default flag
   ELSE default = false;					! Else clear default flag

!
! The parameter is either present of defaulted.  Now it's time to check
! for keywords.  If a keyword list is specified, then call process_keyword_list
! to check for their presence.
!
IF .keyword_list [0] NEQ 0					! If we have a keyword list
   THEN BEGIN	
	LOCAL found, qual, token;
	qual = 0;						! Assume first token will be defaulted
	token = token_desc (.plm [plm_b_fstdesc]);		! Get first parameter token
	found = process_keyword_list (.block, keyword_list [0], ! Process the keyword list
			.token, .default, param_entity, 0, qual);
	IF .qual GTR 0						! If value was not defaulted
	   THEN plm [plm_b_quadesc] = table_index (.qual) + 1	! Then update local qualifier context
	   ELSE plm [plm_b_quadesc] = .plm [plm_b_lstdesc] + 1;	! Else allow no more local qualifiers
	RETURN .found;
	END;

!
! If we've gotten this far, then no keywords are present and the specified 
! parameter is either present or defaulted.  Return the appropriate value.
!
IF .default							! If the parameter was defaulted
   THEN RETURN cli$_defaulted					! Then so indicate
   ELSE BEGIN
	plm [plm_b_quadesc] = .plm [plm_b_fstdesc] + 1;		! Update qualifier pointer
	RETURN cli$_present;					! Return present
	END;

END;

ROUTINE qualifier_present (keyword_list) : entity_linkage =

!---
!
!	Determine if a qualfier value is present.
!
! Inputs:
!
!	keyword_list = Address of list of keyword descriptors
!
!	block = Address of qualifier entity descriptor block
!	number = Qualifier number
!	type = Always "qual_entity"
!
! Outputs:
!
!	routine value = status indicating presence
!
!---

BEGIN

MAP
    keyword_list : REF VECTOR;

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter number
    type=11;							! Entity type (param_entity)

LOCAL
    default,							! Defaut values flag
    token :	REF BBLOCK,					! Address of next token descriptor
    status;

!
! Search for a local occurrence of the qualifier.  If none found, and
! the qualifier can be positioned globally, then search for a global
! occurance.
!
token = local_qualifier (.block, .number); 			! Search for local qualifier
IF (.token EQL 0) AND .block [ent_v_verb]			! If none, but allowed globally,
   THEN token = global_qualifier (.block, .number);		! Then search for global qualifier

!
! If no occurence was found, check to see if it is present by default.
! If not, then return CLI$_ABSENT.
!
IF .token EQL 0							! If no occurrence found,
   THEN IF NOT .block [ent_v_deftrue]				! and not defaulted present
		AND NOT (.block [ent_v_batdef] AND batch_job())
	   THEN RETURN cli$_absent				! Then return not present
	   ELSE default = true					! Else set default flag
   ELSE default = false;					! Else clear default flag

!
! The qualifier is either explicitly, or defaulted, present.  If any keywords
! were specified, search for them now.
!
IF .keyword_list [0] NEQ 0					! If keywords to check
   THEN BEGIN							! Then check them
	status = process_keyword_list (.block, keyword_list [0],! Process keyword list
			.token, .default, qual_entity, 0, 0);
	IF (.status EQL cli$_defaulted)				! If presence was defaulted
		OR (.status EQL cli$_absent)			! or not found
	   THEN RETURN .status;					! Then return now
	END

!
! No keywords are present.  Just set the global status.
!
   ELSE IF .default						! Else no keywords, so set status
	   THEN RETURN cli$_defaulted				! If defaulted, then return now
	   ELSE IF .token [ptr_v_negate]			! If negated, then 
		   THEN status = cli$_negated			! Then indicate so
		   ELSE status = cli$_present;			! Else mark as present

!
! If qualifier was positioned locally, then convert the global status
! to a local status.  Otherwise, return the global status.
!
IF .token [ptr_v_type] EQL ptr_k_comdqual 			! If command qualifier	
   THEN RETURN .status						! Then return current status
   ELSE IF .status EQL cli$_present				! Else convert to local status
	   THEN RETURN cli$_locpres				! Then indicate locally present
	   ELSE RETURN cli$_locneg;				! Else indicate locally negated

END;

GLOBAL ROUTINE mcr$getvalue (rqdesc, rqwork, rqbits) =

!---
!
!	This routine is called to obtain the next value
!	associated with a named entity on the command line.
!
! Inputs:
!
!	rqdesc = Address of request descriptor data structure
!	rqword, rqbits = ignored
!
! Outputs:
!
!	Routine value:
!
!		success =  CLI$_CONCAT - a value terminated by a plus was returned
!			   CLI$_COMMA - a value terminated by a comma was returned
!			   SS$_NORMAL - a value was returned (there may be more)
!
!		failure =  0 - there are no more values associated with the entity
!
!	All errors are signaled.
!---

BEGIN

MAP 
   rqdesc : REF BBLOCK;

GLOBAL REGISTER
    block=9:	REF BBLOCK,					! Address of entity descriptor block
    number=10,							! Parameter/qualifeier number
    type=11;							! Entity type

LOCAL
    keyword_array : VECTOR [2*(mcr_c_context+1)+1];		! Keyword array

!
! Initialize CLINT if necessary.
!
IF .ctl$gl_clintown EQL 0					! If not yet initialized,
   THEN initialize (.rqdesc [int_l_getvm],			! then initialize parsing
			.rqdesc [int_l_freevm]);		!

!
! Verify that valid entities were specified.
!
return_if_error (verify_entities (rqdesc [int_w_entlen], 	! Verify all specified entities
			keyword_array));			!

!
! Process each primary entity type differently.
!
CASE .type FROM min_entity TO max_entity			! Process each entity type differently
OF SET								!
    [param_entity]: RETURN parameter_value(.block, .number, 	! Process parameter
		keyword_array [2], rqdesc [int_w_entlen]);	!
    [qual_entity]: RETURN qualifier_value(.block, .number,	! Process qualifier
		keyword_array [2], rqdesc [int_w_entlen]);	!
    [reserved_entity]: RETURN reserved_value(.number, 		! Process reserved entity
		rqdesc [int_w_entlen]);				!
    TES								!
    
END;

ROUTINE parameter_value (entity, param_number, keyword_list, retdesc) =

!---
!
!	This routine returns the next value in the list for
!	a given parameter.
!
! Inputs:
!
!	entity = Address of parameter descriptor block
!	param_number = Parameter number
!	keyword_list = Address of list of keyword descriptors
!	retdesc = Address of return descriptor to receive value
!
! Outputs:
!
!	retdesc = Next value string in list
!
!	routine value = status indicating presence of value
!---

BEGIN

MAP
    entity : REF BBLOCK,
    keyword_list : REF VECTOR,
    retdesc : REF BBLOCK;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK,			! Address of command work area (WRK block)
    prmlim = ctl$gl_clintown [mcr_l_prmlim] : VECTOR,		! Parameter context array
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    token_context = ctl$gl_clintown [mcr_l_token] : VECTOR;	! Token context array

LOCAL
    found,							! Value found flag
    plm:	REF BBLOCK;					! Address of current parameter context entry

!
! Set initial conditions.
!	
found = true;							! Assume value will be found
retdesc [dsc$w_length] = 0;					! and that the value will be null
ctl$gl_clintown [mcr_b_param] = .param_number;			! Save last parameter # requested
								! (for local qualifier search)
ctl$gl_clintown [mcr_l_qual] = 0;				! Clear qualifier context
plm = prmlim [.param_number - 1];				! Find limits for the parameter
ctl$gl_clintown [mcr_b_param] = .param_number;			! Update the local qualifier context

!
! Find our place in the parameter value list.  If the parameter does not 
! appear on the command line, see if it is present by default.  
!
IF .plm [plm_b_fstdesc] EQL 0					! If param not on command line
   THEN IF ((.entity [ent_w_defval] EQL 0)			! Then if param is not defaulted
		AND NOT.entity [ent_v_deftrue])			! 
		OR (.plm [plm_b_nxtdesc] GTRU 			! Or if all default values have 
			.plm [plm_b_lstdesc])			!  already been returned
	   THEN BEGIN						! Then no value is present
		zero_context_arrays (0);			! Clear the context arrays
		RETURN cli$_absent;				! Return no value present
		END;

!
! Update the context if necessary.
!
IF .entity_context [0] NEQ .entity				! If there has been a change in context
   THEN BEGIN							! Then update the context
	entity_context [0] = .entity;				! Set the current entity context
	token_context [0] = 0;					! Set the current token context
	zero_context_arrays (1);				! Clear the rest of the context arrays
	END;

!
! If no keyword list is specified, then if the parameter is present by default,
! or has a default value, then return that default value.  Otherwise, return
! the next parameter value and update the context.
!
IF .keyword_list [0] EQL 0					! If no keyword list is specified
   THEN IF .plm [plm_b_fstdesc] EQL 0				! Then, if the param value is defaulted
	   THEN (IF (found = get_default_value 			! Then, return that default value
			(.entity, 0, .retdesc)) EQL true	! And, if this is the last default parameter value
		   THEN plm [plm_b_nxtdesc] = 			! Then so indicate
				.plm [plm_b_lstdesc] + 1)	!
	   ELSE BEGIN						! Else, return the explicit value
		LOCAL token;					!

		IF .plm[plm_b_nxtdesc] GTRU .plm[plm_b_lstdesc]	! If all values have been returned,
		   THEN BEGIN					! Then no value is present
			plm [plm_b_quadesc] = 			! Set no more local qualifiers
				.plm [plm_b_nxtdesc];		!
			RETURN cli$_absent;			! Return no value found
			END;					!

		token = token_desc (.plm [plm_b_nxtdesc]);	! Get the first value token
		get_specified_value (.token,.retdesc);		! Return the value it marks
		plm [plm_b_quadesc] = .plm [plm_b_nxtdesc] + 1;	! Set local qualifier pointer

		IF (found = get_explicit_value (token, 0))	! Find the next parameter value
			AND (.found NEQ true)			! (but not the first in the next list)
		   THEN plm[plm_b_nxtdesc] = table_index(.token)! If present, then point to it
		   ELSE BEGIN					! Else indicate no more values
			plm [plm_b_nxtdesc] = 			! Force next CLI$GET_VALUE to fail
				.plm [plm_b_lstdesc] + 1;	!
			RETURN true;				! But return that this value was found
			END;					!

		zero_context_arrays (1);			! Clear the rest of the context arrays
		END

!
! If a keyword list is specified, then call process_keyword_list to check 
! the keywords. 
!
   ELSE BEGIN							! A keyword list has been specified
	LOCAL default, qual, token;

	IF .plm [plm_b_fstdesc] EQL 0				! If the param value is defaulted present
	   THEN default = true					! Then set the default flag
	   ELSE BEGIN						! Else,
		default = false;				! Clear the default flag
		token = token_desc (.plm [plm_b_fstdesc]);	! Find the first param token
		END;						!

	qual = 0;						! Assume first token will be defaulted
	found = process_keyword_list (.entity, keyword_list [0],! Process the keywords
		    .token, .default, param_entity, .retdesc, qual);

	IF .qual GTR 0						! If value was not defaulted
	   THEN plm [plm_b_quadesc] = table_index (.qual) + 1	! Then update local qualifier context
	   ELSE plm [plm_b_quadesc] = .plm [plm_b_lstdesc] + 1;	! Else allow no more local qualifiers

	END;

RETURN .found;							! Return status
END;

ROUTINE qualifier_value (entity, qual_number, keyword_list, retdesc) =

!---
!
!	Return the next value in a qualifier value list.
!
! Inputs:
!
!	entity = Address of qualifier descriptor block
!	qual_number = Qualifier number
!	keyword_list = Address of list of keyword descriptors
!	retdesc = Address of return descriptor to receive value
!
! Outputs:
!
!	retdesc = Next value in list
!
!	routine value = status indicating presence of value
!---

BEGIN

MAP
    entity : REF BBLOCK,
    keyword_list : REF VECTOR,
    retdesc : REF BBLOCK;

BIND 
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    token_context = ctl$gl_clintown [mcr_l_token] : VECTOR,	! Token context array
    last_qual = ctl$gl_clintown [mcr_l_qual];			! Last qualifier token 

GLOBAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Qualifier number
    type=11;							! Entity type

LOCAL
    found,							! Value found flag
    token;							! Address of token descriptor

!
! Set initial conditions.
!	
found = true;							! Assume value will be found
retdesc [dsc$w_length] = 0;					! Assume the value will not be found

!
! Find the last occurrence of the qualifier on the command line.  If the
! qualifier does not appear on the command line, see if it is present by 
! default.  If it isn't, return CLI$_ABSENT.  
!
token = local_qualifier (.entity, .qual_number);		! Look for local occurances
IF (.token EQL 0) AND (.entity [ent_v_verb])			! If none, but global allowed,
   THEN token = global_qualifier(.entity, .qual_number);	! Then look for global occurances
IF .token EQL 0							! If still none, 
   THEN IF NOT .entity [ent_v_deftrue]				! Then check for default presence
		AND NOT (.entity [ent_v_batdef] AND batch_job())!
	   THEN BEGIN						! If still none, then give up
		last_qual = 0;					! Clear qualifier context
		zero_context_arrays (0);			! Clear the context arrays
		RETURN cli$_absent;				! Return no value present
		END;

!
! If we are not doing the same qualifier as last time, then reset our context.
! Otherwise, use the old context.
!
IF (.entity_context [0] NEQ .entity) OR (.last_qual NEQ .token)	! Is context of last call still valid?
   THEN BEGIN							! No, reset the context
	token_context [0] = 0;					! Set token context
	entity_context [0] = .entity;				! Set entity context
	last_qual = .token;					! Set qualifier context
	zero_context_arrays (1);				! Clear the rest of the arrays
	END;

!
! The qualifier is explicitly, or defaulted, present.  If no keywords
! are specified, then return the explicit or default qualifier value.
!
IF .keyword_list [0] EQL 0					! If no keywords were specified
   THEN IF .token LEQ 0						! Then, if the qualifier value is defaulted
	   THEN RETURN get_default_value(.entity, 0, .retdesc)	! Then, return the default value
	   ELSE RETURN get_next_value(.token,.entity,0,.retdesc)! Else, return the explicit value

!
! If a keyword list is specified, then process that list.
!
   ELSE BEGIN							! Process the keyword list
    	LOCAL default;						! Default value flag
	IF .token EQL 0						! Was a qual found on the command line?
	   THEN default = true					! No, then use default values
	   ELSE default = false;				! Yes, then use explicit values
	RETURN process_keyword_list (.entity, keyword_list [0],	! Process the keyword list
		.token, .default, qual_entity, .retdesc, 0);
	END;

END;

ROUTINE reserved_value (number, retdesc) =

!---
!
!	Return the value associated with a reserved entity name.
!
! Inputs:
!
!	number = Reserved word number
!	retdesc = Address of return buffer descriptor
!
! Outputs:
!
!	retdesc = Value string.
!
!	routine value = status indicating presence of value
!---

BEGIN

MAP
    retdesc : REF BBLOCK;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

LOCAL
    token : REF BBLOCK,						! Address of curent token descriptor
    string : VECTOR [2];					! String descriptor

CASE .number FROM 1 TO 2					! Based on reserved word number
OF SET
   [1]:	BEGIN							! $LINE reserved word
	token = wrk [wrk_g_result];				! Start at first token descriptor

	WHILE (.token [ptr_v_type] NEQ ptr_k_endline)		! Until end of command line
	DO token = .token + ptr_c_length;			! then skip to next one

	string [0] = .token [ptr_v_offset];			! Line length is offset to eol
	string [1] = wrk [wrk_g_buffer];			! and set address of input buffer
	
	IF CH$RCHAR (.string [1]) EQL %C'$'			! If line is preceeded with "$"
	   THEN BEGIN						! then strip it off
		string [0] = .string [0] - 1;
		string [1] = .string [1] + 1;
		END;
	END;

   [2]:	BEGIN							! $VERB reserved word
	LOCAL verb :  REF VECTOR [,BYTE];			!
	verb = .wrk [wrk_l_verb];				! Get address of ASCIC verb string
	string [0] = MINU (.verb [0], 4);			! Get length of verb
	string [1] = verb [1];					! Get address of verb
	END;							!

    TES;

retdesc [dsc$w_length] = .string [0];				! Return value string
retdesc [dsc$a_pointer] = .string [1];

RETURN true;
END;

ROUTINE verify_entities (entity_desc, array) : 	entity_linkage =

!---
!
!	Verify that all the specified entities really exist.  
!	Fill in the keyword descriptor array.  Return the address 
!	of the descriptor corresponding to the first entity.
!
! Inputs:
!
!	entity_desc = Address of entity name descriptor
!	array = Address of keyword array
!
! Outputs:
!
!	block = Address of first entity descriptor
!	type = First entity type
!	number = Parameter or qualifier number
!
!	routine value = True if found, else false
!
!	If entity not found, an error is signaled.
!---

BEGIN

MAP
    array : REF VECTOR;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

!
! If we don't have a valid set of tables to search, exit with failure
!
IF .ctl$gl_clintown [mcr_v_nowrkarea]				! If invalid tables
   THEN RETURN false;						! Then exit with failure

!
! Convert the linear keyword list into a more usable keyword array.
!
return_if_error (convert_keyword_list (.entity_desc, .array));	! Convert into a keyword array

!
! Find the first entity.
!
IF NOT (find_main_entity (array [0]))				! If we can't find the first entity
   THEN return_if_error (guess_entity (array [0]));		! Then look around for it

!
! If entity was successfully found, then verify the keyword list.
!
IF .array [2] NEQ 0						! If a keyword list is present
   THEN return_if_error (verify_keywords (.block, .type,	! Then verify it
						array [2]));

RETURN true;
END;

ROUTINE find_main_entity (name): entity_linkage =

!---
!
!	Locate a parameter, qualifier, or reserved entity by entity name 
!	string and return the address of the entity block corresponding to 
!	that entity.
!
! Inputs:
!
!	name = Address of entity name descriptor
!
! Outputs:
!
!	block = Address of entity block
!	type = Entity type
!	number = Parameter or qualifier number
!
!	routine value = True if found, else false
!
!	If entity not found, an error is signaled.
!---

BEGIN

MAP
    name:	REF BBLOCK;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

LOCAL
    entity_name: VECTOR [2],					! Descriptor for above buffer
    buffer: VECTOR [32,BYTE],					! Buffer for upcased entity label
    ptr:	REF BBLOCK;					! Pointer to scan reserved word table

!
! Upcase the entity name string
!
entity_name [1] = buffer;					! Point at buffer
upcase (.name, entity_name);					! Upcase the string

!
! Search parameter and qualifier lists for entity.
!
block = .wrk [wrk_l_proptr];					! Get address of first block
type = param_entity;						! Assume parameter entity will be found

WHILE (true)							! Search parameter and qualifier lists
DO BEGIN							!
   IF (find_entity (entity_name))				! Search entity list
      THEN RETURN true;						! Return true if found
   IF .type EQL qual_entity					! If qualifiers already searched, 
      THEN EXITLOOP;						! then exit the loop
   block = .wrk [wrk_l_quablk];					! Get address of first qualifier block
   type = qual_entity;						! Indicate qualifier entity
   END;

!
! Search the list of reserved entity names
!
number = 1;							! Start at first reserved word
ptr = reserved_words;						! Point to beginning of table
type = reserved_entity;						! Assume entity will be found

WHILE (CH$RCHAR(.ptr) NEQ 0)					! Until end of table
DO BEGIN							!
   IF CH$EQL(.entity_name [0], .entity_name [1],		! If this is the entity requested
		CH$RCHAR(.ptr), .ptr+1, 0)			!
      THEN RETURN true;						! then return success
   ptr = CH$RCHAR_A(ptr) + .ptr;				! Skip to next reserved word
   number = .number + 1;					! Increment reserved word number
   END;

RETURN false;							! Return unsuccessful

END;

ROUTINE verify_keywords (input_block, input_type, keyword_list) =

!---
!
!	Verify a keyword path from the already found main entity.
!	(FIND_MAIN_ENTITY should always be called before this routine.)
!
! Inputs:
!
!	input_block = Address of entity descriptor block
!	input_type = Type of entity
!	keyword_list = Address of keyword name descriptor list
!
! Outputs:
!
!	routine value = True if found, else false
!
!	If entity is not found, an error is signaled.
!---

BEGIN

MAP
    keyword_list :	REF BBLOCK;

GLOBAL REGISTER
    block=9:	REF BBLOCK,					! Address of entity descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

LOCAL
    status;

!
!  Set up registers for find_keyword_entity().
!
block = .input_block;						! Set block to entity descriptor 
type = .input_type;						! Set type to entity type
number = 0;							! Clear number

!
! Return error if entity is a reserved entity.
!
IF .type EQL reserved_entity					! Is entity a reserved entity?
   THEN status = false						! Yes, then error

!
! Search down the keyword path name.  Validate each keyword entity block
! along the way.
!
   ELSE DO BEGIN
	   IF NOT (status = find_keyword_entity(.keyword_list))	! Validate the current keyword
	      THEN EXITLOOP;					! Exit if invalid
	   keyword_list = .keyword_list + 8;			! Get the next keyword
	   END
	UNTIL (.keyword_list [dsc$w_length] EQL 0);		! Quit when no more keywords

!
! Signal any errors.
!
IF NOT .status							! If some keyword was invalid
   THEN SIGNAL (msg$_noentity,1,.keyword_list);			! Then signal the error
RETURN .status;							! Return the status

END;

ROUTINE find_keyword_entity (keyword) : entity_linkage =

!---
!
!	Locate the keyword entity block specified by the next keyword
!	descriptor in the list.
!
! Inputs:
!
!	keyword = Address of keyword name descriptor 
!
! Outputs:
!
!	block = Address of entity descriptor
!	type = Entity type
!	number = Parameter or qualifier number
!
!	routine value = True if found, else false
!
!---

BEGIN

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Keyword number
    type=11;							! Entity type

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

LOCAL
    buffer : BBLOCK [32],					! Buffer for upcased keyword label
    keyword_name : BBLOCK [dsc$c_s_bln];			! Descriptor for keyword label

!
! Get and upcase the keyword name string.
!
keyword_name [dsc$a_pointer] = buffer;				! Point at buffer
upcase (.keyword, keyword_name);				! Upcase the string

!
! Get the first keyword entity block.  If none, then exit with error.
! If successful, then calculate the block address and search for the keyword.
!
IF .block [ent_l_user_type] EQL 0				! Get the first keyword entity block
   THEN RETURN false;						! If none, then exit with an error
block = .block [ent_l_user_type] + .wrk [wrk_l_tab_vec];	! Calculate its absolute address
block = .block [ent_l_next] + .wrk [wrk_l_tab_vec]; 		! Skip list header
RETURN find_entity (keyword_name);				! Search for the keyword
END;

ROUTINE find_entity (name) : entity_linkage =

!---
!
!	Locate an entity by entity name string and return the address 
!	of the entity block corresponding to that entity.
!
! Inputs:
!
!	name = Address of entity name descriptor
!
! Outputs:
!
!	block = Address of entity block
!	type = Entity type
!	number = Parameter or qualifier number
!
!	routine value = True if found, else false
!---

BEGIN

MAP
    name : REF BBLOCK;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

LOCAL
    label_string;

number = 1;							! Start at entity 1

WHILE (.block NEQ 0)						! Until end of entity list
DO BEGIN							!

   label_string = .block + .block [ent_w_label];		! Get label address

   IF CH$EQL(.name [dsc$w_length], .name [dsc$a_pointer],	! If this is the one we are looking for
	CH$RCHAR_A (label_string), .label_string, 0)		!
      THEN RETURN true;						! then return success

   IF .block [ent_l_next] NEQ 0					! If not end of list
      THEN block = .block [ent_l_next] + .wrk [wrk_l_tab_vec]	! then skip to next block
      ELSE RETURN false;					! else terminate loop
   number = .number + 1;					! Increment entity number
   END;								!

RETURN false;
END;

ROUTINE guess_entity (array) : entity_linkage =

!---
!
!	Locate a given entity (or list of entities), that may be at any 
!	level, by entity name string.  Fill in the array with the keyword
!	path that we found.  Search qualifiers 	first, then parameters.
!
! Inputs:
!
!	array = Address of keyword array
!
! Outputs:
!
!	block = Address of entity descriptor
!	type = Entity type
!	number = Parameter or qualifier number
!
!	routine value = True if found, else false
!
!	If entity not found, an error is signaled.
!---

BEGIN

MAP
    array : REF VECTOR;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

EXTERNAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

LOCAL
    found,
    buffer : BBLOCK [32],					! Buffer for upcased keyword label
    keyword : BBLOCK [dsc$c_s_bln];				! Descriptor for keyword label

!
! Get and upcase the keyword name string.
!
keyword [dsc$a_pointer] = buffer;				! Point at buffer
upcase (.array, keyword);					! Upcase the string

!
! Check the qualifier entity descriptors first.
!
block = .wrk [wrk_l_quablk];					! Get first qualifier entity block
type = qual_entity;						! Set qualifier type

WHILE (true)							! Search qualifiers and paramters
DO BEGIN							!
   number = 1;							! Set first entity

   WHILE (.block NEQ 0)						! Check each entity in the list
   DO BEGIN							!

      IF (found = guess_keyword_entity (keyword, .block, 2, 	! Is keyword down this path?
			array [0]))				!
	 THEN RETURN true;					! Yes, then stop looking

      IF .block [ent_l_next] NEQ 0				! If more entity blocks
	 THEN block = .block [ent_l_next] + .wrk [wrk_l_tab_vec]! Then calculate address of next
	 ELSE EXITLOOP;						! Else quit this loop

       number = .number + 1;					! Increment the entity number
       END;							!

!
! Check the parameter entity descriptors.
!
   IF .type EQL param_entity					! If parameters already searched
      THEN EXITLOOP;						! then exit loop
   block = .wrk [wrk_l_proptr];					! Get first parameter entity block
   type = param_entity;						! Set parameter type
   END;								!

!
! If keyword was not found, then signal an error;
!
SIGNAL (msg$_noentity, 1, array [0]);
RETURN false;

END;

ROUTINE guess_keyword_entity (keyword, block, level, array) =

!---
!
!	Locate the keyword entity block specified by the next keyword
!	descriptor in the list.
!
! Inputs:
!
!	name = Address of keyword name descriptor 
!	block = Last entity block
!	level = Depth of search
! 	array = Keyword descriptor array
!
! Outputs:
!
!	array is initialized
!
!	routine value = True if found, else false
!
!	If entity is not found, an error is signaled.
!---

BEGIN

MAP
    block : REF BBLOCK,
    array : REF VECTOR,
    keyword : REF BBLOCK;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

LOCAL 
    keyword_label : REF VECTOR [,BYTE];				! ASCIC entity name from tables

!
! Get the first keyword entity block.  If none, then exit with error.
! If successful, then calculate the block address and continue.
!
IF (.block [ent_l_user_type] EQL 0)				! If no more keyword entity blocks
	OR (.level EQL 2*(mcr_c_context + 1))			! or too deeply nested
   THEN RETURN false;						! Then exit with an error
block = .block [ent_l_user_type] + .wrk [wrk_l_tab_vec];	! Calculate the address of the first block
block = .block [ent_l_next] + .wrk [wrk_l_tab_vec]; 		! Skip list header

!
! Starting with this block, search the keyword list for the specified keyword.
!
WHILE (.block NEQ 0)						! Continue until an exitloop
DO BEGIN							!
   keyword_label = .block + .block [ent_w_label];		! Get keyword label

!
! If we find the keyword here, then we are at the deepest point in 
! the search.  Shift the lefotover keywords into the array at the
! appropriate level.
!
   IF CH$EQL (.keyword [dsc$w_length], .keyword [dsc$a_pointer],! Is it the keyword we want
	.keyword_label [0], keyword_label [1], 0)		!
      THEN BEGIN						! Yes, then fill in the array
	   LOCAL t_level;					!
	   t_level = 1;						! Set level to start search at

	   WHILE ((.t_level LEQ mcr_c_context)			! Count number of levels of keywords
		AND (.array [2 * .t_level] NEQ 0))		!
	   DO t_level = .t_level + 1;				!

	   IF (mcr_c_context - .level/2) LSSU .t_level		! If they won't fit in the leftover space
	      THEN RETURN false;				! Then exit with an error

	   CH$MOVE (4*2*.t_level, array [0], array [.level]);	! Shift the keywords over
	   RETURN true;						! Exit with success
	   END;							!

! If the keyword is found further down the tree, then we are currently 
! at an intermediate level.  Just insert the current keyword at the 
! appropriate level.
!
   IF guess_keyword_entity (.keyword, .block, .level + 2, 	! If the keyword is found deeper down
					array [0])   		!
      THEN BEGIN						!
	   array [.level] = .keyword_label [0];			! Then insert the current keyword
	   array [.level + 1] = keyword_label [1];		!   into the array
	   RETURN true;						! Exit with success
	   END;							!

!
! If no match, but more blocks, then keep looking.
!
   IF .block [ent_l_next] EQL 0					! Are there more entity blocks?
      THEN RETURN false;					! No, then error
   block = .block [ent_l_next] + .wrk [wrk_l_tab_vec];		! Yes, get next
   END;								!

RETURN true;							! No-op
END;

 
ROUTINE process_keyword_list (entity, keyword_list, token, default, 
				keyword_type, retdesc, qual) =
!---
!
!	Determine if the specified keywords are present.
!
! Inputs:
!
!	entity = Address of primary entity block
!	keyword_list = Address of list of keyword descriptors
!	token = Address of first param value token or actual qualifier token
!	default = True if only checking default values (token is invalid)
!	keyword_type = Param_entity or qual_entity depending on type of keywords
!	retdesc = If specified, then we are doing a CLI$GET_VALUE -
!		  use and modify context and return the requested value
!	qual = Address of first possible address of qualifier token
!		(requested by parameter_present and parameter_value)
!
! Outputs:
!
!	retdesc and qual are updated
!	routine value = status indicating presence
!
!---

BEGIN

MAP
    entity : REF BBLOCK,
    keyword_list : REF BBLOCK,	
    token : REF BBLOCK,
    retdesc : REF BBLOCK;

BUILTIN
    NULLPARAMETER;

GLOBAL REGISTER
    block=9:	REF BBLOCK,					! Address of descriptor block
    number=10,							! Parameter number
    type=11;							! Entity type

BIND 
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    token_context = ctl$gl_clintown [mcr_l_token] : VECTOR,	! Token context array
    last_qual = ctl$gl_clintown [mcr_l_qual];			! Last qualifier token 

LOCAL
    ctx,							! Index into context arrays
    found,							! Value found flag
    get_value,							! CLI$GET_VALUE in progress flag
    index,							! Result parse descriptor number
    negated,							! Explicit keyword negated flag
    plm :	REF BBLOCK;					! Address of parameter limit

!
! Set initial state variables.
!
get_value = NOT NULLPARAMETER (6);				! True if CLI$GET_VALUE, false if CLI$PRESENT
ctx = 1;							! Start with the second array elements
block = .entity;						! Start wih primary entity block
found = true;							! Assume the keyword/value will be found
negated = false;						! Assume no keyword will be negated

!
! Search for each keyword in the keyword path name.
!
WHILE ((.keyword_list [dsc$w_length] NEQ 0)			! While we have more keywords
	AND .found)						! and are still successful
DO BEGIN							!
   find_keyword_entity (.keyword_list);				! Get the keyword entity block
   keyword_list = .keyword_list + 8;				! Point to the next keyword descriptor

   !
   ! If we are doing a CLI$GET_VALUE, then we must concern ourselves with the old
   ! context arrays.  If we are using a previous context, then update the token 
   ! pointer, otherwise reset the context.
   !
   IF .get_value						! If we are doing a CLI$GET_VALUE
      THEN IF .block NEQ .entity_context [.ctx]			! And if we have no valid previous context
	      THEN zero_context_arrays (.ctx)			! Then erase the old context
	      ELSE BEGIN					! Else try to use it

		   IF ((.keyword_type EQL qual_entity) 		! If at /QUAL= level
			AND (.ctx EQL 1))
		      THEN token = .last_qual			! Then use the last qualifier context
		      ELSE token = .token_context [.ctx-1];	! Else use the last token context

		   IF .token LEQ 0				! If defaulted last time
		      THEN default = true			! Then set default value flag
		      ELSE negated = .token [ptr_v_negate];	! Else conditionally set negated flag

		   END;

   !
   ! If we have not yet encountered a defaulted keyword, then try to find 
   ! the specified keyword either in the context or in the command string.
   !
   IF NOT .default						! If no keyword was defaulted yet
      THEN BEGIN

	   LOCAL explicit;					! Assume some explicit value (not necessarily
	   explicit = true;					!   a match) is present

	   IF .get_value AND 					! If valid context exists
		(.block EQL .entity_context [.ctx])		!
	      THEN token = .token_context [.ctx-1];		! Then use it

	   IF ((.keyword_type EQL qual_entity) 			! If qualifier value
		OR (.ctx NEQ 1))				! or not level 1 parameter value,
		AND NOT (.get_value AND				! Then if not using an old context
			(.entity_context [.ctx] NEQ 0))  	!
	      THEN explicit = found = 				! Then get the first value in the list
			get_explicit_value (token, 1);		!
	
	   WHILE (.found AND					! Check all keywords in the value list
			(.token [ptr_b_number] NEQ .number)) 	!
	   DO found = get_explicit_value (token, 0);		! for the one we want
	
	   IF .found 						! If an explicit match was found
	      THEN negated = .token [ptr_v_negate]		! Then conditionally set negated flag
	      ELSE IF NOT .explicit				! If no match was found and no values were present
		      THEN default = true;			! Then plan to look for a default value

	   END;

   !
   ! If some keyword was defaulted, or no explicit value was found, then
   ! check to see if this keyword was defaulted.
   !
   IF .default 							! If no explicit value is present
      THEN IF NOT .block [ent_v_deftrue]			! Then if the keyword is not defaulted present
	      THEN found = false				! Then mark it not found
	      ELSE found = true;				! Else mark it found

   !
   ! If we are doing a CLI$GET_VALUE, and if we found the keyword, then update
   ! the context arrays.
   !
   IF (.get_value AND .found)					! If context should be updated
      THEN BEGIN						! Then do so
	   IF NOT .default					! If keyword was explicitly found
	      THEN token_context [.ctx-1] = .token		! Then use that found token
	      ELSE IF .entity_context [.ctx] EQL 0		! Else if no old context
		      THEN token_context [.ctx-1] = 0		! Then mark keyword "new default"
		      ELSE IF token_context [.ctx-1] LEQ 0	! Else if already defaulted
			      THEN token_context [.ctx-1] = -1	! Then mark "default value already returned"
			      ELSE token_context [.ctx-1] = 0;	! Else mark "new default"
	   entity_context [.ctx] = .block;			! Update the entity context
	   END;

   !
   ! Save the first possible address of a quaifier for the parameter_present and
   ! parameter_value routines.
   !
   IF NOT NULLPARAMETER (7) AND (.ctx EQL 1) AND .found AND NOT .default
      THEN .qual = .token;

   ctx = .ctx + 1;						! Increment the context level
   END;

!
! If no value was found, then return that status now.
!
IF NOT .found							! If the keyword was not found
   THEN RETURN cli$_absent;					! Then say so

!
! If we are doing a PRESENT, then return the correct found status now.
!
IF NULLPARAMETER (6) 						! If doing a PRESENT
   THEN IF .default						! If value was defaulted
	   THEN RETURN cli$_defaulted				! Then say so
	   ELSE IF .token [ptr_v_negate]			! Else if it was negated
		   THEN RETURN cli$_negated			! Then so indicate
		   ELSE RETURN cli$_present;			! Else say it was present

!
! If we are doing GET_VALUE then return the appropriate value and status.
!
IF .default							! If the keyword was defaulted
   THEN IF .negated						! and if a keyword was negated
	   THEN RETURN cli$_absent				! Then return absent
	   ELSE RETURN get_default_value(.block,.ctx-1,.retdesc)! Else return the default value
   ELSE RETURN get_next_value(.token, .block, .ctx-1, .retdesc);! Else return the explicit value

END;

ROUTINE get_param_token (index, rettoken) =

!---
!
!	Get the next token in the command line which is a parameter value.
!
! Inputs:
!
!	index = Address of longword containing previous token index.
!	rettoken = Address of longword to receive token descriptor address
!
! Outputs:
!
!	index = Address of longword containing token index of parameter.
!	rettoken = Address of longword containing token descriptor address.
!
!	routine value = True if parameter value found, false if eol detected.
!---

BEGIN

BIND
    wrk = ctl$gl_dclprsown : REF BBLOCK;

LOCAL
    token:	REF BBLOCK;					! Address of token descriptor

token = token_desc(..index);					! Get starting token descriptor address

WHILE (.token [ptr_v_type] NEQ ptr_k_endline)			! Get each token on the line
DO BEGIN							! Until the end of the line is reached
   token = .token + ptr_c_length;				! Skip to the next token
   .index = ..index + 1;					! Increment the token index

   IF (.token [ptr_v_type] EQL ptr_k_parametr)			! If a parameter value was found
	AND (.token [ptr_b_level] EQL 1)			! and it is at level one
      THEN BEGIN						! then return success
	   .rettoken = .token;					! Return token
	   RETURN true;						! and indicate found
	   END;							!

   END;

RETURN false;							! Indicate no parameter found

END;

ROUTINE get_next_value (token, entity, ctx, retdesc) =
!---
!
!	Get the next explicit or default value in the current value list.
!
! Inputs:
!
!	token = address of the last token examined
!	entity = address of the last entity descriptor block examined
!	ctx = current context level
!	retdesc = address of return value descriptor
!
! Outputs:
!
!	retdesc is filled in
! 	routine value is true if value is found, else false
!
!---

BEGIN

MAP
    token : REF BBLOCK;

BIND 
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    token_context = ctl$gl_clintown [mcr_l_token] : VECTOR;	! Token context array

LOCAL
    found;							! Value found flag

IF .token_context [.ctx] EQL -1					! Have we already exhausted these values?
   THEN RETURN cli$_absent;					! Yes, then return null string

IF (.token_context [.ctx] GTR 0) 				! If there is an extant value context
	AND (.entity_context [.ctx + 1] GTR 0)			! and if we are backing up a level
   THEN token_context [.ctx] = 0;				! Then get the first value

IF .token_context [.ctx] EQL 0					! Is there an extant value context?
   THEN IF (found = get_explicit_value (token, 1))		! No, then find the first value
	   THEN token_context [.ctx] = .token			! and save it's location as context
	   ELSE IF .token [ptr_v_negate]			! Not found, was the previous keyword negated?
		   THEN RETURN cli$_absent			! Yes, then return absent		
		   ELSE RETURN get_default_value		! No, return default value
				(.entity,.ctx,.retdesc);	!

token = .token_context [.ctx];					! Set the value context
get_specified_value (.token, .retdesc);				! Get the qualifier value

IF found = get_explicit_value (token, 0)			! Is there a next value?
   THEN token_context [.ctx] = .token				! Yes, then set the new context
   ELSE BEGIN							! No, 
	token_context [.ctx] = -1;				! Then invalidate the context
	found = true;						! But return that the current value was found
	END;							!

zero_context_arrays (.ctx + 1);					! Zero the context past this point

RETURN .found;							! Return generic status
END;

ROUTINE get_explicit_value (token, level) =
!---
!
!	Get the next explicit value in the current value list.
!
! Inputs:
!
!	token = address of address of the last token examined
!	level = flag, if present, get first value at the next level
!
! Outputs:
!
!	token and level are updated
!	routine value = True if found, else false
!---

BEGIN

LOCAL
    ptr : REF BBLOCK;

!
! If starting a new value level, then set the level value and check that
! the previous terminator is and equal sign (KEYWORD=).
!
ptr = ..token;						! Get address of last token examined
IF .level EQL 0						! If next value is at current level
   THEN level = .ptr [ptr_b_level]			! Then get that level from the token desc
   ELSE BEGIN						! Else 
	IF .ptr [ptr_v_term] NEQ ptr_k_colon		! Verify that previous token ends with a colon
	   THEN RETURN cli$_absent;			! Return no more values if not
	level = .ptr [ptr_b_level] + 1;			! Indiate that we want a more deeply nested value
	END;						!

!
! Get the next value in the list.
!
WHILE (.ptr [ptr_v_type] NEQ ptr_k_endline)		! While there are more tokens left to examine
DO BEGIN						! Scan for the next value
   ptr = .ptr + ptr_c_length;				! Get the next token

   IF .ptr [ptr_b_level] LSSU .level			! If it is shallower than the value we want
      THEN RETURN cli$_absent;				! Then return not found

   IF .ptr [ptr_b_level] EQL .level			! If it is the level we want
      THEN IF (.level NEQ 1) OR				! Then if not mistaking a qualifier for a 
	        (.ptr [ptr_v_type] EQL ptr_k_parametr)	! parameter value 
	      THEN EXITLOOP;				! Then exit the loop

   END;

!
! If end of line, then return not found.
!
IF .ptr [ptr_v_type] EQL ptr_k_endline			! If EOL
   THEN RETURN cli$_absent;				! Then return not found

!
! If we've gotten this far, then we've found a value.  Return it.
! Also, set the success status according to the type of terminator that
! immediately preceeds the value.
!
.token = .ptr;						! Return pointer to token desc
ptr = .ptr - ptr_c_length;				! Back up one descriptor
IF .ptr [ptr_v_term] EQL ptr_k_plus			! If previous value,
   THEN RETURN cli$_concat				! then return plus or comma
   ELSE IF .ptr [ptr_v_term] EQL ptr_k_comma		! depending on the terminator
	   THEN RETURN cli$_comma			!
	   ELSE RETURN true;				! Return no previous value

END;

ROUTINE get_specified_value (token, retdesc) =
!---
!
!	Get the value (possibly extending down several levels) that begins 
!	with the specified token.
!
! Inputs:
!
!	token = Address of the first token in the value
!	retdesc = Address of the descriptor to return the result in
!
! Outputs:
!
!	retdesc is updated
!	routine value = always true
!---

BEGIN

MAP
    retdesc : REF BBLOCK,
    token : REF BBLOCK;

BIND
    wrk = ctl$gl_dclprsown : REF BBLOCK;

LOCAL
    count,						! Number of tokens in value
    parens,						! Parenthesis count
    ptr : REF BBLOCK;					! Pointer to token after the value

!
! Initialize the local variables.
!
parens = 0;						! Set no parenthesis seen
count = 1;						! Start with one token
ptr = .token + ptr_c_length;				! Point to second token

!
! Get all value tokens in the command that are part of this value.
!
WHILE ((.ptr [ptr_v_type] NEQ ptr_k_endline) AND	! While there are still tokens on the line
	(.ptr [ptr_b_level] GTR .token [ptr_b_level]))	! and they are part of the current value
DO BEGIN						! Update the local variables
   LOCAL index;

   !
   ! If token is preceeded by a "(", then increment the paren count.
   !
   IF CH$RCHAR (.ptr [ptr_v_offset] + wrk [wrk_g_buffer] - 1) EQL %C'('
      THEN parens = .parens + 1;

   !
   ! If token is terminated by ")"s, then decrement the paren count
   ! appropriately.
   index = 0;
   WHILE (CH$RCHAR (.ptr [ptr_v_offset] + wrk [wrk_g_buffer] 
			+ .ptr [ptr_b_value] + .index) EQL %C')')
      DO index = .index + 1;
   parens = .parens - .index;

   !
   ! Update the last token pointer and the token count.
   !
   ptr = .ptr + ptr_c_length;
   count = .count + 1;
   END;

!
! Strip off the terminator if appropriate and return the value that we found.
!
retdesc [dsc$a_pointer] = .token [ptr_v_offset] + wrk [wrk_g_buffer];
IF .count EQL 1
   THEN retdesc [dsc$w_length] = .token [ptr_b_value]
   ELSE BEGIN
	retdesc [dsc$w_length] = .ptr [ptr_v_offset] - .token [ptr_v_offset];
	IF .ptr [ptr_v_type] NEQ ptr_k_endline
	   THEN retdesc [dsc$w_length] = .retdesc [dsc$w_length] - 1;
	retdesc [dsc$w_length] = .retdesc [dsc$w_length] + .parens;
	END;

RETURN true;
END;

ROUTINE get_default_value (entity, ctx, retdesc) =
!---
!
!	Get the default value associated with the specified entity.
!
! Inputs:
!
!	entity = Address of an entity descriptor block
!	ctx = Context level of last entity
!	retdesc = Address of a string descriptor to return the result in
!
! Outputs:
!
!	retdesc is returned as described above
!---

BEGIN

MAP
    entity : REF BBLOCK,
    retdesc : REF BBLOCK;

BIND
    wrk = ctl$gl_dclprsown : REF BBLOCK,			! Address of command work area
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    token_context = ctl$gl_clintown [mcr_l_token] : VECTOR;	! Token context array

LOCAL
    found,							! Value found flag
    string : BBLOCK [dsc$c_s_bln],				! Local descriptor for value
    value : REF VECTOR [,BYTE];					! Address of ASCIC value

!
! Initialize the default value buffer
!
ctl$gl_clintown [mcr_w_deflen] = 0;				! Clear default value buffer

!
! If there is a default value associated with the entity, and we have not
! returned it before, then return it now.
!
IF .entity [ent_w_defval] NEQ 0					! If default value
   THEN IF (.entity_context [.ctx] EQL .entity)			! Then, if returned before
		AND (.token_context [.ctx] EQL -1)		!
	   THEN RETURN cli$_absent				! Then return not found
	   ELSE BEGIN						! Else return the value
		value = .entity + .entity [ent_w_defval] + 1;	! Get address of ASCIC string
		retdesc [dsc$w_length] = .value [0];		! Get default value
		retdesc [dsc$a_pointer] = value [1];		!
		token_context [.ctx] = -1;			! Do not return again
		RETURN true;					! Return found
		END;						!

!
! If there is no keyword list associated with the entity.  Than it can no
! longer have a default value.
!
IF .entity [ent_l_user_type] EQL 0				! If no keyword list
   THEN RETURN cli$_absent;					! Return no value

!
! If we have a previous keyword context, then use it.
!
ctx = .ctx + 1;							! Increment context level
IF (.entity_context [.ctx] GTR 0)				! If we have a previous context
	AND (.entity_context [.ctx + 1] EQL 0)			! but are not backing up a level
   THEN BEGIN							! Then use it
	entity = .entity_context [.ctx];			! Get last keyword returned
	IF .entity [ent_l_next] EQL 0				! If no more keywords
	   THEN RETURN cli$_absent				! Then return no value
	   ELSE entity = .entity [ent_l_next] 			! Else point to next
				+ .wrk [wrk_l_tab_vec];		!
	END							!
   ELSE BEGIN							!
	entity = .entity[ent_l_user_type] + .wrk[wrk_l_tab_vec];! Else start with first keyword
	entity = .entity [ent_l_next] + .wrk [wrk_l_tab_vec]; 	! Skip list header
	END;							!
zero_context_arrays (.ctx + 1);					! Zero the context arrays from this point

!
! Find the next keyword that is present by default.  Return it and any
! default value that may be associated with it.
!
found = cli$_absent;						! Assume no value will be found
WHILE (.entity NEQ 0)						! Loop will be exited by EXITLOOP
DO BEGIN
   IF .entity [ent_v_deftrue]					! If keyword is present by default
      THEN BEGIN						! Then return it

	   IF .found						! If a value was already found
	      THEN RETURN cli$_comma				! Then return "another value" status
	      ELSE found = true;				! Else mark value found

	   value = .entity + .entity [ent_w_name];		! Get address of ASCIC string
	   token_context [.ctx] = 0;				! Mark entity defaulted
	   entity_context [.ctx] = .entity;			!

	   IF (.entity [ent_l_user_type] NEQ 0)			! If keyword can have
		OR (.entity [ent_w_defval] NEQ 0)		! a default value
	      THEN BEGIN					! Then process it
		   string [dsc$w_length] = .value [0];		! Get keyword name
		   string [dsc$a_pointer] = value [1];		!
		   insert_string (string);			! Insert keyword into buffer
		   insert_next_level (.entity);			! Insert its def val into buffer
		   CH$MOVE (dsc$c_s_bln, 			! Get the result
		     ctl$gl_clintown [mcr_w_deflen], .retdesc);	!
		   END						!
	      ELSE BEGIN					! Else simply return the keyword
		   retdesc [dsc$w_length] = .value [0];		! Get keyword name
		   retdesc [dsc$a_pointer] = value [1];		!
		   END;						!

	   END;

   IF .entity [ent_l_next] EQL 0				! If no more keywords
      THEN RETURN .found;					! Then return status
   entity = .entity [ent_l_next] + .wrk [wrk_l_tab_vec];	! Get next keyword
   END;

RETURN true;
END;

ROUTINE insert_next_level (entity) =
!---
!
!	Put the next level of default values associated with the specified 
!	entity into the default value buffer.
!
! Inputs:
!
!	entity = Address of an entity descriptor block
!
! Outputs:
!
!	The default value buffer is updated.
!---

BEGIN

MAP
    entity : REF BBLOCK;

BIND
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

LOCAL
    first,							! First value found flag
    string : BBLOCK [dsc$c_s_bln],				! Local descriptor for value
    value : REF VECTOR [,BYTE];					! Address of ASCIC value

!
! If there is a default value associated with the entity, then return it now.
!
IF .entity [ent_w_defval] NEQ 0					! If default value
   THEN BEGIN
	insert_char (%C'=');					! Insert an equals sign
	value = .entity + .entity [ent_w_defval] + 1;		! Get address of ASCIC string
	string [dsc$w_length] = .value [0];			! Get default value
	string [dsc$a_pointer] = value [1];		
	insert_string (string);					! Insert the default value
	RETURN true;						! Return found
	END;

!
! If there is no keyword list associated with the entity.  Than it can no
! longer have a default value.
!
IF .entity [ent_l_user_type] EQL 0				! If no keyword list
   THEN RETURN false;						! Return no value

!
! Get the address of the first keyword.  Set the first value flag.
!
entity = .entity [ent_l_user_type] + .wrk [wrk_l_tab_vec];	! Start with first keyword
entity = .entity [ent_l_next] + .wrk [wrk_l_tab_vec]; 		! Skip list header
first = true;

!
! Find each keyword that is present by default.  Insert it and any default 
! value that may be associated with it.
!
WHILE (.entity NEQ 0)						! Loop will be exited by EXITLOOP
DO BEGIN
   IF .entity [ent_v_deftrue]					! If keyword is present by default
      THEN BEGIN						! Then insert it
	   IF .first						! If first value
	      THEN BEGIN
		   first = false;				! Clear the flag
		   insert_char (%C'=');				! Insert an equals sign
		   insert_char (%C'(');				! Insert an open parenthesis
		   END
	      ELSE insert_char (%C',');				! Else insert a comma
	   value = .entity + .entity [ent_w_name];		! Get address of ASCIC string
	   string [dsc$w_length] = .value [0];			! Get keyword name
	   string [dsc$a_pointer] = value [1];		
	   insert_string (string);				! Insert keyword into buffer
	   insert_next_level (.entity);				! Insert its def val into buffer
	   END;
		   
   IF .entity [ent_l_next] EQL 0				! If no more keywords
      THEN EXITLOOP;						! Then done
   entity = .entity [ent_l_next] + .wrk [wrk_l_tab_vec];	! Get next keyword
   END;

IF NOT .first							! If we have an open paren
   THEN insert_char (%C')');					! Then match it

RETURN true;
END;

ROUTINE insert_string (string) =

!---
!
!	Insert the specified string into the defalut value buffer.
!
! Inputs:
!
!	string = Address of the string descriptor of the value to insert
!
! Outputs:
!
!	the default value buffer is modified as described above
!---

BEGIN

MAP
    string : REF BBLOCK;

BIND
    retdesc = ctl$gl_clintown [mcr_w_deflen] : BBLOCK,		! Default value string descriptor
    size = ctl$gl_clintown [mcr_w_buflen] : WORD;		! Default value buffer size

!
! If default buffer cannot fit string, then increase its size.
!
IF (.size - .retdesc[dsc$w_length]) LSSU .string [dsc$w_length]	! If not enough space in the buffer
   THEN allocate_default_buffer (.string [dsc$w_length]);	! Then increase its size

!
! Insert the string.
!
CH$MOVE (.string [dsc$w_length], .string [dsc$a_pointer],	! Insert the string
	    .retdesc [dsc$a_pointer] + .retdesc [dsc$w_length]);
retdesc [dsc$w_length] = .retdesc [dsc$w_length] 		! Update the length
	    + .string [dsc$w_length];
RETURN true;

END;

ROUTINE insert_char (char) =

!---
!
!	Insert the specified character into the defalut value buffer.
!
! Inputs:
!
!	char = The value of the character to insert
!
! Outputs:
!
!	the default value buffer is modified as described above
!---

BEGIN

MAP
    char : BYTE;

BIND
    retdesc = ctl$gl_clintown [mcr_w_deflen] : BBLOCK,		! Default value string descriptor
    size = ctl$gl_clintown [mcr_w_buflen] : WORD;		! Default value buffer size

!
! If default buffer cannot fit string, then increase its size.
!
IF (.size - .retdesc[dsc$w_length]) LSSU 1			! If not enough space in the buffer
   THEN allocate_default_buffer (1);				! Then increase its size

!
! Insert the character.
!
CH$WCHAR (.char, .retdesc [dsc$a_pointer] + 			! Insert the character
			.retdesc [dsc$w_length]);
retdesc [dsc$w_length] = .retdesc [dsc$w_length] + 1;		! Update the length
RETURN true;

END;

ROUTINE allocate_default_buffer (length) =

!---
!
!	Expand the default value buffer by at least the specified string length.
!
! Inputs:
!
!	length = the size of the most recent string being inserted
!
! Outputs:
!
!	the default value buffer is modified as described above
!---

BEGIN

BIND
    retdesc = ctl$gl_clintown [mcr_w_deflen] : BBLOCK,		! Default value string descriptor
    size = ctl$gl_clintown [mcr_w_buflen] : WORD;		! Default value buffer size

LITERAL
    slot = 128;							! Increments to increase the buffer size by 

LOCAL
    address,
    old_size,
    status;

old_size = .size;						! Get old size
size = ((.retdesc [dsc$w_length] + .length / slot) + 1) * slot;	! Calculate size of new buffer
IF NOT (status = (.ctl$gl_clintown [mcr_l_getvm])		! Get new buffer
			(size, address))
   THEN SIGNAL (.status);					! Signal any error
CH$MOVE (.retdesc [dsc$w_length], .retdesc [dsc$a_pointer],	! Copy old value
		.address);
(.ctl$gl_clintown [mcr_l_freevm]) (old_size, 			! Free old buffer
		retdesc [dsc$a_pointer]);
retdesc [dsc$a_pointer] = .address;				! Save new buffer
RETURN true;
END;

ROUTINE local_qualifier (entity, number) =

!---
!
!	Locate the last local occurrence of a qualifier on the command
!	line and return the token descriptor.  
!
! Inputs:
!
!	entity = Address of entity descriptor block
!	number = Qualifier number to search for
!
! Outputs:
!
!	routine value = Address of token descriptor if found, else 0
!---

BEGIN

MAP
    entity:	REF BBLOCK;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK,
    prmlim = ctl$gl_clintown [mcr_l_prmlim] : VECTOR,
    last_param = ctl$gl_clintown [mcr_b_param] : BYTE;

LOCAL
    token:	REF BBLOCK,					! Address of current token
    index,							! Index of current token
    match;							! Address of last matching token

!
! If the qualifier has local or positional placement, then search for
! a parmqual starting at the last parameter value returned until the
! next parameter value.
!
match = false;							! If no match is found, then return false
IF .entity [ent_v_parm]						! If local or position placement,
    AND .last_param NEQ 0					! and we have recently requested a parm
   THEN BEGIN
	LOCAL plm: REF BBLOCK;					! Address of parameter limit descriptor
	plm = prmlim [.last_param-1];				! Limits of last parameter requested
	index = .plm [plm_b_quadesc];				! Start following last value returned

	WHILE .index NEQ 0					! While range not yet exhausted,
		AND .index LEQU .plm [plm_b_lstdesc]		!
	DO BEGIN						!
	   token = token_desc(.index);				! Get token descriptor

	   IF (.token [ptr_v_type] EQL ptr_k_parametr)		! If a parameter value,
		AND (.token [ptr_b_level] EQL 1)		!
	      THEN EXITLOOP;					! then stop the parameter search

	   IF (.token [ptr_v_type] EQL ptr_k_parmqual)		! If parameter qualifier,
		AND (.token [ptr_b_number] EQL .number) 		! and its ours,
	      THEN match = .token;				! Return descriptor of parmqual

	   index = .index + 1;					! Skip to next descriptor
	   END;							!

	END;

RETURN .match;							! Return token address or false

END;

ROUTINE global_qualifier (entity, number) =

!---
!
!	Locate the last global occurrence of a qualifier on the command
!	line and return the token descriptor.  
!
! Inputs:
!
!	entity = Address of entity descriptor block
!	number = Qualifier number to search for
!
! Outputs:
!
!	routine value = Address of token descriptor if found, else 0
!---

BEGIN

BIND 
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    last_qual = ctl$gl_clintown [mcr_l_qual],			! Last qualifier token 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

LOCAL
    last:	REF BBLOCK,					! Address of token for last occurrence
    token:	REF BBLOCK,					! Address of current token
    index;							! Index of current token

!
! If in midst of CLI$NEXT_QUAL call, then return the already found global
! qualifier token.
!
IF .ctl$gl_clintown [mcr_v_nextqual] AND (.entity_context [0] EQL .entity)
   THEN RETURN .last_qual;

!
! Search for the last occurrence as a command qualifier.
!
last = 0;							! Indicate no occurrences found
index = 1;
token = token_desc(1);						! Start at first token descriptor

WHILE (.token [ptr_v_type] NEQ ptr_k_endline)			! Until end of command line
DO BEGIN							!

   IF .token [ptr_v_type] EQL ptr_k_comdqual			! If token is a qualifier
	AND .token [ptr_b_number] EQL .number			! and its our qualifier
      THEN last = .token;					! Save last occurrence of qualifier

   token = .token + ptr_c_length;				! Skip to next token
   index = .index + 1;						! and increment token index
   END;								!

RETURN .last;							! Return address of token descriptor

END;

ROUTINE token_string (token, retdesc): NOVALUE =

!---
!
!	Create a string descriptor of a token string
!
! Inputs:
!
!	token = Address of token descriptor
!	retdesc = Address of quadword to receive string descriptor
!
! Outputs:
!
!	retdesc = Descriptor of token string
!---

BEGIN

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

MAP
    token:	REF BBLOCK,
    retdesc:	REF VECTOR [2];

retdesc [0] = .token [ptr_b_value];				! Return the token length
retdesc [1] = wrk [wrk_g_buffer] + .token [ptr_v_offset];	! Return the token address

END;

ROUTINE upcase (input, output): NOVALUE =

!---
!
!	Upcase a string.
!
! Inputs:
!
!	input = address of input string descriptor
!	output = address of output string descriptor
!
! Outputs:
!
!	The string is upcased.
!---

BEGIN

MAP
    input : REF BBLOCK,
    output : REF BBLOCK;

REGISTER
    ptr: REF VECTOR [,BYTE],					! Pointer into the character string
    char: BYTE;							! Character to test

output [dsc$w_length] = .input [dsc$w_length];			! Use the original string length
CH$COPY(.input [dsc$w_length], .input [dsc$a_pointer], 		! Copy the input to the output
		0, 32, .output [dsc$a_pointer]);		!

ptr = .output [dsc$a_pointer];					! Starting address of string
DECR count FROM .input [dsc$w_length]-1				! Upcase the characters
DO BEGIN							!
   char = CH$RCHAR_A (ptr);					! Get next character
   IF .char GEQU 'a'						! Lower case letter?
	AND .char LEQU 'z'					!
      THEN ptr [-1] = .char - ('a' - 'A');			! Convert to upper
   END;								!

END;

ROUTINE convert_keyword_list (desc, array) =

!---
!
! 	Take the user's string apart and fill in the keyword array.
!
! Inputs:
!
!	desc = Address of descriptor of user's input string
!	array = Address of the array of descriptors to be filled in
!
! Outputs:
!
!	The array is set up.
!	False is returned if there is a syntax error in the input string.
!	The error is signalled here.
!---

BEGIN

MAP
    desc : REF BBLOCK,
    array : REF VECTOR;

LOCAL
    ptr,
    old_ptr,
    index,
    status;

CH$FILL (0, 4*(2*(mcr_c_context+1)+1), .array);
ptr = old_ptr = .desc [dsc$a_pointer];
index = 0;
status = false;

WHILE ((.ptr LSSU .desc [dsc$a_pointer] + .desc [dsc$w_length])
	AND (.index LSSU 2*(mcr_c_context+1)))
DO BEGIN
   ptr = CH$FIND_CH (.desc [dsc$a_pointer] + .desc [dsc$w_length] - .ptr,
			.ptr, %C'.');
   IF .ptr EQL 0
      THEN EXITLOOP status = true;
   array [.index] = .ptr - .old_ptr;
   array [.index + 1] = .old_ptr;
   ptr = .ptr + 1;
   old_ptr = .ptr;
   index = .index + 2;
   END;

IF NOT .status
   THEN BEGIN
	SIGNAL (msg$_noentity, 1, .desc);
	RETURN false
	END;      
   
array [.index] = .desc [dsc$a_pointer] + .desc [dsc$w_length] - .old_ptr;
array [.index + 1] = .old_ptr;
RETURN true;
END;

ROUTINE batch_job =

!---
!
!	This routine returns a boolean value indicating whether
!	the current process is a batch job or not.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	Routine value is true if a batch job, else false
!---

BEGIN

LOCAL
    pcb_sts:	BBLOCK [4],					! PCB status flags
    item_list:	BBLOCK [16];					! GETJPI item list

!
! Get job status flags to determine type of job
!

item_list [0,0,16,0] = 4;					! Buffer length
item_list [2,0,16,0] = jpi$_sts;				! JPI code
item_list [4,0,32,0] = pcb_sts;					! Buffer address
item_list [8,0,32,0] = 0;					! Address to return item length
item_list [12,0,32,0] = 0;					! End of item list

return_if_error($GETJPI(ITMLST = item_list));			! Obtain PCB flags

RETURN .pcb_sts <$BITPOSITION(pcb$v_batch),1>;			! True if batch job

END;

GLOBAL ROUTINE mcr$nextqual (rqdesc, rqwork, rqbits) =

!---
!
!	Point to the next instance of the specified qualifier 
!	in the command line.
!
! Inputs:
!
!	rqdesc = Address of request descriptor data structure
!	rqword, rqbits = ignored
!
! Outputs:
!
!	Routine value:
!
!		success = cli$_present
!			  cli$_locpres
!			  cli$_defaulted
!
!		failure = cli$_absent
!			  cli$_negated
!			  cli$_locneg
!		  
!	All errors are signalled.
!---

BEGIN

MAP 
   rqdesc : REF BBLOCK;

BIND
    entity_context = ctl$gl_clintown [mcr_l_entity] : VECTOR,	! Entity context array
    token_context = ctl$gl_clintown [mcr_l_token] : VECTOR,	! Token context array
    last_qual = ctl$gl_clintown [mcr_l_qual],			! Last qualifier token 
    wrk = ctl$gl_dclprsown : REF BBLOCK;			! Address of command work area

GLOBAL REGISTER
    block=9:	REF BBLOCK,					! Address of entity descriptor block
    number=10,							! Parameter/qualifier number
    type=11;							! Entity type

LOCAL
    token : REF BBLOCK,						! Ptr to token descriptor
    keyword_array : VECTOR [2*(mcr_c_context+1)+1];		! Keyword array

!
! Initialize CLINT if necessary.
!
IF .ctl$gl_clintown EQL 0					! If not yet initialized,
   THEN initialize (.rqdesc [int_l_getvm], 			! then initialize parsing
			.rqdesc [int_l_freevm]);

!
! Verify that valid entities were specified.
!
return_if_error (verify_entities (rqdesc [int_w_entlen], 	! Verify all specified entities
			keyword_array));

!
! If the entity is not a qualifier then return an error.
!
IF (.type NEQ qual_entity) OR
	(.keyword_array [2] NEQ 0)
   THEN BEGIN
	SIGNAL (msg$_noentity,1,keyword_array [0]);		! Then signal the error
	RETURN false;						! Return the status
	END;

!
! Do we have a previous context?  If so, start search there.
!
IF .entity_context [0] EQL .block
   THEN token = .last_qual + ptr_c_length
   ELSE token =  token_desc(1);
zero_context_arrays [0];
last_qual = 0;

!
! Search for the next occurrence as a command qualifier.
!
WHILE (.token [ptr_v_type] NEQ ptr_k_endline)			! Until end of command line
DO BEGIN							!

   IF (.token [ptr_v_type] EQL ptr_k_comdqual)			! If token is a qualifier
	AND (.token [ptr_b_number] EQL .number)			! and its our qualifier
      THEN BEGIN						! Save last occurrence of qualifier
	   last_qual = .token;					!
	   entity_context [0] = .block;				!
	   ctl$gl_clintown [mcr_v_nextqual] = true;		! Set nextqual qualifier parse
	   RETURN cli$_present;					!
	   END;							!

   token = .token + ptr_c_length;				! Skip to next token
   END;

ctl$gl_clintown [mcr_v_nextqual] = false;			! Set normal qualifier parse
RETURN cli$_absent;						! Return address of token descriptor
END;

END
ELUDOM
