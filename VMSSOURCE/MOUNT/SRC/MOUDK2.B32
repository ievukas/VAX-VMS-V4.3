MODULE MOUDK2 (
		LANGUAGE (BLISS32),
		IDENT = 'V04-002'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  MOUNT Utility Structure Level 2
!
! ABSTRACT:
!
!	This routine performs all of the mechanics of mounting a disk,
!	given as input the parsed and partially validated command line.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  17-Oct-1977  17:41
!
! MODIFIED BY:
!
!	V04-002	HH0057		Hai Huang		12-Sep-1984
!		Clear DEV$V_MNT bit along with UCB$L_VCB on error 
!		path.
!
!	V04-001	HH0056		Hai Huang		11-Sep-1984
!		Return SS$_VOLINV status when appropriate to facilitate
!		retry on volume invalid errors.
!
!	V03-030	CDS0011		Christian D. Saether	29-Aug-1984
!		Only set up QUO_CACHE for RVN 1.  Ignore quodirty
!		flag for other than RVN 1.
!
!	V03-029	HH0045		Hai Huang		10-Aug-1984
!		Take out the volume lock for shared foreign mounts.
!
!	V03-028	ACG0438		Andrew C. Goldstein,	25-Jul-1984  11:48
!		Initialize cache flusher ACB's in the VCA
!
!	V03-027	HH0041		Hai Huang		24-Jul-1984
!		Remove REQUIRE 'LIBD$:[VMSLIB.OBJ]MOUNTMSG.B32'.
!
!	V03-026	HH0039		Hai Huang		20-Jul-1984
!		Return SS$_NOHOMEBLK if index file header checks fail.
!
!	V03-025	LMP0275		L. Mark Pilant,		12-Jul-1984  21:38
!		Initialize the ACL info in the ORB to be a null descriptor
!		list rather than an empty queue.  This avoids the overhead
!		of locking and unlocking the ACL mutex, only to find out
!		that the ACL was empty.
!
!	V03-024	CDS0010		Christian D. Saether	12-Jul-1984
!		Clean up handling of quodirty flag and rebuilding
!		decisions thereof.  Don't output REBLDREQD informational
!		until after the volume is mounted.
!
!	V03-023	CDS0009		Christian D. Saether	11-Jul-1984
!		Don't call check_cluster_sanity until after we've
!		determined whether disk is write-locked.
!		Don't rundown locks in cleanup handler until
!		after scb has been rewritten.
!		Revive use of SCB$L_STATUS and SCB$L_STATUS2 flags.
!
!	V03-022	HH0031		Hai Huang		03-Jul-1984
!		Set up FCB$L_LOCKBASIS correctly when creating a volume
!		set.
!
!	V03-021	HH0029		Hai Huang		29-Jun-1984
!		Ouput informational message about reduced cache when
!		appropriate.
!
!	V03-020	CDS0008		Christian D. Saether	17-May-1984
!		Remove reference to VC_NOALLOC.  That flag is no
!		longer used by the file system.
!
!	V03-019	CDS0007		Christian D. Saether	26-Apr-1984
!		Bump FCB$W_REFCNT for index file fcb.
!
!	V03-018	LMP0221		L. Mark Pilant,		28-Mar-1984  9:57
!		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
!		ORB$W_PROT.
!
!	V03-017	ROW0326		Ralph O. Weber		20-MAR-1984
!		Add setup of VCB$Q_MOUNTTIME for later testing by mount 
!		verification.
!
!	V03-016	HH0004		Hai Huang		11-Mar-1984
!		Fix truncation errors introduced by cluster-wide 
!		mount support.
!
!	V03-015	ACG0400		Andrew C. Goldstein,	10-Mar-1984  1:29
!		Turn quota cache back on
!
!	V03-014	HH0002		Hai Huang		01-Feb-1984
!		Add job-wide mount support, i.e. always deallocate
!		mount list entries to paged-pool in condition handler.
!
!	V03-013	CDS0006		Christian D. Saether	18-Oct-1983
!		Move STORE_CONTEXT call to before quota file activation.
!
!	V03-012	CDS0005		Christian D. Saether	 1-Sep-1983
!		Only make duplicate volume set name test for first
!		volume mounted.  Clear UCB pointer in RVT in kernel
!		mode handler on error paths.
!
!	V03-011	CDS0004		Christian D. Saether	30-Aug-1983
!		Use different local for rvt ucb scan.
!
!	V03-010	CDS0003		Christian D. Saether	 3-Aug-1983
!		Cluster consistency checks added.
!		Remove the earlier crude mount serialization now
!		that MOUNT_VOLUME does it based on device.
!		Delay increment of device refcount in UCB so that
!		it will not be left incorrectly biased on certain
!		error paths.
!
!	V03-009	CDS0002		Christian D. Saether	 3-Aug-1983
!		Remove reference to RVT$L_RVX (obsolete).
!
!	V03-008	TCM0001		Trudy C. Matthews	21-Jun-1983
!		Increment device refcount in UCB on mount.
!
!	V03-007	DMW4044		DMWalp			 7-Jun-1983
!		Remove (S)LOG_ENTRY
!
!	V03-006	STJ3095		Steven T. Jeffreys,	28-Apr-1983
!		Propagate ERASE and NOHIGHWATER throughout the volume set.
!
!	V03-005	STJ50311	Steven T. Jeffreys,	11-Feb-1983
!		Make all uses of PHYS_NAME indexed by DEVICE_INDEX.
!
!	V03-004	CDS0001		Christian D. Saether	 6-Jan-1983
!		Make test for xqp here and take out mount interlock lock
!		for duration of MOUNT_DISK2 if using xqp.
!		Temporarily disable write back caching and quota caching
!		when running with xqp, as well as rebuild until mount
!		can figure out if other mounters are present.
!
!	V03-003	LMP0036		L. Mark Pilant,		 6-Aug-1982  15:30
!		Add support for ACL's.
!
!	V03-002	STJ0301		Steven T. Jeffreys,	18-May-1982
!		Add support for /NOUNLOAD qualifier.
!
!	V03-001	STJ0243		Steven T. Jeffreys,	03-Apr-1982
!		- Use common I/O routines.
!		- Remove code that sets device allocation access mode.
!		  The device will be manually deallocated in VMOUNT.
!		- Ensure that we back out a 'dirty' SCB in case the
!		  specified ACP cannot be found.
!
!	V02-020	STJ0193		Steven T. Jeffreys,	02-Feb-1982
!		Rearrange storage so that different modules can share
!		the statically allocated buffers.
!
!	V02-019	STJ0179		Steven T. Jeffreys,	07-Jan-1982
!		Add support for the VCB$V_MOUNTVER bit.
!
!	V02-018	ACG0246		Andrew C. Goldstein,	4-Jan-1982  14:27
!		Add /OVER:LOCK support, add NOCACHE bit to VCB;
!		Remove primary exception handler code.
!
!	V02-017	ACG0230		Andrew C. Goldstein,	29-Dec-1981  19:21
!		Add file expiration support
!
!	V02-016	ACG0234		Andrew C. Goldstein,	4-Dec-1981  17:03
!		Limit index file EOF to allocated space
!
!	V02-015	STJ0045		Steven T. Jeffreys,	31-May-1981
!		Initialize a BLISS local variable to prevent a KERNEL mode
!		access violation in MAKE_DISK_MOUNT for /FOREIGN mounts.
!
!	V02-014	STJ0040		Steven T. Jeffreys,	21-May-1981
!		Copy volume serial number from homeblock to VCB.
!
!	V02-013	ACG35282	Andrew C. Goldstein,	23-Jan-1981  14:13
!		Clean up SCB after ACP startup failure
!
!	V02-012	ACG0169		Andrew C. Goldstein,	18-Apr-1980  13:48
!		Bug check on internal errors
!
!	V02-011	ACG0167		Andrew C. Goldstein,	18-Apr-1980  13:38
!		Previous revision history moved to MOUNT.REV
!**

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:MOUDEF.B32';


FORWARD ROUTINE
	MOUNT_DISK2	: NOVALUE,	! main disk mounting routine
	MOUNT_HANDLER,			! condition handler for main mount code
	MAKE_DISK_MOUNT,		! kernel mode mount routine
	SET_DATACHECK	: NOVALUE,	! set volume data check attributes
	KERNEL_HANDLER	: NOVALUE;	! kernel mode condition handler

!+
!
! Own storage for this module.
!
!-

LITERAL
	WINDOW_SIZE	= 30*6;		! maximum index file window size

GLOBAL
	!
	! Declare a one block buffer to be used by MOUDK1, MOUDK2, and BINDVL.
	! Previously, each module declared the buffer as OWN storage.  Since
	! the buffer is always written to before it is used, there is no need
	! to zero it before hand.
	!
	BUFFER		: BBLOCK [512],		! buffer for disk blocks
	!
	! Likewise, MOUDK1 and MOUDK2 make use of PROTO_VCB, PROTO_FCB,
	! PROTO_WCB and VOLUME_UIC.  In addition, MOUTAP also uses PROTO_VCB.
	! Each module is responsible for zeroing the blocks before using them.
	!
	PROTO_VCB	: BBLOCK [VCB$C_LENGTH], ! prototype VCB
	PROTO_FCB	: BBLOCK [FCB$C_LENGTH], ! prototype index file FCB
	PROTO_WCB	: BBLOCK [WCB$C_LENGTH+WINDOW_SIZE],
						! prototype index file window
	VOLUME_UIC	: LONG,			! owner UIC of volume
	CACHE_STATUS;				! status of block cache allocation


OWN
	IO_STATUS	: VECTOR [4, WORD];	! I/O status block.

GLOBAL ROUTINE MOUNT_DISK2 : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs all of the mechanics of mounting a structure
!	level 2 disk, given as input the parsed and partially validated
!	command line.
!
!
! CALLING SEQUENCE:
!	MOUNT_DISK ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MOUNT parser data base
!	CHANNEL: channel number for I/O
!	HOME_BLOCK: buffer containing volume home block
!	HOMEBLOCK_LBN: LBN of home block
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	volume mounted: VCB, etc., created, ACP started
!
!--

BEGIN

BUILTIN
	ROT,
	FFS,
	FFC,
	TESTBITSC;

LINKAGE
	L_MAP_POINTER	= JSB :
			GLOBAL (COUNT = 6, LBN = 7, MAP_POINTER = 8);

LABEL
	IDX_SCAN;			! index file bitmap scan loop

GLOBAL REGISTER
	COUNT		= 6,		! number of blocks in storage map
	LBN		= 7,		! current LBN in use
	MAP_POINTER	= 8 : REF BBLOCK; ! pointer to scan map pointers

LOCAL
	PROCESS_UIC,			! UIC of this process
	PRIVILEGE_MASK	: REF BBLOCK,	! address of process privilege mask
	P,				! random pointer
	C,				! string count
	STATUS		: BBLOCK [4],	! utility status word
	IDX_EOF,			! end of file on index file
	FREE,				! number of free blocks on volume
	X,				! longword of bitmap
	B1,				! start point of bit scan
	B2;				! end point of bit scan

EXTERNAL
	DEV_CTX		: BBLOCK FIELD (DC), ! device lock value block context
	VOL_CTX		: BBLOCK FIELD (VC), ! volume lock value block context
	VOLOCK_COUNT,			! count of volume locks
	STORED_CONTEXT	: BITVECTOR,	! XQP flag is used
	MOUNT_OPTIONS	: BITVECTOR,	! command option flags
	CLEANUP_FLAGS	: BITVECTOR,	! cleanup action flags
	DEVICE_CHAR	: BBLOCK,	! device characteristics
	USER_STATUS,			! status return from some routines
	LABEL_STRING	: VECTOR,	! volume label string in command
	DEVICE_INDEX	: VECTOR,	! index into PHYS_NAME vector
	PHYS_NAME	: VECTOR,	! descriptor of physical device name
	STRUCT_NAME	: VECTOR,	! descriptor of volume set name
	DRIVE_COUNT	: VECTOR,	! number of drives per device
	WINDOW,				! command specified window size
	ACCESSED,			! command specified LRU limit
	EXTENSION,			! command specified default file extend
	EXT_CACHE,			! size of extent cache to allocate
	FID_CACHE,			! size of file ID cache to allocate
	QUO_CACHE,			! size of quota file cache to allocate
	EXT_LIMIT,			! limit of volume space to cache
	HOME_BLOCK	: BBLOCK,	! buffer containing volume home block
	HOMEBLOCK_LBN,			! LBN of home block
	HEADER_LBN,			! LBN of current file header
	CURRENT_RVN,			! RVN of disk being mounted
	CURRENT_VCB	: REF BBLOCK,	! address of VCB being built
	CTL$GL_PHD	: REF BBLOCK ADDRESSING_MODE (ABSOLUTE),
					! vector page pointer to process header
	ACP$GW_EXTCACHE	: WORD ADDRESSING_MODE (ABSOLUTE),
					! default space for extent cache
	ACP$GW_FIDCACHE	: WORD ADDRESSING_MODE (ABSOLUTE),
					! default space for file ID cache
	ACP$GW_QUOCACHE	: WORD ADDRESSING_MODE (ABSOLUTE),
					! default space for quota file cache
	ACP$GW_EXTLIMIT	: WORD ADDRESSING_MODE (ABSOLUTE),
					! max space to keep in extent cache
	ACP$GB_WRITBACK	: BYTE ADDRESSING_MODE (ABSOLUTE),
					! ACP write-back cache enable flag
	ACP$GB_WINDOW	: BYTE ADDRESSING_MODE (ABSOLUTE),
					! default window size for /SYSTEM
	ACP$GW_SYSACC	: WORD	ADDRESSING_MODE (ABSOLUTE);
					! default LRU limit for /SYSTEM

EXTERNAL ROUTINE
	CHECK_CLUSTER_SANITY : NOVALUE,	! check cluster mount consistency
	GET_VOLUME_LOCK,		! take out volume lock
	GET_VOLUME_LOCK_NAME,		! generate volume lock name
	GET_UIC,			! get UIC of process
	CHECK_HEADER2,			! verify file header
	CHECKSUM,			! compute block checksum
	READ_BLOCK,			! read a block from the disk
	WRITE_BLOCK,			! write a block to the disk
	INIT_FCB2,			! initialize FCB
	TURN_WINDOW2,			! initialize window
	LEFT_ONE,			! leftmost one bit of value
	GET_MAP_POINTER	: L_MAP_POINTER, ! get value of file map pointer
	BIND_VOLUME;			! update volume set list


ENABLE MOUNT_HANDLER;

CURRENT_VCB = PROTO_VCB;		! pointer used by CHECK_HEADER2
CH$FILL (0, VCB$C_LENGTH, PROTO_VCB);	! init to zero
CACHE_STATUS = 1;			! init status of block cache allocation

! For maximum safety, we do as much setup work in user mode as possible. We
! read all of the disk blocks (index file and storage map headers and the
! storage map) in user mode so that the program is abortable in case something
! hangs. Prototype control blocks are built in local storage and are copied
! into the system pool by the kernel mode routine.
! Get the process UIC and the volume owner UIC. Make the privilege checks
! for overriding volume protection and options requiring operator privilege.
!

PROCESS_UIC = KERNEL_CALL (GET_UIC);
PRIVILEGE_MASK = CTL$GL_PHD[PHD$Q_PRIVMSK];
VOLUME_UIC = 0;
IF .MOUNT_OPTIONS[OPT_IS_FILES11]
THEN VOLUME_UIC = .HOME_BLOCK[HM2$L_VOLOWNER];

IF  (
    .MOUNT_OPTIONS[OPT_OVR_PRO]
    AND NOT (.PRIVILEGE_MASK[PRV$V_VOLPRO]
		OR .VOLUME_UIC EQL 0
		OR .VOLUME_UIC EQL .PROCESS_UIC)
    )

OR  (
    (  .MOUNT_OPTIONS[OPT_WINDOW]
    OR .MOUNT_OPTIONS[OPT_ACCESSED]
    OR .MOUNT_OPTIONS[OPT_UNIQUEACP]
    OR .MOUNT_OPTIONS[OPT_SAMEACP]
    OR .MOUNT_OPTIONS[OPT_FILEACP]
    OR .MOUNT_OPTIONS[OPT_CACHE]
    )
    AND NOT .PRIVILEGE_MASK[PRV$V_OPER]
    )

OR  (
    .MOUNT_OPTIONS[OPT_GROUP]
    AND NOT .PRIVILEGE_MASK [PRV$V_GRPNAM]
    )

OR  (
    .MOUNT_OPTIONS[OPT_SYSTEM]
    AND NOT .PRIVILEGE_MASK [PRV$V_SYSNAM]
    )

THEN ERR_EXIT (SS$_NOPRIV);

IF .MOUNT_OPTIONS[OPT_FOREIGN]
THEN VOLUME_UIC = .PROCESS_UIC;

! Unless the file= option was used to specify and acp for this
! volume always use the xqp.
!

IF NOT .MOUNT_OPTIONS [OPT_FILEACP]
THEN
    STORED_CONTEXT [XQP] = 1;

! Establish the volume set name, if any. It comes from the /BIND switch,
! or from the home block. If both, they must match.
!

IF .MOUNT_OPTIONS[OPT_BIND]
THEN
    BEGIN
    IF .HOME_BLOCK[HM2$W_RVN] NEQ 0
    THEN
	BEGIN
	IF CH$NEQ (.STRUCT_NAME[0], .STRUCT_NAME[1],
		   HM2$S_STRUCNAME, HOME_BLOCK[HM2$T_STRUCNAME], ' ')
	THEN ERR_EXIT (MOUN$_VOLINSET);
	END

    ELSE
	BEGIN
	CH$COPY (.STRUCT_NAME[0], .STRUCT_NAME[1], ' ',
		 HM2$S_STRUCNAME, HOME_BLOCK[HM2$T_STRUCNAME]);
	MOUNT_OPTIONS[OPT_DO_BIND] = 1;
	END;
    END

ELSE
    BEGIN
    IF .HOME_BLOCK[HM2$W_RVN] NEQ 0
    THEN
	BEGIN
	STRUCT_NAME[0] = HM2$S_STRUCNAME;
	STRUCT_NAME[1] = HOME_BLOCK[HM2$T_STRUCNAME];
	END;
    END;

! Default the cache parameters to the system defaults.
!

IF .EXT_CACHE EQL 0
THEN EXT_CACHE = .ACP$GW_EXTCACHE;
IF .MOUNT_OPTIONS[OPT_NOEXT_C]
THEN EXT_CACHE = 0;

IF .FID_CACHE EQL 0
THEN FID_CACHE = .ACP$GW_FIDCACHE;
IF .MOUNT_OPTIONS[OPT_NOFID_C]
OR .FID_CACHE EQL 0
THEN FID_CACHE = 1;

IF .QUO_CACHE EQL 0
THEN QUO_CACHE = .ACP$GW_QUOCACHE;
IF .MOUNT_OPTIONS[OPT_NOQUO_C]
THEN QUO_CACHE = 0;

IF .EXT_LIMIT EQL 0
THEN EXT_LIMIT = .ACP$GW_EXTLIMIT;

! First fill in the prototype VCB from the data in the home block.
!

PROTO_VCB[VCB$W_TRANS] = 1;		! transaction count
PROTO_VCB[VCB$W_MCOUNT] = 1;		! mount count

PROTO_VCB[VCB$V_ERASE] = .HOME_BLOCK[HM2$V_ERASE];
PROTO_VCB[VCB$V_NOHIGHWATER] = .HOME_BLOCK[HM2$V_NOHIGHWATER];

IF .MOUNT_OPTIONS[OPT_GROUP]
THEN PROTO_VCB[VCB$V_GROUP] = 1;
IF .MOUNT_OPTIONS[OPT_SYSTEM]
THEN PROTO_VCB[VCB$V_SYSTEM] = 1;

!
! Copy volume serial number from home block to VCB.
!
PROTO_VCB [VCB$L_SERIALNUM] = .HOME_BLOCK [HM2$L_SERIALNUM];

IF .MOUNT_OPTIONS[OPT_IS_FILES11]
AND NOT (.MOUNT_OPTIONS[OPT_FOREIGN] AND .MOUNT_OPTIONS[OPT_LABEL])
THEN
					! volume label, blank filled
    CH$MOVE (HM2$S_VOLNAME, HOME_BLOCK[HM2$T_VOLNAME], PROTO_VCB[VCB$T_VOLNAME])
ELSE
    CH$COPY (.LABEL_STRING[0], .LABEL_STRING[1], ' ',
	     VCB$S_VOLNAME, PROTO_VCB[VCB$T_VOLNAME]);

IF NOT .MOUNT_OPTIONS[OPT_FOREIGN]
THEN
    BEGIN
					! relative volume number
    IF .HOME_BLOCK[HM2$W_RVN] GEQU 256
    OR .HOME_BLOCK[HM2$W_SETCOUNT] GEQU 256
    THEN ERR_EXIT (SS$_FILESTRUCT);
    PROTO_VCB[VCB$W_RVN] = .HOME_BLOCK[HM2$W_RVN];
    CURRENT_RVN = .HOME_BLOCK[HM2$W_RVN];

    PROTO_VCB[VCB$L_HOMELBN] = .HOMEBLOCK_LBN; ! home block LBN
    PROTO_VCB[VCB$L_HOME2LBN] = .HOME_BLOCK[HM2$L_ALHOMELBN];

    IF .PROTO_VCB[VCB$L_HOMELBN] EQL .PROTO_VCB[VCB$L_HOME2LBN]
    THEN
	BEGIN
	PROTO_VCB[VCB$V_HOMBLKBAD] = 1;
	ERR_MESSAGE (MOUN$_HOMBLKBAD);
	END;

					! index file bitmap LBN
    PROTO_VCB[VCB$L_IBMAPLBN] = .HOME_BLOCK[HM2$L_IBMAPLBN];
    PROTO_VCB[VCB$L_IXHDR2LBN] = .HOME_BLOCK[HM2$L_ALTIDXLBN];
					! volume cluster factor
    PROTO_VCB[VCB$W_CLUSTER] = .HOME_BLOCK[HM2$W_CLUSTER];
					! device blocking factor
    PROTO_VCB[VCB$B_BLOCKFACT] = (.DEVICE_CHAR[DIB$B_SECTORS]
				* .DEVICE_CHAR[DIB$B_TRACKS]
				* .DEVICE_CHAR[DIB$W_CYLINDERS])
				/ .DEVICE_CHAR[DIB$L_MAXBLOCK];
					! default window size
    PROTO_VCB[VCB$B_WINDOW] = .HOME_BLOCK[HM2$B_WINDOW];
    IF .PROTO_VCB[VCB$B_WINDOW] EQL 0
    THEN PROTO_VCB[VCB$B_WINDOW] = 7;
    IF .MOUNT_OPTIONS[OPT_SYSTEM]
    THEN PROTO_VCB[VCB$B_WINDOW] = .ACP$GB_WINDOW;
    IF .MOUNT_OPTIONS[OPT_WINDOW]
    THEN PROTO_VCB[VCB$B_WINDOW] = .WINDOW;
					! directory LRU limit
    PROTO_VCB[VCB$B_LRU_LIM] = .HOME_BLOCK[HM2$B_LRU_LIM];
    IF .MOUNT_OPTIONS[OPT_SYSTEM]
    THEN PROTO_VCB[VCB$B_LRU_LIM] = .ACP$GW_SYSACC;
    IF .MOUNT_OPTIONS[OPT_ACCESSED]
    THEN PROTO_VCB[VCB$B_LRU_LIM] = .ACCESSED;
    IF .MOUNT_OPTIONS[OPT_NOCACHE]
	OR .STORED_CONTEXT [XQP]	!****TEMP****
    THEN PROTO_VCB[VCB$B_LRU_LIM] = 0;
					! default file extend
    PROTO_VCB[VCB$W_EXTEND] = .HOME_BLOCK[HM2$W_EXTEND];
    IF .PROTO_VCB[VCB$W_EXTEND] EQL 0
    THEN PROTO_VCB[VCB$W_EXTEND] = 5;
    IF .MOUNT_OPTIONS[OPT_EXTENSION]
    THEN PROTO_VCB[VCB$W_EXTEND] = .EXTENSION;
					! index file bitmap size
    PROTO_VCB[VCB$B_IBMAPSIZE] = .HOME_BLOCK[HM2$W_IBMAPSIZE];
    IF .HOME_BLOCK[HM2$W_IBMAPSIZE] GTRU 255
    THEN ERR_EXIT (SS$_FILESTRUCT);
					! maximum number of files
    PROTO_VCB[VCB$L_MAXFILES] = .HOME_BLOCK[HM2$L_MAXFILES];
    IF .HOME_BLOCK[HM2$L_MAXFILES] GTRU 255^12
    THEN ERR_EXIT (SS$_FILESTRUCT);
    PROTO_VCB[VCB$V_EXTFID] = 1;

    PROTO_VCB[VCB$B_RESFILES] = .HOME_BLOCK[HM2$W_RESFILES];
    IF .HOME_BLOCK[HM2$W_RESFILES] GTRU 255
    THEN ERR_EXIT (SS$_FILESTRUCT);

    IF .MOUNT_OPTIONS[OPT_WTHRU]
	OR .STORED_CONTEXT [XQP]	!****TEMP*****
    THEN PROTO_VCB[VCB$V_WRITETHRU] = 1;

    IF .MOUNT_OPTIONS[OPT_NOCACHE]
    THEN PROTO_VCB[VCB$V_NOCACHE] = 1;

! Quota file is always on RVN 1.
!

    IF .CURRENT_RVN LEQU 1
    THEN
	PROTO_VCB[VCB$W_QUOSIZE] = .QUO_CACHE
    ELSE
	QUO_CACHE = 0;

    CH$MOVE (HM2$S_RETAINMIN, HOME_BLOCK[HM2$Q_RETAINMIN], PROTO_VCB[VCB$Q_RETAINMIN]);
    CH$MOVE (HM2$S_RETAINMAX, HOME_BLOCK[HM2$Q_RETAINMAX], PROTO_VCB[VCB$Q_RETAINMAX]);

! Now read the index file header, verify it, and initialize the prototype
! index file FCB. If the primary header is no good, try for the secondary.
!

    HEADER_LBN = .PROTO_VCB[VCB$L_IBMAPLBN] + .PROTO_VCB[VCB$B_IBMAPSIZE];
    STATUS = READ_BLOCK (.HEADER_LBN, BUFFER);
    IF NOT .STATUS OR NOT CHECK_HEADER2 (BUFFER, UPLIT WORD (1, 1, 0))
    THEN
	BEGIN
	USER_STATUS = 1;
	PROTO_VCB[VCB$V_IDXHDRBAD] = 1;
	PROTO_VCB[VCB$V_NOALLOC] = 1;
	ERR_MESSAGE (MOUN$_IDXHDRBAD);
	HEADER_LBN = .PROTO_VCB[VCB$L_IXHDR2LBN];
	STATUS = READ_BLOCK (.HEADER_LBN, BUFFER);
	END;
    IF NOT .STATUS THEN ERR_EXIT (.STATUS);
    IF NOT CHECK_HEADER2 (BUFFER, UPLIT WORD (1, 1, 0)) 
    THEN 
	ERR_EXIT (SS$_NOHOMEBLK);

    CH$FILL (0, FCB$C_LENGTH, PROTO_FCB);
    PROTO_FCB[FCB$L_STVBN] = 1;
    INIT_FCB2 (PROTO_FCB, BUFFER);
    PROTO_FCB[FCB$W_ACNT] = 1;
    PROTO_FCB[FCB$W_REFCNT] = 1;

! Build the prototype index file window.
!

    CH$FILL (0, WCB$C_LENGTH, PROTO_WCB);
    PROTO_WCB[WCB$W_SIZE] = WCB$C_LENGTH + WINDOW_SIZE;
    PROTO_WCB[WCB$V_READ] = 1;
    TURN_WINDOW2 (PROTO_WCB, BUFFER, 3, 1, .PROTO_VCB[VCB$W_RVN]);

! Now read the storage map file header and find the starting LBN of the
! storage map. Note that the storage map size is computed from the volume
! size and cluster factor, since the storage map file is rounded up to the
! next cluster boundary.
!

    STATUS = READ_BLOCK (.PROTO_VCB[VCB$L_IBMAPLBN] + .PROTO_VCB[VCB$B_IBMAPSIZE] + 1, BUFFER);
    IF NOT .STATUS OR NOT CHECK_HEADER2 (BUFFER, UPLIT WORD (2, 2, 0))
    THEN
	BEGIN

! The shared file system cannot tolerate failure to read the storage
! control block, because that is where the volume label used for
! locking is stored.
!
! If NOALLOC could be believed clusterwide such that we were guaranteed
! it was safe to proceed without doing any locking, failure to get
! SCB$T_VOLOCKNAME could be tolerated.  However, being able to issue
! an unlock control function makes that difficult.
!

	IF .STORED_CONTEXT [XQP]
	THEN
	    IF .STATUS EQL SS$_VOLINV
	    THEN
		ERR_EXIT (SS$_VOLINV)
	    ELSE
	        ERR_EXIT (MOUN$_MAPHDRBAD);

	ERR_MESSAGE (MOUN$_MAPHDRBAD);
	PROTO_VCB[VCB$V_NOALLOC] = 1;
	END

    ELSE
	BEGIN
	MAP_POINTER = BUFFER + .BUFFER[FH2$B_MPOFFSET]*2;
	GET_MAP_POINTER ();
	COUNT = ((.DEVICE_CHAR[DIB$L_MAXBLOCK] + .PROTO_VCB[VCB$W_CLUSTER] - 1)
	  	/ .PROTO_VCB[VCB$W_CLUSTER] + 4095) / 4096;
	IF .COUNT GTRU 255
	THEN ERR_EXIT (SS$_FILESTRUCT);

	PROTO_VCB[VCB$L_SBMAPLBN] = .LBN + 1;
	PROTO_VCB[VCB$B_SBMAPSIZE] = .COUNT;

! Now read the storage control block and check the various dirty bits, and
! issue messages if the volume was not properly dismounted. Then set the
! appropriate bits and rewrite the storage control block. If the write fails,
! write-lock the volume.
!

	STATUS = READ_BLOCK (.LBN, BUFFER);
	IF NOT .STATUS
	THEN

! See comment above on failure to read sbm header.
!
	    IF .STATUS EQL SS$_VOLINV
	    THEN
		ERR_EXIT (SS$_VOLINV)
	    ELSE
	        ERR_EXIT (MOUN$_BITMAPERR, 0, .STATUS);

	IF .BUFFER[SCB$V_MAPDIRTY]
	THEN
	    BEGIN
	    ERR_MESSAGE (MOUN$_BITMAPINV);
	    PROTO_VCB[VCB$V_NOALLOC] = 1;
	    END;

! Get volume lock and establish volume lock name.
!

	GET_VOLUME_LOCK_NAME ();

	VOLOCK_COUNT = 0;

	IF .STORED_CONTEXT [XQP]
	THEN
	    BEGIN
	    IF NOT (STATUS = KERNEL_CALL (GET_VOLUME_LOCK))
	    THEN
		ERR_EXIT (.STATUS);

	    VOLOCK_COUNT = .VOLOCK_COUNT - 1;		! Don't count ourself.

	    IF .DEV_CTX [DC_NOTFIRST_MNT] NEQ .VOL_CTX [VC_NOTFIRST_MNT]
	    THEN
		ERR_EXIT (MOUN$_VOLALRMNT);

	    END;

	CH$MOVE (8, BUFFER [SCB$Q_MOUNTTIME], PROTO_VCB [VCB$Q_MOUNTTIME]);

	IF NOT .PROTO_VCB[VCB$V_NOALLOC]
	AND .MOUNT_OPTIONS[OPT_WRITE]
	THEN
	    BEGIN

	    IF NOT .DEV_CTX [DC_NOTFIRST_MNT]	! i.e., first
	    THEN
		BEGIN
		CH$MOVE (12, PROTO_VCB [VCB$T_VOLCKNAM], BUFFER [SCB$T_VOLOCKNAME]);
		$GETTIM (TIMADR = BUFFER [SCB$Q_MOUNTTIME]);
		END;

	    IF .BUFFER [SCB$W_WRITECNT] NEQ .VOLOCK_COUNT
	    THEN

! If the count of volume locks does not match the count in the
! storage control block, someone that once mounted this volume
! did not dismount it.
!
! Set the count straight now, but also note in status2 which caches
! need rebuilding by ORing the STATUS flags into it.
! The STATUS2 flags are only cleared upon successful completion
! of a rebuild, so we will continue to attempt a rebuild until
! the volume is actually rebuilt.
!

		BEGIN
		BUFFER [SCB$L_STATUS2] = .BUFFER [SCB$L_STATUS2]
					OR .BUFFER [SCB$L_STATUS];
		BUFFER [SCB$W_WRITECNT] = .VOLOCK_COUNT;
		END;

	    IF .BUFFER [SCB$V_MAPALLOC2] OR .BUFFER [SCB$V_FILALLOC2]
	    THEN
		CLEANUP_FLAGS [CLF_REBUILD] = 1;

	    IF .BUFFER [SCB$V_QUODIRTY2]
		AND .CURRENT_RVN LEQU 1
	    THEN
		BEGIN
		IF NOT .MOUNT_OPTIONS [OPT_NOQUOTA]
		THEN
		    CLEANUP_FLAGS [CLF_REBUILDQUO] = 1;
		END
	    ELSE
		BUFFER [SCB$V_QUODIRTY2] = 0;

	    BUFFER [SCB$W_WRITECNT] = .BUFFER [SCB$W_WRITECNT] + 1;

! Note which caches we are enabling by setting the corresponding flag
! in the SCB.  These may already be set if
! the disk has been mounted elsewhere in the cluster with the
! same cache enabled.
!

	    IF .EXT_CACHE NEQ 0
	    THEN
		BUFFER [SCB$V_MAPALLOC] = 1;

	    IF .FID_CACHE NEQ 1		! 1 is no caching
	    THEN
		BUFFER [SCB$V_FILALLOC] = 1;

! Note that we don't know yet whether quotas will be enabled until
! we actually try to turn them on in MAKE_DISK_MOUNT.  So far all
! we know is that we intend to turn them on if a quota.sys file is
! really there.
!

	    IF (.QUO_CACHE NEQ 0 AND .CURRENT_RVN LEQU 1)
		AND NOT .MOUNT_OPTIONS [OPT_NOQUOTA]
	    THEN
		BUFFER [SCB$V_QUODIRTY] = 1;

! NOTE:  This read/write of the SCB is using the volume lock to
! serialize with the DISMOUNT subfunction (ACPCONTROL qio) which
! lowers the writecnt.  It does NOT correctly serialize with the
! REBUILD routine which only holds the volume blocking lock (LOCK_VOLUME).
! MOUNT does not respect the blocking lock because there isn't enough
! state yet to do it (volume sets are the problem).
! The correct solution here is probably to not rewrite the SCB at all
! in this leg of code (in mount), but rather have the file system do
! is as part of the MOUNT function QIO issued from START_ACP (called
! from the MAKE_DISK_MOUNT routine).  It can then respect the volume
! blocking lock (LOCK_VOL function) and interlock correctly with
! the bitmap rebuild, which does need to rewrite it.  The LOCK_VOL function
! should also make the lock count vs writecnt test and OR the STATUS flags
! into the STATUS2 flags if the counts mismatch, and rewrite the SCB
! (in an interlocked fashion) for the bitmap rebuilder to look at and
! correctly determine whether a rebuild is really necessary when it
! actually executes.
! This still leaves the problem of what block can mount read and attempt
! to write back to determine whether the volume is write-locked or not.
! All storage bitmap and index file bitmap blocks are really off limits
! because they are read and written by the bitmap rebuilder under the
! volume blocking lock (LOCK_VOL).  The home block, maybe?
!

	    CHECKSUM (BUFFER);
	    STATUS = WRITE_BLOCK (.LBN, BUFFER);

! Bump storage bitmap sequence number in the volume lock value block
! to invalidate potential copies in file system caches elsewhere.
!

	    VOL_CTX [VC_SBMSEQNUM] = .VOL_CTX [VC_SBMSEQNUM] + 1;

	    IF .STATUS
	    THEN
		CH$MOVE (8, BUFFER [SCB$Q_MOUNTTIME], 
						PROTO_VCB [VCB$Q_MOUNTTIME])
	    ELSE
		BEGIN
	        IF .STATUS EQL SS$_VOLINV
	        THEN
		    ERR_EXIT (SS$_VOLINV);
		IF .STATUS EQL SS$_WRITLCK
		THEN ERR_MESSAGE (MOUN$_WRITELOCK)
		ELSE ERR_MESSAGE (MOUN$_WRITESCB, 0, .STATUS);
		MOUNT_OPTIONS[OPT_WRITE] = 0;
		END;

	    CLEANUP_FLAGS[CLF_CLEANSCB] = 1;

	    END;


! If this is not the first mount for this device, make sure
! essential mount parameters are consistent with other mounts
! elsewhere.
! For either the first mount of a cluster available device, or
! for mounts of local disks, the routine is not called.
!

	IF .DEV_CTX [DC_NOTFIRST_MNT]
	THEN
	    CHECK_CLUSTER_SANITY();


! Scan the index file bitmap from the end backwards looking for the highest
! file number. Compute its index file VBN and check against the index file
! EOF. If the EOF is short, set the EOF delta high so that the first create
! will update the index file header.
! If this is not the initial mount of the volume, simply copy the index
! file eof from the value block.
!

	IF .VOL_CTX [VC_NOTFIRST_MNT]
	THEN
	    PROTO_FCB [FCB$L_EFBLK] = .VOL_CTX [VC_IDXFILEOF]
	ELSE
	IDX_SCAN:
	    BEGIN
	    DECR J FROM .PROTO_VCB[VCB$B_IBMAPSIZE] - 1 TO 0
	    DO
		BEGIN
		MAP BUFFER : VECTOR;
		STATUS = READ_BLOCK (.PROTO_VCB[VCB$L_IBMAPLBN] + .J, BUFFER);
		IF NOT .STATUS
		THEN
		    BEGIN
		    IF .STATUS EQL SS$_VOLINV
		    THEN
			ERR_EXIT (SS$_VOLINV)
		    ELSE
		        ERR_MESSAGE (MOUN$_IDXMAPERR, 0, .STATUS);
		    PROTO_VCB[VCB$V_NOALLOC] = 1;
		    IDX_EOF = 0;
		    LEAVE IDX_SCAN;
		    END;

		DECR I FROM 127 TO 0
		DO
		    BEGIN
		    IF .BUFFER[.I] NEQ 0
		    THEN
			BEGIN
			IDX_EOF = .J*4096 + .I*32 + LEFT_ONE (.BUFFER[.I])
			    + .PROTO_VCB[VCB$B_IBMAPSIZE] + .PROTO_VCB[VCB$W_CLUSTER]*4;
			LEAVE IDX_SCAN;
			END;
		    END;
		END;
	    END;			! end of block IDX_SCAN

	IDX_EOF = MINU (.IDX_EOF, .PROTO_FCB[FCB$L_FILESIZE]);
	IF .IDX_EOF GTRU .PROTO_FCB[FCB$L_EFBLK]
	THEN
	    BEGIN
	    PROTO_FCB[FCB$L_EFBLK] = .IDX_EOF;
	    PROTO_VCB[VCB$B_EOFDELTA] = 250;
	    END;

	VOL_CTX [VC_IDXFILEOF] = .PROTO_FCB [FCB$L_EFBLK];

! Scan the storage map to compute the number of free blocks on the volume.
!

	IF .VOL_CTX [VC_NOTFIRST_MNT]
	THEN
	    PROTO_VCB [VCB$L_FREE] = .VOL_CTX [VC_VOLFREE]
	ELSE
	    BEGIN

	    FREE = 0;
	    DECR J FROM .COUNT TO 1 DO
		BEGIN
		MAP BUFFER : VECTOR;

		LBN = .LBN + 1;
		STATUS = READ_BLOCK (.LBN, BUFFER);
		IF NOT .STATUS
		THEN
		    BEGIN
		    IF .STATUS EQL SS$_VOLINV
		    THEN
			ERR_EXIT (SS$_VOLINV)
		    ELSE
		        ERR_MESSAGE (MOUN$_BITMAPERR, 0, .STATUS);
		    PROTO_VCB[VCB$V_NOALLOC] = 1;
		    END;

		INCR I FROM 0 TO 127 DO
		    BEGIN
		    X = .BUFFER[.I];
		    IF .X NEQ 0
		    THEN
			BEGIN
			B2 = 0;
			WHILE 1 DO
			    BEGIN
			    IF FFS (B2, %REF (32-.B2), X, B1)
			    THEN EXITLOOP;
			    FFC (B1, %REF (32-.B1), X, B2);
			    FREE = .FREE + .B2 - .B1;
			    IF .B2 GEQ 32 THEN EXITLOOP;
			    END;
			END;
		    END;
		END;

	    PROTO_VCB[VCB$L_FREE] = .FREE * .PROTO_VCB[VCB$W_CLUSTER];
	    VOL_CTX [VC_VOLFREE] = .PROTO_VCB [VCB$L_FREE];
	    END;

	END;				! end of storage bitmap hdr read success

    END					! end of Files-11 specific mount processing
ELSE
    BEGIN

! This is a foreign mount. If this is a shared foreign mount, 
! take out the volume lock.
!
! If this is not the first mount for this device, make sure
! essential mount parameters are consistent with other mounts
! elsewhere.
! For either the first mount of a cluster available device, or
! for mounts of local disks, the routine is not called.
!

    IF NOT .MOUNT_OPTIONS [OPT_NOSHARE]
    THEN
	BEGIN
	GET_VOLUME_LOCK_NAME ();
	IF NOT (STATUS = KERNEL_CALL (GET_VOLUME_LOCK))
	THEN
	    ERR_EXIT (.STATUS);
	IF .DEV_CTX [DC_NOTFIRST_MNT] NEQ .VOL_CTX [VC_NOTFIRST_MNT]
	THEN
	    ERR_EXIT (MOUN$_VOLALRMNT);
	END;

    IF .DEV_CTX [DC_NOTFIRST_MNT]
    THEN
	CHECK_CLUSTER_SANITY();

    END;				! end of foreign-specific mount processing


! Finally call the kernel mode routine to make it all real. Note that all the
! hookups, including generating the mounted volume list entry, are done
! within one kernel mode call so that they are uninterruptible by the user.
!

IF .MOUNT_OPTIONS[OPT_OVR_LOCK]
THEN PROTO_VCB[VCB$V_NOALLOC] = 0;

STATUS = KERNEL_CALL (MAKE_DISK_MOUNT);
IF NOT .STATUS
THEN
    BEGIN
    IF .STATUS[STS$V_SEVERITY] EQL STS$K_SEVERE
    THEN ERR_EXIT (.STATUS)
    ELSE
	BEGIN
	IF .IO_STATUS
	THEN ERR_MESSAGE (.STATUS)
	ELSE ERR_MESSAGE (.STATUS, 0, .IO_STATUS<0,16>);
	END;
    END;

! If this volume is being bound into a volume set, now do the on-disk
! modifications.
!

CLEANUP_FLAGS[CLF_DISMOUNT] = 1;	! cleanup from here requires a full dismount

IF TESTBITSC (MOUNT_OPTIONS[OPT_DO_BIND])
THEN BIND_VOLUME ();

! Announce that the volume is mounted.
!

ERR_MESSAGE (MOUN$_MOUNTED, 3, VCB$S_VOLNAME, PROTO_VCB[VCB$T_VOLNAME], PHYS_NAME[.DEVICE_INDEX*2]);

!
! If a FILES-11 volume is mounted with a reduced block cache, output the 
! appropriate informational message.
!

IF  ( NOT .CACHE_STATUS )
AND ( NOT .MOUNT_OPTIONS [OPT_FOREIGN] )
THEN
    ERR_MESSAGE (MOUN$_REDCACHE);

! Earlier in this routine, the CLF_REBUILD flag was set if either of
! the bitmaps (storage and file number) needs rebuilding.  CLF_REBUILDQUO
! was set if the quota file needs rebuilding and quota are in fact
! enabled.  Check if anything needs rebuilding and, if so, whether
! it should be done now.
!

IF .CLEANUP_FLAGS [CLF_REBUILD] OR .CLEANUP_FLAGS [CLF_REBUILDQUO]
THEN
    IF .MOUNT_OPTIONS [OPT_NOREBUILD]
    THEN
	BEGIN
	ERR_MESSAGE (MOUN$_REBLDREQD);
	CLEANUP_FLAGS [CLF_REBUILD] = 0;
	CLEANUP_FLAGS [CLF_REBUILDQUO] = 0;
	END
    ELSE
	IF .CLEANUP_FLAGS [CLF_REBUILDQUO]
	THEN
	    CLEANUP_FLAGS [CLF_REBUILD] = 1;

END;					! end of routine MOUNT_DISK2

ROUTINE MOUNT_HANDLER (SIGNAL, MECHANISM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the condition handler for the main disk mount
!	code. It undoes any damage done so far and returns the error
!	status to the user mode caller.
!
!
! CALLING SEQUENCE:
!	MOUNT_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal vector
!	ARG2: address of mechanism vector
!
! IMPLICIT INPUTS:
!	global pointers to blocks allocated
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_RESIGNAL
!
! SIDE EFFECTS:
!	necessary cleanups done
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal vector
	MECHANISM	: REF BBLOCK;	! mechanism vector

EXTERNAL
	MOUNT_OPTIONS	: BITVECTOR,	! command parser options
	CLEANUP_FLAGS	: BITVECTOR;	! cleanup action flags

EXTERNAL ROUTINE
	CHECKSUM,			! compute block checksum
	LOCK_CLEANUP : NOVALUE,		! cleanup dev and vol locks.
	READ_BLOCK,			! read a disk block
	WRITE_BLOCK;			! write a disk block


! Note that cleanup is done if we are unwinding, which occurrs when
! we take an error exit.
!

IF  (.SIGNAL[CHF$L_SIG_NAME] NEQ SS$_UNWIND)
AND ((.BBLOCK [SIGNAL [CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_SEVERE) OR
     (.BBLOCK [SIGNAL [CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_ERROR))
THEN
    BEGIN

! Clear the dirty bits in the storage control block if they were set.
!

    IF .CLEANUP_FLAGS[CLF_CLEANSCB] AND .MOUNT_OPTIONS[OPT_WRITE]
    THEN
	BEGIN
	IF READ_BLOCK (.PROTO_VCB[VCB$L_SBMAPLBN]-1, BUFFER)
	THEN
	    IF BUFFER [SCB$W_WRITECNT] NEQ 0
	    THEN
		BEGIN
		IF (BUFFER [SCB$W_WRITECNT] = .BUFFER [SCB$W_WRITECNT] - 1)
		    EQL 0
		THEN
		    BUFFER [SCB$L_STATUS] = 0;

		CHECKSUM (BUFFER);
		WRITE_BLOCK (.PROTO_VCB[VCB$L_SBMAPLBN]-1, BUFFER);
		END;
	END;

    LOCK_CLEANUP ();

    END;

SS$_RESIGNAL
END;					! end of routine MOUNT_HANDLER

ROUTINE MAKE_DISK_MOUNT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine does all of the data base manipulation needed to get
!	a volume actually mounted. It allocates the real VCB, FCB, and
!	window, and hooks then all together. It also starts up the ACP
!	gets the mounted volume list entry made.
!
!
! CALLING SEQUENCE:
!	MAKE_DISK_MOUNT ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MOUNT parser data base
!	own storage of this module
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1 if successful
!	status values if not
!
! SIDE EFFECTS:
!	volume mounted
!
!--

BEGIN

BUILTIN
	INSQUE;

LOCAL
	WINDOW_SIZE,			! size in bytes needed for window
	UCB		: REF BBLOCK,	! pointer to volume UCB
	ORB		: REF BBLOCK,	! Pointer to device ORB
	VCB		: REF BBLOCK,	! pointer to volume VCB
	RVT		: REF BBLOCK,	! pointer to volume set RVT
	SYS_STATUS,			! system service status
	STATUS,				! general status value
	NOWRITE,			! state of volume set write lock
	ERASE,				! state of volume erase-on-delete
	NOHIGHWATER,			! state of volume file-highwater-marking
	MOUNTVER,			! state of volume set mount verification
	LOCKED;				! state of volume set allocation lock

EXTERNAL
	DEV_CTX		: BBLOCK FIELD (DC), ! device context
	VLSETLCK_CTX	: BBLOCK FIELD (VC), ! volume set lock context
	VOL_CTX		: BBLOCK FIELD (VC), ! volume lock context
	MOUNT_OPTIONS	: BITVECTOR,	! command parser options
	STORED_CONTEXT	: BITVECTOR,	! looks at xqp flag
	CLEANUP_FLAGS	: BITVECTOR,	! cleanup action flags
	DEVICE_COUNT,			! number of devices specified
	CHANNEL,			! channel assigned to device
	STRUCT_NAME	: VECTOR,	! descriptor of volume set name
	HOME_BLOCK	: BBLOCK,	! buffer containing home block
	OWNER_UIC,			! owner UIC from command
	PROTECTION,			! volume protection from command
	EXT_CACHE,			! size of extent cache to allocate
	FID_CACHE,			! size of file ID cache to allocate
	QUO_CACHE,			! size of quota file cache to allocate
	EXT_LIMIT,			! limit of volume space to cache
	CURRENT_RVN,			! RVN of disk being mounted
	REAL_VCB	: REF BBLOCK,	! address of VCB allocated
	REAL_VCA	: REF BBLOCK,	! address of volume cache allocated
	REAL_FCB	: REF BBLOCK,	! address of FCB allocated
	REAL_WCB	: REF BBLOCK,	! address of window allocated
	MTL_ENTRY	: REF BBLOCK,	! address of mount list entry
	SMTL_ENTRY	: REF BBLOCK,	! address of mount list entry for volume set
	CTL$GL_VOLUMES	: ADDRESSING_MODE (ABSOLUTE);
					! count of volumes mounted by process

EXTERNAL ROUTINE
	GET_VOLSET_LOCK,		! get cluster lock for volume set.
	STORE_CONTEXT,			! write appropriate value blocks.
	GET_CHANNELUCB,			! get UCB assigned to channel
	ALLOCATE_MEM,			! allocate system dynamic memory
	START_ACP,			! start and connect ACP to device
	LOCK_IODB	: ADDRESSING_MODE (GENERAL), ! lock I/O database mutex
	UNLOCK_IODB	: ADDRESSING_MODE (GENERAL), ! unlock I/O database mutex
	ENTER_RVT,			! attach to relative volume table
	ALLOC_LOGNAME,			! create logical name and MTL blocks
	ENTER_LOGNAME,			! enter logical name and MTL in lists
	SEND_ERRLOG;			! send message to error logger


! Allocate all of the required control blocks. We allocate them in
! advance to avoid having to back out of some awkward situations later on.
! The one exception is the AQB, which is either found or allocated by
! START_ACP.
!

ENABLE KERNEL_HANDLER;

REAL_VCB = ALLOCATE_MEM (VCB$C_LENGTH, 0);
REAL_VCB[VCB$B_TYPE] = DYN$C_VCB;
CH$MOVE (VCB$C_LENGTH-11, PROTO_VCB+11, .REAL_VCB+11);
UCB = GET_CHANNELUCB (.CHANNEL);
ORB = .UCB[UCB$L_ORB];
RVT = 0;

IF NOT .MOUNT_OPTIONS[OPT_FOREIGN]
THEN
    BEGIN
    LOCAL	FCB_ORB	: REF BBLOCK;

    REAL_VCB[VCB$L_FCBFL] = REAL_VCB[VCB$L_FCBFL];
    REAL_VCB[VCB$L_FCBBL] = REAL_VCB[VCB$L_FCBFL];

    REAL_FCB = ALLOCATE_MEM (FCB$C_LENGTH, 0);
    REAL_FCB[FCB$B_TYPE] = DYN$C_FCB;
    CH$MOVE (FCB$C_LENGTH-11, PROTO_FCB+11, .REAL_FCB+11);
    REAL_FCB[FCB$L_WLFL] = REAL_FCB[FCB$L_WLFL];
    REAL_FCB[FCB$L_WLBL] = REAL_FCB[FCB$L_WLFL];

    FCB_ORB = REAL_FCB[FCB$R_ORB];
    FCB_ORB[ORB$V_ACL_QUEUE] = 0;
    FCB_ORB[ORB$L_ACL_COUNT] = 0;
    FCB_ORB[ORB$L_ACL_DESC] = 0;
    INSQUE (.REAL_FCB, REAL_VCB[VCB$L_FCBFL]);

    WINDOW_SIZE = WCB$C_LENGTH + MAXU (.PROTO_WCB[WCB$W_NMAP] + 2, 6) * 6;
    REAL_WCB = ALLOCATE_MEM (.WINDOW_SIZE, 0);
    REAL_WCB[WCB$B_TYPE] = DYN$C_WCB;
    CH$MOVE (.WINDOW_SIZE-11, PROTO_WCB+11, .REAL_WCB+11);
    REAL_WCB[WCB$L_FCB] = .REAL_FCB;
    INSQUE (.REAL_WCB, REAL_FCB[FCB$L_WLFL]);

! Allocate the cache block for the volume, computing the size from the cache
! parameters.
!

    REAL_VCA = ALLOCATE_MEM (VCA$C_LENGTH
			     + $BYTEOFFSET (VCA$L_FIDLIST) + .FID_CACHE * 4
			     + $BYTEOFFSET (VCA$Q_EXTLIST) + .EXT_CACHE * 8,
			     0);
    REAL_VCB[VCB$L_CACHE] = .REAL_VCA;
    REAL_VCA[VCA$B_TYPE] = DYN$C_VCA;
    REAL_VCA[VCA$L_FIDCACHE] = .REAL_VCA + VCA$C_LENGTH;
    REAL_VCA[VCA$L_EXTCACHE] = .REAL_VCA + VCA$C_LENGTH
			     + $BYTEOFFSET (VCA$L_FIDLIST) + .FID_CACHE * 4;
    BBLOCK [.REAL_VCA[VCA$L_FIDCACHE], VCA$W_FIDSIZE] = .FID_CACHE;
    BBLOCK [.REAL_VCA[VCA$L_EXTCACHE], VCA$W_EXTSIZE] = .EXT_CACHE;
    BBLOCK [.REAL_VCA[VCA$L_EXTCACHE], VCA$W_EXTLIMIT] = .EXT_LIMIT;
    BBLOCK [BBLOCK [.REAL_VCA[VCA$L_FIDCACHE], VCA$B_FIDCACB], ACB$B_RMOD] =
	PSL$C_KERNEL + ACB$M_NODELETE;
    BBLOCK [BBLOCK [.REAL_VCA[VCA$L_EXTCACHE], VCA$B_EXTCACB], ACB$B_RMOD] =
	PSL$C_KERNEL + ACB$M_NODELETE;
    REAL_VCB[VCB$W_QUOSIZE] = .QUO_CACHE;

! If this volume is part of a volume set, attach it to the RVT for the set,
! creating one if it doesn't exist.
!

    REAL_VCB[VCB$L_RVT] = .UCB;

    IF .HOME_BLOCK[HM2$W_RVN] NEQ 0 OR .MOUNT_OPTIONS[OPT_BIND]
    THEN
	BEGIN
	RVT = ENTER_RVT (STRUCT_NAME[0], .UCB);
	REAL_VCB[VCB$L_RVT] = .RVT;
	REAL_WCB[WCB$L_RVT] = .RVT;
	CURRENT_RVN = .HOME_BLOCK[HM2$W_RVN];
	REAL_FCB[FCB$W_FID_RVN] = .HOME_BLOCK[HM2$W_RVN];
	(REAL_FCB[FCB$L_LOCKBASIS])<24,8> = .REAL_FCB[FCB$B_FID_RVN];
	REAL_VCB[VCB$W_RVN] = .HOME_BLOCK[HM2$W_RVN];

! Take out the volume set lock.  Also check for cluster uniqueness
! of the volume set structure name.  Note that this
! test is based on whether or not this is (or is not) the first instance
! of this device being mounted and the lock for the volume set being created.
! A given volume set must always be mounted in the same order on
! different nodes in the cluster.  If, for example, RVN 2 was mounted
! first on node A, then if node B mounts RVN 1 next, it will fail because
! the volume set lock already exists, even though it is the first mount
! on the RVN 1 device.
!

	IF .RVT [RVT$L_STRUCLKID] EQL 0
	THEN
	    BEGIN
 	    GET_VOLSET_LOCK();

	    IF .STORED_CONTEXT [XQP]
	    THEN
		IF .DEV_CTX [DC_NOTFIRST_MNT] NEQ .VLSETLCK_CTX [VC_NOTFIRST_MNT]
		THEN
		    ERR_EXIT (MOUN$_VOLINSET);
	    END;

	END;
    END;

! Now allocate space for logical name and mounted volume list entries.
! If this is volume 1 of a set, we allocate 2 - one for the volume as usual
! and one for the set. If a logical name is given in the command, it is assigned
! to volume 1 of the set, or if only one volume is being mounted, to it.
! Otherwise, the logical name is constructed from the volume label.
!

IF NOT .MOUNT_OPTIONS[OPT_FOREIGN] AND .HOME_BLOCK[HM2$W_RVN] EQL 1
THEN
    BEGIN
    ALLOC_LOGNAME (0);
    SMTL_ENTRY = .MTL_ENTRY;		! copy reserved entry to entry for set
    MTL_ENTRY = 0;
    ALLOC_LOGNAME (1);
    END

ELSE
    BEGIN
    IF .DEVICE_COUNT EQL 1
    THEN ALLOC_LOGNAME (0)
    ELSE ALLOC_LOGNAME (1);
    END;

! All data blocks except the AQB are now allocated. First set up the
! volume ownership and protection in the VCB. Now hook up the blocks
! to the device data base and start the ACP.
!

UCB[UCB$V_UNLOAD] = NOT .MOUNT_OPTIONS [OPT_NOUNLOAD];
ORB[ORB$L_OWNER] = .VOLUME_UIC;
IF .MOUNT_OPTIONS[OPT_OWNER_UIC]
THEN ORB[ORB$L_OWNER] = .OWNER_UIC;

ORB[ORB$V_PROT_16] = 1;				! SOGW protection word
IF .MOUNT_OPTIONS[OPT_FOREIGN]
THEN ORB[ORB$W_PROT] = %X'FF00'
ELSE ORB[ORB$W_PROT] = .HOME_BLOCK[HM2$W_PROTECT];
IF .MOUNT_OPTIONS[OPT_PROTECTION]
THEN ORB[ORB$W_PROT] = .PROTECTION;

STATUS = 1;
IF NOT .MOUNT_OPTIONS[OPT_FOREIGN]
THEN
    BEGIN
    REAL_VCB [VCB$V_MOUNTVER] = .MOUNT_OPTIONS [OPT_MOUNTVER];
    REAL_WCB[WCB$L_ORGUCB] = .UCB;
    START_ACP (.UCB, .REAL_VCB, AQB$K_F11V2);

! Store value blocks of device and volume locks, as appropriate.
!

    STORE_CONTEXT ();

! Unless the disk is being mounted /NOQUOTA or is write locked, attempt
! to connect the quota file if the RVN is 0 or 1. If it fails with no such
! file, then proceed; else lock the volume.
!

    IF NOT .MOUNT_OPTIONS[OPT_NOQUOTA]
    AND .REAL_VCB[VCB$W_RVN] LEQU 1
    AND NOT .REAL_VCB[VCB$V_NOALLOC]
    AND .MOUNT_OPTIONS[OPT_WRITE]
    THEN
	BEGIN
	PSECT	PLIT = $OWN$;		! ACP argument blocks must be writable

	SYS_STATUS = DO_IO (
		EFN  = MOUNT_EFN,
		CHAN = .CHANNEL,
		FUNC = IO$_ACPCONTROL,
		IOSB = IO_STATUS[0],
		P1   = UPLIT (FIB$C_MTALEN,
			      UPLIT (0, WORD (0, 0, 0), WORD (4, 4, 0), 0,
				     WORD (0, FIB$C_ENA_QUOTA), 0)),
		P2   = DESCRIPTOR ('QUOTA.SYS;1')
		);
	IF NOT .SYS_STATUS THEN IO_STATUS = .SYS_STATUS;

	IF NOT .IO_STATUS[0]
	THEN
	    BEGIN

! CLF_REBUILDQUO was set in MOUNT_DISK2 if the QUODIRTY2 flag was
! set in the SCB, indicating that the disk was improperly dismounted
! sometime in the past when quota caching was enabled.  However, if
! we failed to enable quotas here for whatever reason (normally just
! failure to find a quota file), clear the flag now so that quota
! rebuild is not attempted.
!

	    CLEANUP_FLAGS [CLF_REBUILDQUO] = 0;

	    IF .IO_STATUS[0] NEQ SS$_NOSUCHFILE
	    THEN
		BEGIN
		REAL_VCB[VCB$V_NOALLOC] = 1;
		STATUS = MOUN$_QUOTAFAIL;
		END;
	    END;
	END;
    END

! Do /FOREIGN processing if requested.
!

ELSE
    BEGIN

! Store value blocks of device and volume locks, as appropriate.
!

    STORE_CONTEXT ();

    LOCK_IODB ();
    UCB[UCB$L_VCB] = .REAL_VCB;
    UCB[UCB$L_DEVCHAR] = .UCB[UCB$L_DEVCHAR]
			OR (DEV$M_MNT OR DEV$M_DIR OR DEV$M_FOR);
    SET_DATACHECK (.UCB, 0);
    UNLOCK_IODB ();
    END;

IF .MOUNT_OPTIONS[OPT_NOSHARE] AND .CLEANUP_FLAGS[CLF_DEALLOCATE]
THEN UCB[UCB$V_DEADMO] = 1;

IF NOT .MOUNT_OPTIONS[OPT_WRITE]
THEN BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_SWL] = 1;

! Enter the logical name for the volume; bump the user's volume mount count,
! and make the error log entry for the mount.
!

ENTER_LOGNAME (.UCB, .REAL_VCB);
CTL$GL_VOLUMES = .CTL$GL_VOLUMES + 1;
SEND_ERRLOG (1, .UCB);

! If any volume in the set is mounted /NOWRITE or is locked due to an error,
! the entire volume set must be similarly locked to prevent random behavior.
! Scan the RVT and process all volumes in the set. Also inhibit disk rebuild
! if the volumes are locked.
!

NOWRITE = .BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_SWL];
LOCKED = .REAL_VCB[VCB$V_NOALLOC];
MOUNTVER = .REAL_VCB[VCB$V_MOUNTVER];
ERASE = .REAL_VCB[VCB$V_ERASE];
NOHIGHWATER = .REAL_VCB[VCB$V_NOHIGHWATER];

IF .RVT NEQ 0
THEN
    BEGIN
    LOCK_IODB ();

    INCR J FROM 1 TO .RVT[RVT$B_NVOLS]
    DO
	BEGIN

	LOCAL
	    RVUCB	: REF BBLOCK;

	RVUCB = .VECTOR [RVT[RVT$L_UCBLST], .J-1];
	IF .RVUCB NEQ 0
	THEN
	    BEGIN
	    IF .NOWRITE
	    THEN BBLOCK [RVUCB[UCB$L_DEVCHAR], DEV$V_SWL] = 1;
	    NOWRITE = .BBLOCK [RVUCB[UCB$L_DEVCHAR], DEV$V_SWL];

	    VCB = .RVUCB[UCB$L_VCB];
	    IF .LOCKED
	    THEN VCB[VCB$V_NOALLOC] = 1;
	    LOCKED = .VCB[VCB$V_NOALLOC];

	    IF .MOUNTVER
	    THEN VCB[VCB$V_MOUNTVER] = 1;
	    MOUNTVER = .VCB[VCB$V_MOUNTVER];

	    IF .ERASE
	    THEN VCB[VCB$V_ERASE] = 1;
	    ERASE = .VCB[VCB$V_ERASE];

	    IF .NOHIGHWATER
	    THEN VCB[VCB$V_NOHIGHWATER] = 1;
	    NOHIGHWATER = .VCB[VCB$V_NOHIGHWATER];
	    END;
	END;
    UNLOCK_IODB ();
    END;

IF .LOCKED OR .NOWRITE
THEN CLEANUP_FLAGS[CLF_REBUILD] = 0;

! Increment the refcount, so that it never goes to zero while the device
! is mounted.
! All subsequent error paths from this point must do a full dismount to
! correctly remove the refcount bias.
!

UCB[UCB$W_REFC] = .UCB[UCB$W_REFC] + 1;

RETURN .STATUS;

END;					! end of routine MAKE_DISK_MOUNT

GLOBAL ROUTINE SET_DATACHECK (UCB, HOME_BLOCK) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets the read and write check bits in the indicated UCB
!	according to the command switches and the volume characteristics.
!
!
! CALLING SEQUENCE:
!	SET_DATACHECK (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG2: address of home block or 0
!
! IMPLICIT INPUTS:
!	MOUNT_OPTIONS: datacheck qualifier bits
!
! OUTPUT PARAMETERS:
!	ARG1: address of UCB
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	UCB		: REF BBLOCK,	! UCB arg
	HOME_BLOCK	: REF BBLOCK;	! home block arg

EXTERNAL
	MOUNT_OPTIONS	: BITVECTOR;	! parser option flags

! The read and write check attributes to be set are simply the inclusive
! OR of the read and write check volume attributes and the command options.
!

BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_RCK] = .MOUNT_OPTIONS[OPT_READCHECK]
    OR (IF .HOME_BLOCK NEQ 0
	THEN .HOME_BLOCK[HM2$V_READCHECK]
	ELSE 0
	);

BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_WCK] = .MOUNT_OPTIONS[OPT_WRITECHECK]
    OR (IF .HOME_BLOCK NEQ 0
	THEN .HOME_BLOCK[HM2$V_WRITCHECK]
	ELSE 0
	);

END;					! end of routine SET_DATACHECK

ROUTINE KERNEL_HANDLER (SIGNAL, MECHANISM) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the condition handler for all of the kernel mode
!	code. It undoes any damage done so far and returns the error
!	status to the user mode caller.
!
!
! CALLING SEQUENCE:
!	KERNEL_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal vector
!	ARG2: address of mechanism vector
!
! IMPLICIT INPUTS:
!	global pointers to blocks allocated
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	stack unwound, allocations undone
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal vector
	MECHANISM	: REF BBLOCK;	! mechanism vector

LOCAL
	P		: REF BBLOCK,	! pointer to scan system lists
	UCB		: REF BBLOCK;	! UCB being mounted

EXTERNAL
	MOUNT_OPTIONS	: BITVECTOR,	! command parser options
	CLEANUP_FLAGS	: BITVECTOR,	! cleanup action flags
	CHANNEL,			! channel assigned to device
	MAILBOX_CHANNEL,		! channel number of ACP mailbox
	REAL_VCB	: REF BBLOCK,	! address of VCB allocated
	REAL_VCA	: REF BBLOCK,	! address of volume cache allocated
	REAL_FCB	: REF BBLOCK,	! address of FCB allocated
	REAL_WCB	: REF BBLOCK,	! address of window allocated
	REAL_RVT	: REF BBLOCK,	! address of disk RVT
	REAL_AQB	: REF BBLOCK,	! address of AQB allocated
	MTL_ENTRY	: REF BBLOCK,	! address of mounted volume list entry
	SMTL_ENTRY	: REF BBLOCK,	! address of volume set MTL
	IOC$GL_AQBLIST	: REF BBLOCK ADDRESSING_MODE (ABSOLUTE);
					! system AQB list

EXTERNAL ROUTINE
	GET_CHANNELUCB,			! get UCB address of channel
	LOCK_IODB	: ADDRESSING_MODE (GENERAL), ! interlock system I/O database
	UNLOCK_IODB	: ADDRESSING_MODE (GENERAL), ! unlock system I/O database
	DEALLOCATE_MEM;			! deallocate system dynamic memory


! Deallocate whatever control blocks exist to wherever they came from.
!

IF .SIGNAL[CHF$L_SIG_NAME] NEQ SS$_UNWIND
THEN
    BEGIN

    IF .SIGNAL[CHF$L_SIG_ARGS] NEQ 3
    THEN BUG_CHECK (UNXSIGNAL, FATAL, 'Unexpected signal in MOUNT');

! If there is a mailbox in existence, deassign its channel, thereby
! deleting the mailbox.
!

    IF .CLEANUP_FLAGS[CLF_DEASSMBX]
    THEN
	$DASSGN (CHAN = .MAILBOX_CHANNEL);

! Clean up the UCB.
!

    UCB = GET_CHANNELUCB (.CHANNEL);
    LOCK_IODB ();
    BBLOCK [UCB [UCB$L_DEVCHAR], DEV$V_MNT] = 0;
    UCB[UCB$L_VCB] = 0;
    UNLOCK_IODB ();

! If we have created an AQB but no ACP, we must remove the AQB from the
! system list.
!

    IF .CLEANUP_FLAGS[CLF_DELAQB]
    THEN
	BEGIN
	LOCK_IODB ();
	P = .IOC$GL_AQBLIST;
	IF .P EQL .REAL_AQB
	THEN
	    IOC$GL_AQBLIST = .REAL_AQB[AQB$L_LINK]
	ELSE
	    BEGIN
	    UNTIL .P[AQB$L_LINK] EQL .REAL_AQB
	    DO P = .P[AQB$L_LINK];
	    P[AQB$L_LINK] = .REAL_AQB[AQB$L_LINK];
	    END;
	DEALLOCATE_MEM (.REAL_AQB, 0);
	UNLOCK_IODB ();
	END;

! If we have hooked up to an RVT, undo it. Note that this must be done under
! interlock since others may be looking at the same RVT at the same time.
! If the RVT is not disappearing entirely, remove knowledge of this volume
! from it by zeroing the UCB entry in its list of UCB's.
!

    IF .REAL_RVT NEQ 0
    THEN
	BEGIN
	LOCK_IODB ();
	REAL_RVT[RVT$W_REFC] = .REAL_RVT[RVT$W_REFC] - 1;
	IF .REAL_RVT[RVT$W_REFC] EQL 0
	THEN
	    DEALLOCATE_MEM (.REAL_RVT, 0)
	ELSE
	    VECTOR [REAL_RVT [RVT$L_UCBLST], .REAL_VCB [VCB$W_RVN]-1] = 0;

	UNLOCK_IODB ();
	END;

    IF .REAL_VCB NEQ 0
    THEN DEALLOCATE_MEM (.REAL_VCB, 0);

    IF .REAL_VCA NEQ 0
    THEN DEALLOCATE_MEM (.REAL_VCA, 0);

    IF .REAL_FCB NEQ 0
    THEN DEALLOCATE_MEM (.REAL_FCB, 0);

    IF .REAL_WCB NEQ 0
    THEN DEALLOCATE_MEM (.REAL_WCB, 0);

    IF .MTL_ENTRY NEQ 0
    THEN DEALLOCATE_MEM (.MTL_ENTRY, 1);

    IF .SMTL_ENTRY NEQ 0
    THEN DEALLOCATE_MEM (.SMTL_ENTRY, 1);

! Return the condition code in R0.
!

    MECHANISM[CHF$L_MCH_SAVR0] = .SIGNAL[CHF$L_SIG_NAME];
    $UNWIND ();

    END;
END;					! end of routine KERNEL_HANDLER


END
ELUDOM
