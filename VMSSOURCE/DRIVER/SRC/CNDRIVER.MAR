	.TITLE	CNDRIVER - VAX/VMS DECnet-CI Class Driver
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS DECnet-CI class driver
;
; ABSTRACT:
;
;	This module contains the DECnet-CI class driver FDT routines,
;	SCS dispatcher, and fork routines.
;
;
;
;	Kerbey T. Altmann, 17-Aug-1981
;
; MODIFIED BY:
;
;	V03-016	ADE3004		A. Eldridge		24-Jul-1984	
;		Change name back to DECNET$PHASE_III for now.  The change in the
;		name must be phased in by updating the receiver to accept the
;		old and new name before the transmitter can be updated to send
;		the new name.  The new name should be DECNET$CI rather than
;		DECNET$PHASE_IV.
;
;	V03-015	LMP0275		L. Mark Pilant,		12-Jul-1984  12:26
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-014	LMP0221		L. Mark Pilant,		26-Mar-1984  16:43
;		Change UCB$L_OWNUIC to ORB$L_OWNER.
;
;	V03-013	TMK0002		Todd M. Katz		24-Mar-1984
;		When connecting to a remote station over a specific local
;		port, which is what this DECnet class driver does, the name of 
;		the local port together with the remote station address must be 
;		specified as an arguement to the CONNECT fork process call. This
;		DECnet class driver was specifying the name of the local port
;		as PAA. It should now be specifying the name of the local port
;		as PAA0. If this is not done, the CONNECT will fail.
;
;		Change the SCS process name of the DECnet SYSAP from
;		DECNET$PHASE_III to DECNET$PHASE_IV.
;
;	V03-012	TMK0001		Todd M. Katz		08-Feb-1984
;		Use the macro SEND_DG_BUF_REG to do transmits instead of
;		SEND_DG_BUF. This allows me to remove the pseudo-CDRP which
;		is currently buried within the CDB. This false CDRP was only
;		being used to pass the application data and CDT addresses to 
;		the fork process call, FPC$SENDDG. The 	fork process call issued
;		by SEND_DG_BUF_REG, FPC$SENDRGDG, requires these addresses to be
;		in registers when it is invoked, and thus, doesn't require a 
;		CDRP in order to obtain them.
;
;	V03-011	ADE3003		Alan D. Eldridge	19-May-1983
;		Replaced constants with appropriate SBO$ symbols.
;
;	V03-010	ADE3002		Alan D. Eldridge	19-Apr-1983
;		Modified datagram internal SCS header "size" field to
;		handle new negative offset processing option.
;
;	V03-009	ADE3001		Alan D. Eldridge	 2-Feb-1983
;		Simplified connect/disconnect control.  Removed the sending of
;		XON/XOFF sequenced messages.  Issue a CONNECT only if the
;		remote sequence number is higher.  Redefined the CDB.
;
;	V03-008	NPK3010		N. Kronenberg		24-Nov-1982
;		Removed output array specifier from CONFIG_SYS call.
;
;	V03-007	KTA0109		Kerbey T. Altmann	 8-Jul-1982
;		Fix bug in returning buffer info in SENSEMODE.
;
;	V03-006	NPK3004		N. Kronenberg		 2-Jul-1982
;		Modify START_TRIB to connect over specific virtual
;		circuit instead of looking up the remote system and
;		connecting to that.
;
;	V03-005	NPK3003		N. Kronenberg		 1-Jul-1982
;		Fixed offsets from CONFIG_PTH/SYS for new format
;		returned by those routines.
;
;	V03-004	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF.
;
;	V03-003	KTA0097		Kerbey T. Altmann	20-Apr-1982
;		Fix bad branch destination.
;
;
;--

	.SBTTL	External and local symbol definitions

;
; System definitions
;

	$ADPDEF				; Adapter control block
	$CDTDEF				; Connection descriptor
	$CRBDEF				; Channel request block
	$CXBDEF				; Complex buffers
	$DCDEF				; Device classes and types
	$DDBDEF				; Device data block
	$DEVDEF				; Device characteristics
	$DPTDEF				; Driver prologue table defs
	$DYNDEF				; Control block defs
	$IODEF				; I/O function codes
	$IPLDEF				; Hardware IPL definitions
	$JIBDEF				; Job info block
	$IRPDEF				; I/O request packet
	$NMADEF				; Network Management definitions
	$ORBDEF				; Object's Rights Block
	$PBDEF				; Path block defininitions
	$PCBDEF				; Process control block
	$PDTDEF				; Port Descriptor Table
	$PRDEF				; Processor register definitions
	$SBDEF				; System block definitions
	$SBODEF				; System block output definitions
	$SSDEF				; System status codes
	$UCBDEF				; Unit control block
	$VECDEF				; Interrupt vector block
	$XMDEF				; XMDRIVER symbols

;
; Local macros
;
.MACRO	SETBIT	POS,BAS,?L		; Set a single bit
		BBSS	POS,BAS,L
	      L:
.ENDM	SETBIT

.MACRO	CLRBIT	POS,BAS,?L		; Clear a single bit
		BBCC	POS,BAS,L
	      L:
.ENDM	CLRBIT
 
.MACRO	PUSHQ	ARG			; Push a quadword
		MOVQ	ARG,-(SP)	; Save argument on stack
.ENDM	PUSHQ
 
.MACRO	POPQ	ARG			; Pop a quadword
		MOVQ	(SP)+,ARG	; Restore argument
.ENDM	POPQ



$DEFINI	PARAM
 
   COUNT_C_ENTRY = 2*2			; COUNT table entry size
   PARAM_C_ENTRY = 2*6			; PARAM table entry size
  _VIELD PRM,0,<-			; Parameter bits and sizes
		<TYPE,12,M>,-		; Parameter type
		<MIN,1,M>,-		; Parameter minimum value
		<MAX,1,M>,-		; Parameter maximum value
		<REQUIRE,1,M>,-		; Parameter required flags
		<INVALID,1,M>,-		; Parameter invalid flags
	       >
 
  _VIELD OFF,0,<-			; Offset word fields
		<VALUE,10,M>,-		; Offset value
		<WIDTH, 6,M>,-		; Width of field in structure
	       >
 
$DEFEND	PARAM
 
.MACRO	PARAM	TYPE,OFFSET,WIDTH=0,MIN=0,MAX=-1,REQUIRED,INVALID
			; NOTE - The REQUIRED field can only check 1 bit!

	$$$NUM = $$$NUM+1		   ; Count number of time executed
	$$$TYP = NMA$C_'TYPE & PRM_M_TYPE  ; Isolate type
	$$$OFF = OFFSET & OFF_M_VALUE	   ; Isolate offset only

	.IIF NOT_BLANK	<MIN>,	    $$$TYP = $$$TYP ! PRM_M_MIN
	.IIF NOT_BLANK	<MAX>,	    $$$TYP = $$$TYP ! PRM_M_MAX
	.IIF NOT_BLANK	<REQUIRED>, $$$TYP = $$$TYP ! PRM_M_REQUIRE
	.IIF NOT_BLANK	<INVALID>,  $$$TYP = $$$TYP ! PRM_M_INVALID

		.WORD	$$$TYP
		.WORD	$$$OFF ! <WIDTH @ OFF_V_WIDTH>
		.WORD	MIN
		.WORD	MAX
		.WORD	REQUIRED
		.WORD	INVALID
.ENDM	PARAM

 
.MACRO	COUNT	TYPE,OFFSET,WIDTH=32

	$$$NUM = $$$NUM+1		   ; Bump number of time executed
	$$$OFF = OFF_M_VALUE & OFFSET 	   ; Isolate offset only
	$$$TYP = PRM_M_TYPE & NMA$C_'TYPE  ; Isolate type

	.IIF IDN, WIDTH, 8,	$$$TYP = $$$TYP ! <1@NMA$V_CNT_WID>
	.IIF IDN, WIDTH,16,	$$$TYP = $$$TYP ! <2@NMA$V_CNT_WID>
	.IIF IDN, WIDTH,32,	$$$TYP = $$$TYP ! <3@NMA$V_CNT_WID>
	
		
		.WORD	$$$TYP ! NMA$M_CNT_COU
		.WORD	$$$OFF ! <WIDTH @ OFF_V_WIDTH>
.ENDM	COUNT

.MACRO	START_TABLE	NAME		; Start Table declaration
	$$$NUM = 0			; Init number of entries
	'NAME'_TABLE = .		; Define begining of table
.ENDM	START_TABLE

.MACRO	END_TABLE	NAME		; Terminate Table declaration
	.WORD	0			; Create marker
	'NAME'_NUM = $$$NUM		; Number of entries
.ENDM	END_TABLE

;
; Local symbols
;

;
; $QIO parameter offsets
;
P1	= 0				; Parameter 1
P2	= 1*4				; Parameter 2

;
; Other constants
;
RBFMIN		=   9			; Min size of CDB_B_RCV_CNT
RBFMAX		=  31			; Max size of CDB_B_RCV_CNT
RBFTHR		=   6			; CND_B_RCV_FQ threshold.  Below this
					; signal XM$M_STS_BUFFAIL in IOST2
MAX_TRB		= 16			; Max tributaries on CI device

;
; Overlays of IRP
;
	ASSUME IRP$L_SEGVBN EQ IRP$Q_NT_PRVMSK+8

$DEFINI	IRP
 
	. = IRP$Q_NT_PRVMSK		; Overlay network priv mask
$DEF	IRP$B_INDEX	.BLKB	1	; Vector index for CDB

	. = IRP$L_EXTEND
$DEF	IRP$L_CDB	.BLKL	1

$DEFEND	IRP				; End of IRP overlays


;
; Definitions that follow the standard UCB fields
;

$DEFINI	UCB				; Start of UCB definitions

	. = UCB$C_LENGTH		; Position at end of UCB

$DEF	UCB$L_LIS_CDT	.BLKL	1	; Addr of listening CDT
$DEF	UCB$L_TWIN_CDT	.BLKL	1	; Addr of loopbacked accept CDT
$DEF	UCB$L_DGHDRSZ	.BLKL	1	; Size of the SCS header for DG's
$DEF	UCB$W_DUMMY	.BLKW	1	; Dummy location for unwanted param's
$DEF	UCB$B_CN_PORT	.BLKB	1	; Our port number
$DEF	UCB$B_RCV_CNT	.BLKB	1	; Number of receive buffers
$DEF	UCB$L_VEC_CDB	.BLKL	MAX_TRB	; CDB address vector
$DEF	UCB$W_VEC_CHAN	.BLKW	MAX_TRB	; User channel lookup vector

	UCB$C_CN_LENGTH	= <.+15>&-16	; Size of UCB padded to a quadword
 
	;
	;  Define device status bits
	;
	$VIELD	UCB,0,<-		; CNDRIVER UCB$W_DEVSTS bits
			<CN_INITED,,M>,-; Device init'ed
		>			;
$DEFEND	UCB				; End of UCB definitions


;
; CNDRIVER CDB definitions
;
$DEFINI	CDB

$DEF	CDB_Q_FORK	.BLKQ	1	; Fork Queue Linkage
$DEF	CDB_W_SIZE	.BLKW	1	; Structure size
$DEF	CDB_B_TYPE	.BLKB	1	; Structure type
$DEF	CDB_B_FIPL	.BLKB	1	; Fork IPL (not UCB FIPL)
	CDB_C_FIPL = 6			; Must be less than SCS's IPL (8)
$DEF	CDB_L_FPC	.BLKL	1	; Fork PC
$DEF	CDB_L_FR3	.BLKL	1	; Fork R3
$DEF	CDB_L_FR4	.BLKL	1	; Fork R4
					;
$DEF	CDB_Q_XMT_IRP	.BLKQ	1	; Transmit IRP's awaiting completion
$DEF	CDB_Q_RCV_IRP	.BLKQ	1	; Receive IRP's awaiting buffers
$DEF	CDB_Q_RCV_MSG	.BLKQ	1	; Receive buffers containing messages
					;
$DEF	CDB_L_SETMODE	.BLKL	1	; Ptr to IO$_SETMODE
$DEF	CDB_L_ABSTIME	.BLKL	1	; Time last DISCONNECT was issued
$DEF	CDB_W_BUFSIZ	.BLKW	1	; Buffer size
$DEF	CDB_W_STS	.BLKW	1	; Circuit status
$DEF	CDB_B_RCV_CNT	.BLKB	1	; Receive buffer count
$DEF	CDB_B_RCV_FQ	.BLKB	1	; Receive buffers on free queue
$DEF	CDB_B_TRB_ADDR	.BLKB	1	; Tributary address
$DEF	CDB_B_STA	.BLKB	1	; Circuit state
	;
	;
	;  Circuit counters
	;
	;
$DEF	CDB_L_BRC	.BLKL	1	; Receive byte count
$DEF	CDB_L_BSN	.BLKL	1	; Transmit byte count
$DEF	CDB_L_DBR	.BLKL	1	; Data buffers received
$DEF	CDB_L_DBS	.BLKL	1	; Data buffers sent
	;
$DEF	CDB_L_UCB	.BLKL	1	; Addr of UCB
$DEF	CDB_L_CDT	.BLKL	1	; Ptr to CDT
$DEF	CDB_B_REMVER	.BLKB	1	; Remote's protocol version
$DEF	CDB_B_REMSYS	.BLKB	1	; Remote's operating system
	CDB_W_REMPROT = CDB_B_REMVER	; Label combining two fields above
$DEF	CDB_B_DUMMY	.BLKB	1	; Dummy location for unwanted param's
$DEF	CDB_B_RSTCNT	.BLKB	1	; Restart counter for slowing down
					; restart frequency
	CDB_C_LENGTH = <.+15>&-16	; Pad structure out to a quadword

;
; Define status bits used in CDB_W_STS and CDB_B_STA values
;
	_VIELD	CDB,0,<-		; Tributary status bits for CDB_W_STS
			<RUN,,M>,-	; Tributary is in RUN state
			<CONN,,M>,-	; Call to CONNECT pending
			<ACPT,,M>,-	; CALL to ACCEPT pending
			<DISC,,M>,-	; Call to DISCONNECT or FORK pending
			<REJECT,,M>,-	; Call to REJECT pending
	       >			; 

	CDB_C_IDLE = 0			; Tributary is idle
	CDB_C_OPEN = 1			; Tributary connection has been made
	CDB_C_CONN = 2			; Tributary has CONNECT pending
	CDB_C_LSTN = 3			; Tributary is listening for connect
	CDB_C_ACPT = 4			; Tributary has ACCEPT pending

$DEFEND	CDB


	.SBTTL	Standard tables

;
; Driver prologue table
;

	DPTAB	-				; DPT-creation macro
		END	= CN_END,-		; End of driver label
		ADAPTER	= NULL,-		; Adapter type
		FLAGS	= DPT$M_SCS,-		; Driver requires SCS
		UCBSIZE	= UCB$C_CN_LENGTH,-	; Length of UCB
		NAME	= CNDRIVER,-		; Driver name
 
	DPT_STORE INIT				; Start of load
						; initialization table
	DPT_STORE UCB,UCB$B_FIPL,B,8		; Device fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,8		; Device interrupt IPL
	DPT_STORE ORB,ORB$B_FLAGS,B,-		; Protection block flags
			   <ORB$M_PROT_16>	; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,W,0		; default protection
	DPT_STORE ORB,ORB$L_OWNER,L,<^X010001>	; [1,1] owns the device
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-		; Device characteristics
			   <DEV$M_NET!-		;   e.g., network device
			    DEV$M_REC!-		;   record oriented
			    DEV$M_IDV!-		;   input device
			    DEV$M_ODV-		;   output device
			   >
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_SCOM	; Sample device class
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,-	; Default buffer size
			    SCS$GW_MAXDG
 
	DPT_STORE REINIT			; Start of reload
						; initialization table
	DPT_STORE DDB,DDB$L_DDT,D,CN$DDT	; Address of DDT
	DPT_STORE CRB,-				; Address of device
		     CRB$L_INTD+VEC$L_UNITINIT,-; unit initialization
		     D,UNIT_INIT		; routine

	DPT_STORE END				; End of initialization
						; tables

;
; Driver dispatch table
;
	DDTAB	-				; DDT-creation macro
		DEVNAM	= CN,-			; Name of device
		FUNCTB	= CN_FUNCTABLE,-	; FDT address
		CANCEL	= CANCEL,-		; Cancel I/O routine
		ALTSTART= ALT_START		; Alternate start I/O
;
; Function dispatch table
;
CN_FUNCTABLE:					; FDT for driver
	FUNCTAB	,-				; Valid I/O functions
			<READLBLK,-		; Read logical
			 WRITELBLK,-		; Write logical
			 SETMODE,-		; Set device mode
			 SENSEMODE,-		; Sense mode
			 SETCHAR -		; Set device chars.
			>
	FUNCTAB	,-				; Buffered functions:
			<READLBLK,-		; Read logical
			 WRITELBLK,-		; Write logical
			 SETMODE,-		; Set device mode
			 SENSEMODE,-		; Sense mode
			 SETCHAR -		; Set device chars.
			>
	FUNCTAB	CLR_IRP,-			; Init IRP fields
			<READLBLK,-		; Read logical
			 WRITELBLK,-		; Write logical
			 SETMODE,-		; Set device mode
			 SENSEMODE,-		; Sense mode
			 SETCHAR -		; Set device chars.
			>
	FUNCTAB	RCV_FDT,-			; FDT read routine for
			<READLBLK,-		; read logical,
			>
	FUNCTAB	XMT_FDT,-			; FDT write routine for
			<WRITELBLK,-		; write logical,
			>
	FUNCTAB	SETMODE_FDT,-			; FDT set mode routine
			<SETMODE,-		; set mode
			 SETCHAR -		; set characteristics
			>
	FUNCTAB SENSEMODE_FDT,-			; FDT sense mode routine
			<SENSEMODE>		; for sensemode 

	.SBTTL	P2 buffer verification tables
 
;
; Define CDB parameters
;
START_TABLE TRIB_PRM	; Start of tributary parameter table
 
	PARAM PCCI_MST, OFFSET	= CDB_B_DUMMY,-		; Trib maint state
			WIDTH	= 0,-			; Dummy location
			MIN	= NMA$C_STATE_ON,-
			MAX	= NMA$C_STATE_OFF,-
			REQUIRED= 0,-
			INVALID	= CDB_M_RUN	
	
	PARAM PCCI_TRI, OFFSET	= CDB_B_TRB_ADDR,-	; Trib address
			WIDTH	= 8,-
			MIN	= 0,-
			MAX	= 15,-
			REQUIRED= 0,-
			INVALID	= CDB_M_RUN
	 
	PARAM PCCI_MRB,	OFFSET	= CDB_B_RCV_CNT,-	; Trib max buf
			WIDTH	= 8,-
			MIN	= 0,-
			MAX	= 255,-
			REQUIRED= 0,-
			INVALID	= CDB_M_RUN	

END_TABLE  TRIB_PRM	; End of tributary paramerer table


;
; Define UCB parameters
;
START_TABLE LINE_PRM	; Start of device parameter table

	PARAM PCLI_DUP,	OFFSET	= UCB$W_DUMMY,-		; Duplex
			WIDTH	= 0,-			; Dummy location
			MIN	= NMA$C_DPX_FUL,-
			MAX	= NMA$C_DPX_HAL,-
			REQUIRED= 0,-
			INVALID	= UCB$M_CN_INITED
	
	PARAM PCLI_CON,	OFFSET	= UCB$W_DUMMY,-		; Controller mode
			WIDTH	= 0,-			; Dummy location
			MIN	= NMA$C_LINCN_NOR,-
			MAX	= NMA$C_LINCN_LOO,-
			REQUIRED= 0,-
			INVALID	= UCB$M_CN_INITED

	PARAM PCLI_BUS, OFFSET	= UCB$W_DEVBUFSIZ,-	; Block size
			WIDTH	= 16,-
			MIN	= 32,-
			MAX	= 948,-
			REQUIRED= 0,-
			INVALID	= UCB$M_CN_INITED

	PARAM PCLI_BFN, OFFSET	= UCB$B_RCV_CNT,-	; Maximum receive buffers
			WIDTH	= 8,-
			MIN	= 1,-
			MAX	= 255,-
			REQUIRED= 0,-
			INVALID	= UCB$M_CN_INITED

END_TABLE  LINE_PRM	; End of device parameter tables

;
; Tributary counter type codes
;
START_TABLE  TRIB_CNT		; Start of Tributary COUNTER table

	COUNT	CTCIR_BRC, WIDTH=32, OFFSET=CDB_L_BRC	; Bytes received
	COUNT	CTCIR_BSN, WIDTH=32, OFFSET=CDB_L_BSN	; Bytes sent
	COUNT	CTCIR_DBR, WIDTH=32, OFFSET=CDB_L_DBR	; Data blocks received
	COUNT	CTCIR_DBS, WIDTH=32, OFFSET=CDB_L_DBS	; Data blocks sent

END_TABLE    TRIB_CNT		; End of Tributary COUNTER table


START_TABLE  LINE_CNT		; Start of device COUNTER table
END_TABLE    LINE_CNT		; - null table

;
;  Our SCS process name and connect data
;
PROC_C_NAM = 6				; How much of PROC_NAM must match
PROC_NAM:
	.ASCII	'DECNET$PHASE_III'	; How SCS knows us -- 16 characters long
CONN_DATA:
	.BYTE	1			; Protocol version
	.BYTE	0			; Operating system (VMS) id
	.BYTE	0[14]			; Remaining fields must be zero

OLD_C_PROT = 0				; Use for original protocol


	.SBTTL	UNIT_INIT,  Unit initialization routine

;++
; UNIT_INIT - Readies unit for I/O operations
;
;
; The operating system calls this routine after calling the
; controller initialization routine:
;
;	- at system startup
;	- during driver loading
;	- during recovery from a power failure
;
; The unit is put online.
;
; Inputs:	R5 = UCB address
;
; Outputs:	All registers are preserved
;
;
;--

UNIT_INIT:					; Initialize unit
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; Set unit online
	RSB					; Return


	.SBTTL	CLR_IRP	- Initialize IRP fields

;++
; CLR_IRP  - Initialize IRP fields
;
; 
; Selected IRP fields are initialized.  The function code with modifiers
; is setup.
;
; Inputs:	R3   IRP address
;
; Outputs:	All other registers are preserved.
;
;		IPL may be FIPL or ASTDEL
;
;--
CLR_IRP:				; Initialize IRP fields
	CLRQ	IRP$L_IOST1(R3)		; Clear IOSB image
	CLRL	IRP$L_SVAPTE(R3)	; Init buffer pointer
	CLRW	IRP$W_BOFF(R3)		; No quota to return yet at I/O post
	CLRL	IRP$L_CDB(R3)		; No CDB yet
	CLRQ	IRP$B_INDEX(R3)		; No trib i.d. yet
	RSB				; Done


	.SBTTL	XMT_FDT,  Transmit I/O Operation FDT Routine

;++
; XMT_FDT - Transmit I/O Operation FDT Routine
;
;
; This routine is called by the SYS$QIO system service to dispatch a
; WRITE I/O request.  The buffer is validated for access and copied to a 
; system buffer.
;
; The QIO parameters used for WRITEs are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;
; Inputs:	R3  - IRP address (I/O request packet)
;		R4  - PCB address (process control block)
;		R5  - UCB address (unit control block)
;		R6  - CCB address (channel control block)
;		R7  - bit number of the I/O function code
;
;		IPL = ASTDEL (2)
;
; Outputs:	R0 = status of transmit request initiation
;
;		R1,R2 are clobbered, all others are preserved.
;--
XMT_FDT:					; Transmit FDT routine
	BSBB	XMT_RCV_FDT_CO			; Get user buffer
						; - no return on error
	JSB	G^EXE$WRITECHK			; Check buffer access 
						; (no return means no access)
GET_BUF:					; Get buffer
	PUSHR	#^M<R1,R2,R3,R4,R5>		; Save registers
						;
	JSB	G^EXE$BUFFRQUOTA		; Check if process has sufficient quota
	BLBC	R0,20$				; If LBC quota check failure
	ADDL	#CXB$C_OVERHEAD,R1		; Add in overhead
	JSB	G^EXE$ALONONPAGED		; Allocate buffer for output
	BLBC	R0,20$				; If LBC allocation failure
	ADDL3	#<DYN$C_CXB@16>,R1,IRP$W_SIZE(R2) ; Set the size
	MOVAB	CXB$C_HEADER(R2),(R2)		; Store pointer to data area
	MOVL	(SP),R1				; Get back message size
	MOVL	R2,4(SP)			; Save buffer address
	MOVL	8(SP),R3			; Retrieve address of IRP
	MOVL	PCB$L_JIB(R4),R0		; Get JIB address
	SUBW	R1,JIB$L_BYTCNT(R0)		; Adjust buffered I/O quota
	MOVL	R2,IRP$L_SVAPTE(R3)		; Setup buffer pointer
	MOVW	R1,IRP$W_BOFF(R3)		; Set number of bytes charged to quota
	BEQL	10$				; If EQL then none
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),10$	; If BS then "read" function
	MOVC3	R1,@IRP$L_IOST2(R3),@(R2)	; Move data
10$:	MOVL	#1,R0				; Indicate success
						;
20$:	POPR	#^M<R1,R2,R3,R4,R5>		; Restore registers
	RSB					; Return to co-routine with

	.SBTTL	RCV_FDT,  Read I/O Operation FDT Routine

;++
; RCV_FDT - Read I/O Operation FDT Routine
;
;
; This routine is called by the SYS$QIO system service to dispatch a
; READ I/O request.
;
; The QIO parameters for READs are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	All other parameters are unused.
;
; The specified buffer is checked for accessibility. The buffer address and
; count are saved in the packet. Then IPL is raised to device fork IPL and if
; a message is available the operation is complete. Otherwise the packet is
; queued onto the waiting receive list of the CDB.
;
;
; Inputs:	R3  - IRP address (I/O request packet)
;		R4  - PCB address (process control block)
;		R5  - UCB address (unit control block)
;		R6  - CCB address (channel control block)
;		R7  - bit number of the I/O function code
;
;		IPL = ASTDEL (2)
;
; Outputs:	R0 = status of transmit request initiation
;
;		R1,R2 are clobbered, all others are preserved.
;
;--
RCV_FDT:					; Read FDT process routine
	BSBB	XMT_RCV_FDT_CO			; Get user buffer
						; - no return on error
	JSB	G^EXE$READCHK			; Check accessibility
						; (No return on no access)
	MOVL	#1,R0				; Say "success"
	RSB					; Return status to co-routine



XMT_RCV_FDT_CO:
	MOVZWL	S^#SS$_BADPARAM,R0		; Assume bad parameters
	MOVZWL	P2(AP),R1			; Get buffer size
	BEQL	10$				; If zero, abort I/O request
	CMPW	R1,UCB$W_DEVBUFSIZ(R5)		; Is buffer too big?
	BGTRU	10$				; If GTRU yes, abort I/O request
	MOVL	P1(AP),R0			; Get user buffer virt address
	MOVL	R0,IRP$L_IOST2(R3)		; Save it for MOVC
	JSB	@(SP)+				; Call back our caller
	BLBS	R0,20$				; If LBS, continue
10$:	BRW	ABORT_REQ			; Abort the request 
20$:	;
	;
	;  Okay so far.  Setup to return to EXE$QIORETURN -- which returns to
	;  the user with SS$_NORMAL in R0.  This means that all subsequent
	;  errors must be reported via the IOSB.
	;
	;
	PUSHAB	G^EXE$QIORETURN			; Setup return address on stack
	SETIPL	UCB$B_FIPL(R5)			; Raise IPL to fork level
	;					;  to lock the data base
	;  Fall thru to ALT_START
	;

	.SBTTL	ALT_START,  Alternate Start I/O Routine

;++
; ALT_START - Alternate Start I/O Routine
;
;
; This entry point is used to dispatch IO$_READLBLK and IO$_WRITELBLK requests.
; The IRP is either built by our own FDT routines, or by some higher level
; Executive agent (e.g, NETDRIVER).  All I/O status, including errors, must
; be passed via IOPOST in the IOSB.
;
;
; NOTE: The CHAN field of the IRP is sufficient to map to a CDB.
;
; Inputs:	R3 - IRP address
;		R5 - UCB address
;
;		All pertinent fields of the IRP are assumed to be valid.
;
;		IPL = FIPL
;
; Outputs:	R0-R4	Garbage
;
;--
ALT_START:
	PUSHR	#^M<R4,R9>		; Save reg
	BSBB	5$			; Process request
	POPR	#^M<R4,R9>		; Restore regs
	RSB				; Return to caller with garbage in R0
					;
5$:	BSBW	XLATE			; Get CDB from IRP$W_CHAN
	BLBC	R0,ABORT_START		; If LBC then error
	ASSUME	CDB_V_RUN  EQ  0	;
	BLBC	CDB_W_STS(R9),ABORT_START; If LBC then not in RUN state
	BBS	#IRP$V_FUNC,-		;	
		IRP$W_STS(R3),RCV_START	; If BS then IO$_READ else IO$_WRITE
	;
	;  Fall thru to XMT_START
	;

	.SBTTL	XMT_START,  Start Transmit Operation
 
;++
; XMT_START - Start Transmit Operation
;
;
; This routine is called to start a transmit operation.  The tributary is
; known to be up and running at this point.  All status must be returned via
; the IOSB.
;
;
; Inputs:	R3 = IRP address
;		R5 = UCB address
;		R9 = CDB address
;
;		IPL = FIPL
;
; Outputs:	R0 = status of transmit request
;
;		R5-R7 are preserved.
;
;--
XMT_START:
	MOVZWL	IRP$L_BCNT(R3),R1		; Pick up length
	MOVL	IRP$L_SVAPTE(R3),R0		; Pick up head of buffer
	MOVL	(R0),R2				; Get beginning of user message
10$:	;
	;  Add CI padding to keep beginning quadword aligned
	;
	BITB	#^X<07>,R2			; Need padding ?
	BEQL	20$				; If EQL no
	MNEGB	#1,-(R2)			; Pad
	INCL	R1				; Adjust byte count
	BRB	10$
20$:	;
	;  Send it to SCS requesting that the datagram be returned when done.
	;
	PUSHQ	R2				; Save user msg & IRP addresses
	CMPW	R1,CDB_W_BUFSIZ(R9)		; Msg size within bounds?
	BGTRU	60$				; If GTRU then no
	SUBL	#32,R2				; Go to begining of PPD header
	SUBL3	R0,R2,R4			; Get offset to top of buffer
	CMPL	R4,#CXB$C_HEADER-32		; Is header big enough ?
	BLSS	60$				; If LSS then header too small
	MNEGW	R4,8(R2)			; Neg. offset to top of buffer
	MOVW	#DYN$C_CIDG,10(R2)		; Sturcture type
	MOVL	UCB$L_PDT(R5),R4		; Recover the PDT
	SEND_DG_BUF_REG  #1,-			; Control returns immediately
			 CDT=CDB_L_CDT(R9),BUFFER=(SP)
	BLBC	R0,60$				; If LBC, datagram not queued
	POPQ	R2				; Restore IRP address
	INSQUE	(R3),@CDB_Q_XMT_IRP+4(R9)	; Queue IRP
40$:	RSB					; Return to await completion

60$:	POPQ	R2				; Restore IRP address

ABORT_START:
	BRW	ABORT_IRP_POST			; Report SS$_ABORT via IOSB


	.SBTTL	RCV_START,  Start Receive Operation
 
;++
; RCV_START - Start Receive Operation
;
;
; This routine is called to start a receive operation.  The tributary is
; known to be up and running at this point.  If IRP$L_SVAPTE is none zero
; then it is assumed to be system buffer to be added to the receive free list.
; All status must be returned via the IOSB.
; 
; Inputs:	R3 = IRP address
;		R5 = UCB address
;		R9 = CDB address
;
;		IPL = FIPL
;
; Outputs:	R0 = return status of receive request
;
;--
RCV_START:
	MOVL	R9,R4				; Transfer CDB pointer
	BSBW	ADDRCVLIST			; Add IRP buffer to free list
	;
	;  Check to see if message is available
	;
	REMQUE	@CDB_Q_RCV_MSG(R9),R2		; Dequeue a received message
	BVS	100$				; Br if none
	BRW	FINISH_RCV_IO			; Complete the I/O request
100$:	;
	;  No message available.  Queue IRP to await arrival of message.
	;
	INSQUE	(R3),@CDB_Q_RCV_IRP+4(R9) 	; Queue IRP to await message
	RSB					; Return


	.SBTTL	SETMODE_FDT,  Set mode I/O operation FDT routine
 
;++
; SETMODE_FDT - Set mode I/O operation FDT routine
;
;
; Setup control parameters.  Optionally startup/shutdownt the device or one
; of the tributaries.  The subfunction modifiers are as follows:
;
;	IO$M_CTRL	- If set, request is for device.  Else, for tributary.
; 	IO$M_STARTUP	- Start device or establish tributary connection.
; 	IO$M_SHUTDOWN	- Shutdown device or disconnect tributary.
;
;
; The QIO parameter for SETMODE is:
;
;	P2 = Optional address of buffer descriptor for extended characteristics
;
;
; Inputs:	R3 = IRP address
;		R4 = PCB address
;		R5 = UCB address
;		R6 = CCB address
;		R7 = Function code
;		AP = address of first QIO parameter
;
; Outputs:	R0 = status of setmode request
;
;		R3-R5 are preserved.
;		R7-R9 = destroyed
;
;--
SETMODE_FDT:					; Setmode FDT processing
	;
	;  Copy the characteristics buffer, if any.  No return on error.
	;  On return, there's a buffer attached to IRP$L_SVAPTE containing a
	;  copy of the user buffer -- hence we cannot "abort" the QIO passed
	;  this point but must return all errors via the IOSB.
	;
	;  Upon return, the IPL has been raised to FIPL
	;
	BSBW	GET_CHAR_WBUF			; Get P2 characteristics buffer
						; - no return on error
	MOVZWL	IRP$W_FUNC(R3),R7		; Get full function code.
	BBC	S^#IO$V_CTRL,R7,10$		; Br if not controller request
	BRW	SETMODE_CTRL			; Process controller request
10$:	;
	;  Perform setmode request on a tributary
	;
	BSBW	XLATE				; Get CDB address if any
	BBC	S^#IO$V_SHUTDOWN,R7,40$		; Branch if not trib shutdown
	;
	;  Shutdown tributary modifier specified -- always successful.
	;  Shutdown may complete ahead of other queued I/O for this tributary.
	;
	BLBC	R0,FINISH_SUC			; If LBC then no CDB
	BSBW	ZAP_CDB_R9			; Do the dirty work
	BRB	FINISH_SUC			; Always return "success"
40$:	;
	;  IO$M_STARTUP tributary modifier specified or no modifier.
	;  Validate the P2 buffer and its contents.
	;
	MOVAB	TRIB_PRM_TABLE,R1		; Set address of verification table
	CLRL	R2				; No status flags yet
	BLBS	R9,50$				; If LBS then no CDB
	MOVZWL	CDB_W_STS(R9),R2		; Get status flags
50$:	BSBW	VALIDATE_P2			; Validate the P2 buffer
	BLBC	R0,FINISH_REQ			; If LBC, report error via IOSB
	;
	;  Check trib address.  If this is a trib address change for this
	;  channel  (in which case unconditionally give up the old CDB even if
	;  the QIO subsequently fails), or if there is no current CDB, then
	;  attempt to bind this channel to the CDB for the new trib address.
	;
	MOVZWL	#NMA$C_PCCI_TRI,R1		; Get trib address param i.d.
	BSBW	UNPACK_P2_BUF			; From P2 buffer
	BLBS	R0,60$				; If LBS, trib was specified
	BLBS	R9,FINISH_REQ			; If LBS, no CDB - return R0,R1
	BRB	80$				; No trib addr, use current CDB
60$:	BLBS	R9,70$				; If LBS, no CDB
	CMPB	R2,CDB_B_TRB_ADDR(R9)		; Address being changed ?
	BEQL	80$				; If EQL no
	CLRW	UCB$W_VEC_CHAN(R5)[R2]		; Give-up previous CDB
	BSBW	ZAP_CDB_R9			; Shut it down
70$:	BSBB	NEW_TRIB			; Init/allocate CDB
	BLBC	R0,FINISH_ERR			; If LBC, report error
80$:	;
	;  Tributary now exists change its characteristics and set them
	;  if trib is established.
	;
	BBC	S^#IO$V_STARTUP,R7,FINISH_SUC	; Br if not startup request
	MOVZWL	#SS$_DEVACTIVE,R0		; Assume trib already active
	MOVZWL	CDB_W_STS(R9),R1		; Get current status
	ASSUME	CDB_C_IDLE  EQ  0		;
	BISB	CDB_B_STA(R9),R1		; OR in the state
	BISL	CDB_L_SETMODE(R9),R1		; OR in pending SETMODE address
	BNEQ	FINISH_ERR			; If NEQ then can't do startup
	MOVL	R3,CDB_L_SETMODE(R9)		; Save IRP address
	BSBW	START_TRIB			; Startup the trib
						; Fall thru to QIORET


	.SBTTL	Complete QIO request routines

;+
;  The following routines all exit the $QIO system service with status in R0.
;  If an error is not being returned, further status will be eventually passed
;  via the IOSB when the IRP undergoes post processing.
;
;
;  Inputs:	R3  IRP address
;		R5  UCB address
;
;		IPL may be FIPL or IPL$_ASTDEL
;
;-
QIORET:	JMP	G^EXE$QIORETURN			; Return success in R0 to user
ABORT_REQ1:
	MOVL	S^#SS$_ABORT,R0			; Setup error status
ABORT_REQ:
	JMP	G^EXE$ABORTIO			; Exit QIO service with error



;+
;  The following routines exit the $QIO system service with SS$_NORMAL and
;  send the IRP back to IOPOST to return final status via the IOSB.
;
;  Inputs:	R3  IRP address
;		R5  UCB address
;
;		IPL may be either FIPL or IPL$_ASTDEL
;
;-
FINISH_SUC:
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
FINISH_ERR:
	CLRL	R1				; Clear second IOSB longword
	BBS	S^#IO$V_CTRL,-			; Skip for controllers 
		IRP$W_FUNC(R3),FINISH_REQ 	;
	ASSUME	CDB_V_RUN  EQ  0		;
	BLBC	R0,FINISH_REQ			; If LBC then circuit not up
	MOVL	#XM$M_STS_ACTIVE!-		; Indicate circuit up
		 XM$M_STS_RUNNING,R1		;
FINISH_REQ:
	JMP	G^EXE$FINISHIO			; Complete the I/O
 

	.SBTTL	NEW_TRIB  - Allocate and init new CDB

;+
;  NEW_TRIB	- allocate and init new CDB
;
;
; A CDB is allocated and initialized and stored in the UCB CDB vector.
; The address is also stored in IRP$L_CDB.
;
;
; Inputs:	R2  Trib address
;		R3  IRP address
;		R5  UCB address
;
; Outputs:	R9  CDB address
;
;		R0-R2  are clobbered.  All other registers are preserved.
;
;-
NEW_TRIB:
	MOVB	R2,IRP$B_INDEX(R3)		; Set the trib number
	MOVZWL	#SS$_DEVALRALLOC,R0		; Assume error
	TSTW	UCB$W_VEC_CHAN(R5)[R2]		; Claimed by another channel?
	BNEQ	40$				; If NEQ yes, report error
	MOVL	UCB$L_VEC_CDB(R5)[R2],R9	; Get associated CDB
	BNEQ	30$				; If NEQ, CDB exits - claim it
	BSBB	NEW_CDB				; Create a new CDB
	BLBC	R0,40$				; If LBC then error
	MOVZBL	IRP$B_INDEX(R3),R2		; Restore trib address
	MOVL	R9,UCB$L_VEC_CDB(R5)[R2]	; Store CDB address in UCB
30$:	MOVW	IRP$W_CHAN(R3),-		; Save channel index in UCB
		UCB$W_VEC_CHAN(R5)[R2]		;
40$:	RSB					; Done


NEW_CDB:					; Create new CDB
	MOVZWL	#CDB_C_LENGTH,R1		; Get size of CDB
	PUSHL	R3				; Save reg
	JSB	G^EXE$ALONONPAGED		; Allocate the CDB
	POPL	R3				; Restore reg
	BLBC	R0,100$				; Br if error
	;
	;  Initialize CDB
	;
	MOVL	R2,R9				; Copy CDB address
	MOVL	R2,IRP$L_CDB(R3)		; Save it in IRP
	MOVAB	CDB_W_SIZE(R2),R2		; Setup ptr to init CDB

	ASSUME	CDB_B_TYPE	EQ  2+CDB_W_SIZE
	ASSUME	CDB_B_FIPL	EQ  1+CDB_B_TYPE
	ASSUME	CDB_L_FPC	EQ  1+CDB_B_FIPL
	ASSUME	CDB_L_FR3	EQ  4+CDB_L_FPC
	ASSUME	CDB_L_FR4	EQ  4+CDB_L_FR3

	MOVW	R1,(R2)+			; CDB_W_SIZE
	MOVW	#<CDB_C_FIPL@8>+DYN$C_NET,(R2)+	; CDB_B_TYPE and CDB_B_FIPL
	ADDL	#3*4,R2				; Advance passed CDB_L_FR4

	ASSUME	CDB_Q_XMT_IRP	EQ  4+CDB_L_FR4
	ASSUME  CDB_Q_RCV_IRP	EQ  8+CDB_Q_XMT_IRP
	ASSUME	CDB_Q_RCV_MSG	EQ  8+CDB_Q_RCV_IRP

	MOVL	#3,R1				; Set number of queue heads
20$:	MOVAL	(R2),(R2)			; Init forward link pointer
	MOVAL	(R2)+,(R2)+			; Init backward link pointer
	SOBGTR	R1,20$				; Loop if more queues

	ASSUME	CDB_L_SETMODE	EQ  8+CDB_Q_RCV_MSG
	ASSUME	CDB_L_ABSTIME	EQ  4+CDB_L_SETMODE
	ASSUME	CDB_W_BUFSIZ	EQ  4+CDB_L_ABSTIME
	ASSUME	CDB_W_STS	EQ  2+CDB_W_BUFSIZ

	CLRQ	(R2)+				; Init CDB_L_SETMODE,ABSTIME
	MOVZWL	UCB$W_DEVBUFSIZ(R5),(R2)+	; CDB_W_BUFSIZ and CDB_W_STS

	ASSUME	CDB_B_RCV_CNT	EQ  2+CDB_W_STS
	ASSUME	CDB_B_RCV_FQ	EQ  1+CDB_B_RCV_CNT
	ASSUME	CDB_B_TRB_ADDR	EQ  1+CDB_B_RCV_FQ
	ASSUME	CDB_B_STA	EQ  1+CDB_B_TRB_ADDR
	ASSUME	CDB_C_IDLE	EQ  0

	MOVB	UCB$B_RCV_CNT(R5),(R2)		; CDB_B_RCV_CNT (default)
	MOVB	(R2)+,(R2)+			; CDB_B_RCV_FQ  (default)
	MOVZBW	IRP$B_INDEX(R3),(R2)+		; CDB_B_TRB_ADDR, CDB_B_STA

	ASSUME	CDB_L_BRC	EQ  1+CDB_B_STA
	ASSUME	CDB_L_BSN	EQ  4+CDB_L_BRC
	ASSUME	CDB_L_DBR	EQ  4+CDB_L_BSN
	ASSUME	CDB_L_DBS	EQ  4+CDB_L_DBR

	CLRQ	(R2)+				; CDB_L_BRC and CDB_L_BSN
	CLRQ	(R2)+				; CDB_L_DBR and CDB_L_DBS
						;
	ASSUME	CDB_L_UCB	EQ  4+CDB_L_DBS
	ASSUME	CDB_L_CDT	EQ  4+CDB_L_UCB

	MOVL	R5,(R2)+			; CDB_L_UCB
	CLRL	(R2)+				; CDB_L_CDT
	MOVL	#1,R0				; Indicate success
100$:	RSB					; Done



	.SBTTL	SETMODE_CTRL,  Perform setmode FDT operation on controller
 
;++
; SETMODE_CTRL - Perform setmode FDT operation on controller
;
;
; This routine performs the SETMODE FDT setup for the controller.
;
; Inputs:	R3 = IRP address
;		R4 = PCB address
;		R5 = UCB address
;		R7 = IRP function word
;
; Outputs:	R0 = status of setmode request
;
;		R3-R5 are preserved.
;
;--
SETMODE_CTRL:					; Perform setmode on controller
	BBC	S^#IO$V_SHUTDOWN,R7,10$		; Br if not shutdown request
	;
	;  Shutdown modifier specified
	;
	BSBW	CAN_DEV				; Shutdown the device
	BRB	50$				; Finish the QIO with success
10$:	;
	;  Startup line modifier specified or no modifier
	;
	BBS	#UCB$V_CN_INITED,-		; Br if controller up already
		 UCB$W_DEVSTS(R5),40$
	;
	;  Validate P2
	;
	MOVAB	LINE_PRM_TABLE,R1		; Address of verif table
	MOVL	R5,R9				; Address of current param's
	MOVZWL	UCB$W_DEVSTS(R5),R2		; Status flags
	BSBW	VALIDATE_P2			; Validate P2 buffer
	BLBC	R0,70$				; If LBC, return R0,R1 in IOSB
	;
	;  Setup Maximum receive buffers
	;
	MOVZWL	#NMA$C_PCLI_BFN,R1		; Set to find MAX RCV
	BSBW	UNPACK_P2_BUF			; In P2 buffer
	BLBC	R0,30$				; Br if not found
	MOVB	R2,UCB$B_RCV_CNT(R5)		; Initialize number of RCV
30$:	;
	;  Setup Blocksize
	;
	MOVZWL	#NMA$C_PCLI_BUS,R1		; Get buffer size
	BSBW	UNPACK_P2_BUF			; From P2 buffer
	BLBC	R0,40$				; Br if not found
	MOVW	R2,UCB$W_DEVBUFSIZ(R5)		;  and in UCB
40$:	;
	;  Device initialized - then do a LISTEN if IO$V_STARTUP
	;
	BBC	S^#IO$V_STARTUP,R7,50$		; Finish up if not starting
	BSBB	LISTEN				; Do a LISTEN
	BLBC	R0,100$				; If LBC then failed
50$:	BRW	FINISH_SUC			; Finish - SS$_NORMAL for IOSB
70$:	BRW	FINISH_REQ			; Finish - R0,R1 for IOSB
100$:	BRW	ABORT_REQ			; Abort the I/O request

LISTEN:	;
	;  Do all the wonderful SCS magic needed to start up.  The buffer 
	;  created on the stack is pointed to by R7 in case the CONFIG_SYS
	;  macro is updated someday to modify SP as it pushes arguements.
	;
	;  NOTE: The following code assumes that we have only 1 CI port on
	;	 the current system!!!!!
	;

	SBO_LNG = SBO$C_LENGTH + 32		; SBO length plus random amount
						; of padding merely for merely
						; hysterical purposes.
	MOVL	R3,R9				; Save R3
	SUBL	#SBO_LNG,SP			; Create buffer on stack
						;
	MOVL	SP,R7				; Preserve value of buffer
	CONFIG_SYS  G^SCS$GB_SYSTEMID,(R7)	; Get our system block
	BLBC	R0,200$				; If LBC, not ready yet
	MOVB	SBO$B_RSTATION1(R7),-		; Get our port number
		UCB$B_CN_PORT(R5)		;
	BGEQ	210$				; If LSS then not ready yet
200$:	MOVZWL	#SS$_DEVOFFLINE,R0		; Device offline error	(no PA)
	BRB	220$				; Exit
210$:	MOVL	SB$L_PBCONNX(R1),R6		; Get path block
	MOVL	PB$L_PDT(R6),R6			; Pick up PDT
	MOVL	R6,UCB$L_PDT(R5)		; Save in UCB
	LISTEN	-				; Setup a LISTEN
		MSGADR = W^LIS_FORK,-
		ERRADR = W^LIS_ERR,-
		LPRNAM = PROC_NAM,-
		PRINFO = PROC_NAM
	BLBC	R0, 220$			; If LBC then error
	MOVL	R3,UCB$L_LIS_CDT(R5)		; Save listen CDT
	MOVL	R5,CDT$L_AUXSTRUC(R3)		; Set addr of UCB into CDT
	BISW	#UCB$M_CN_INITED,UCB$W_DEVSTS(R5) ; Indicate device inited
						;
220$:	ADDL	#SBO_LNG,SP			; Restore stack
	MOVL	R9,R3				; Restore IRP addr
	RSB

LIS_ERR:					; Error on LISTEN CDT
	DISCONNECT				; Put it back to listen
	RSB					; Leave


	.SBTTL	SENSEMODE_FDT,  Sense Mode I/O operation FDT routine

;++
; SENSEMODE_FDT - Sense Mode FDT routine
;
;  This routine returns information to the caller about the configuration
;  and status of the CI device.  Depending on the function modifier,
;  either the device characteristics or error counters contents are returned.
;
;  The QIO parameters for SENSEMODE are:
;
;	P2 = optional address of buffer descriptor for extended characteristics
;	
;
; Inputs:	R3 = IRP address
;		R4 = PCB address
;		R5 = UCB address
;		R6 = CCB address
;		R7 = Function code
;		AP = Address of first function-dependent QIO parameter
;
; Outputs:	R0 = status return of sensemode request
;
;		R3-R5 are preserved.
;
;--
SENSE_TABLE:					; Setup list of offset to 
	.WORD	SENSE_TABLE - TRIB_PRM_TABLE	;   parameter tables with using
	.WORD	SENSE_TABLE - TRIB_CNT_TABLE	;   the following 2 bit index:
	.WORD	SENSE_TABLE - LINE_PRM_TABLE	;
	.WORD	SENSE_TABLE - LINE_CNT_TABLE	;	bit 0 set => counters
						;	bit 1 set => non-trib

SENSEMODE_FDT:					; Sensemode FDT I/O processing
	SENSE_C_BUF = 128
	
	ASSUME	TRIB_PRM_NUM*6  LE  SENSE_C_BUF	; Make sure buffer can hold all
	ASSUME	LINE_PRM_NUM*6  LE  SENSE_C_BUF	; info for all cases
	ASSUME	TRIB_CNT_NUM*6  LE  SENSE_C_BUF
	ASSUME	LINE_CNT_NUM*6  LE  SENSE_C_BUF
	;
	;  Check user buffer.  Get system buffer.  Setup IRP
	;
	MOVW	#SENSE_C_BUF,IRP$L_IOST1+2(R3)	; Setup buff size needed
	BSBW	GET_CHAR_RBUF			; Setup "read" buff for IOPOST
						; - no return on error
	MOVZWL	IRP$W_FUNC(R3),R7		; Get full function code.
	MOVL	IRP$L_IOST2(R3),4(R2)		; Store user buffer virt addr 
						; in standard place in buffer
	MOVL	(R2),R2				; Get pointer to data area 
	;
	;  Locate parameter/counter table
	;
	MOVL	#3,R6				; Init SENSE_TABLE index
	MOVL	#COUNT_C_ENTRY-2,R8		; Bias COUNTER table entry size
	BBS	#IO$V_RD_COUNT,R7,10$		; If BS, "read counter" request
	DECB	R6				; Erase "read counter" bit
	MOVL	#PARAM_C_ENTRY-2,R8		; Bias PARAM table entry size
	BBCC	#IO$V_RD_COUNT,R7,10$		; Clear out garbage modifier
10$:	MOVL	R5,R9				; If IO$V_CTRL, use UCB source
	BBS	#IO$V_CTRL,R7,20$		; If BS, not for a tributary
	BICB	#2,R6				; Erase "non-tributary" flag
	BSBW	XLATE				; Locate CDB, use CDB source
	BLBC	R0,100$				; If LBC then CDB not found
20$:	CVTWL	SENSE_TABLE[R6],R0		; Get offset to parameter table
	MOVAB	SENSE_TABLE,R6			; Get address of base
	SUBL	R0,R6				; Calculate table address
30$:	;
	;  Fill buffer with requested information
	;
	MOVW	(R6)+,R1			; Get parameter i.d.
	BEQL	60$				; If EQL, at end of table
	BBS	#IO$V_RD_COUNT,R7,40$		; If BS then counter i.d.
	BICW	#^C<PRM_M_TYPE>,R1		; Else param i.d.,  clear junk
40$:	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,(R6),R4  ; Get source offset
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,(R6),R0  ; Get source width
	BEQL	50$				; If EQL, ignore this param
	ADDL	R9,R4				; Calculate source address
	MOVW	R1,(R2)+			; Enter parameter i.d.
	EXTZV	#0,R0,(R4),(R2)+		; Enter parameter value
	BBC	#IO$V_CLR_COUNT,R7,50$		; If BC, don't clear source
	INSV	#0,#0,R0,(R4)			; Clear counter
50$:	ADDL	R8,R6				; Advance to next entry
	BRB	30$				; Loop
60$:	;
	;  Setup status and transfer size
	;
	SUBL	@IRP$L_SVAPTE(R3),R2		; Calculate bytes moved
	CMPL	R2,#SENSE_C_BUF			; Was our buffer large enough ?
	BGTRU	200$				; If GTRU no
	MOVW	#SS$_NORMAL,IRP$L_IOST1(R3)	; Assume success
	CMPW	IRP$W_BCNT(R3),R2		; User buffer big enough ?
	BGEQU	80$				; If GEQU then yes
	MOVW	#SS$_BUFFEROVF,IRP$L_IOST1(R3)	; Show warning
	MOVW	IRP$W_BCNT(R3),R2		; Shrink xfer size
80$:	MOVW	R2,IRP$L_IOST1+2(R3)		; Move xfer size to IOSB image
	MOVW	R2,IRP$W_BCNT(R3)		; Setup xfer size for IOPOST
	MOVL	IRP$L_IOST1(R3),R0		; Set length/status	
100$:	BRW	FINISH_ERR			; Leave setting R0 in IOSB

200$:	BUG_CHECK  INCONSTATE,FATAL		; We've corrupted pool

	.SBTTL	GET_CHAR_RBUF,  Get P2 characteristics buffer for read
	.SBTTL	GET_CHAR_WBUF,  Get P2 characteristics buffer for write
 
;++
; GET_CHAR_RBUF - Get P2 characteristics buffer for read
; GET_CHAR_WBUF - Get P2 characteristics buffer for write
;
; This routine saves the address of P2 buffer for later use by the driver.
; The P2 buffer address is saved in IRP$L_IOST2 of the IRP, and the size
; in IRP$L_BCNT.
;
; Inputs:	R3 = IRP address
;		R4 = PCB address
;		R5 = UCB address
;
; Outputs:	R0 = Garbage
;		R1 = User buffer size
;		R3-R5 are preserved.
;
;--
GET_CHAR_RBUF:					; Get P2 char buffer for "read"
	BISB	#IRP$M_FUNC,IRP$W_STS(R3)	; Mark IRP for "read"
GET_CHAR_WBUF:					; Get P2 char buffer for "write"
	CLRQ	R0				; Setup null user buffer
	MOVL	P2(AP),R2			; Get address of P2 desc
	BEQL	10$				; If EQL, no P2 was specified
	EXTZV	#0,#2,IRP$B_RMOD(R3),R0		; Get access mode
	IFNORD	#8,(R2),50$,MODE=R0		; Br if no read access
	MOVZWL	(R2),R1				; Get buffer length in bytes
	MOVL	4(R2),R0			; Get buffer address
10$:	MOVL	R0,IRP$L_IOST2(R3)		; Save it for later
	TSTW	R1				; Null user buffer ?
	BEQL	30$				; If EQL yes, don't probe
	PUSHAB	B^30$				; Setup return address
	BBC	#IRP$V_FUNC,IRP$W_STS(R3),20$	; If BC then "write"
	JMP	G^EXE$READCHK			; Check user buffer, setup IRP
20$:	JMP	G^EXE$WRITECHK			; Check user buffer, setup IRP
						; - no return on error
30$:	BBC	#IRP$V_FUNC,IRP$W_STS(R3),40$	; If BC then "write"
	MOVZWL	IRP$L_IOST1+2(R3),R1		; Get required buffer size
40$:	BSBW	GET_BUF				; Get buffer
	SETIPL	UCB$B_FIPL(R5)			; Raise IPL
	BLBS	R0,60$				; Okay if LBS
50$:	MOVZWL	#SS$_ACCVIO,R0			; Set error status
	BRW	ABORT_REQ			; Abort the I/O request
60$:	RSB


	.SBTTL	START_TRIB,  Start tributary routine

;++
; START_TRIB - Start tributary routine
;
;
; This routine is called when a tributary is to be established and started.
; The control parameters are initialized also.
;
;  Inputs:	R3 = IRP address
;		R5 = UCB address
;		R9 = CDB address
;
;		IPL = FIPL.
;
;  Outputs:	R5 is preserved.
;
;
;--
START_TRIB:					; Start tributary
	;
	;  Setup number of receive buffers
	;
	MOVZWL	#NMA$C_PCCI_MRB,R1		; Get param i.d.
	BSBW	UNPACK_P2_BUF			; Get param value
	BLBS	R0,20$				; If LBS then param was there
	MOVZBL	UCB$B_RCV_CNT(R5),R2		; Else, get default
20$:	CMPB	R2,#RBFMIN			; Are there enough buffers to
	BGTRU	30$				; reduce datagram loss ?
	MOVL	#RBFMIN,R2			; If not, do user a favor
30$:	CMPL	#RBFMAX,R2			; Too many ?
	BGTRU	40$				; If GTRU then no
	MOVL	#RBFMAX,R2			; Use safer minimum
40$:	MOVB	R2,CDB_B_RCV_CNT(R9)		; Setup receive pool accounting
	MOVB	R2,CDB_B_RCV_FQ(R9)		; List starts out full
	;
	;  Init CDB state.
	;
	MOVL	#^A/PAA0/,IRP$B_INDEX+8(R3)	; Set to connect over local
						;  port PAA0
	MOVB	#CDB_C_LSTN,CDB_B_STA(R9)	; Assume "listen" state
	CMPB	UCB$B_CN_PORT(R5),-		; Compare our address to
		IRP$B_INDEX(R3)			; remote's address
	BLSSU	100$				; If LSSU, stay in "listen" 
	BGTRU	50$				; If GTRU, initiate connect
	CLRL	R2				; Else we're talking to 
						; ourselves -- zero rcv buffers
	BRB	60$				; CONNECT from "LSTN" state
50$:	MOVB	#CDB_C_CONN,CDB_B_STA(R9)	; Else, go to "connect" state
60$:	BBSS	#CDB_V_CONN,CDB_W_STS(R9),200$	; Indicate waiting return from
						; CONNECT
	PUSHL	R5				; Save UCB address
	MOVL	R9,R5				; Use CDB for CONNECT context
	BSBB	CONN				; Post connect request to SCS
	POPL	R5				; Restore UCB address
	BBC	#CDB_V_CONN,CDB_W_STS(R9),100$	; If BC, completed synchronously 
	MOVL	R3,CDB_L_CDT(R9)		; Set pointer to open CDT 
100$:	RSB					; Done

200$:	BUG_CHECK  INCONSTATE,FATAL		; Bug if already set

CONN:	MOVZBL	CDB_B_RCV_CNT(R9),R0		; Pick up rcv buffer count
	CONNECT	-				; Request a CONNECT
		MSGADR = W^MSG_FORK,-		; Message address
		DGADR  = W^DG_FORK,-		; Psuedo interrupt routine
		ERRADR = W^CONN_ERR,-		; Connect errors
		RSYSID = 0,-			; No remote system specified
		RSTADR = IRP$B_INDEX(R3),-	; Virtual circ to connect over
		RPRNAM = PROC_NAM,-		; To whom we will speak
		LPRNAM = PROC_NAM,-		; Our name
		INITCR = #1,-			; Allow for messages
		INITDG = R2,-			; Number of receive buffers
		CONDAT = CONN_DATA,-		; Connect data
		AUXSTR = (R5)			; Auxiliary structure
	;
	;  Control returns to caller's caller - the JMP G^EXE$QIORETURN.
	;  When the connection completes, the following is called as a fork
	;  process NOT necessarily in the context of process.
	;
	;	R0  =	Status code
	;	R1  =	Reject reason if status = reject
	;	R2 -->	ACCEPT_REQ msg if status = success
	;	R3 -->	Connection CDT
	;	R4 -->	PDT
	;	R5 -->  CDB
	;
	CLRBIT	#CDB_V_CONN,CDB_W_STS(R5)	; No longer awaiting CONN return
	BLBC	R0,20$				; If LBS then error
	BSBW	CHECK_REMOTE			; Check remote's connect info
	BNEQ	10$				; If NEQ, can't talk to remote
	BRW	CONN_FIN			; Else okay, complete setup
10$:	DISCONNECT				; Break the connection
20$:	CLRL	CDB_L_CDT(R5)			; Forget about CDT, if any

CONN_ABO:
	;
	;  CONNECT or ACCEPT failed.  
	;
	;  If we were to return an error immediately every time, the higher
	;  level user (NETACP) would consume too much time trying to restart
	;  the circuit.  This is because the CI, unlike other devices, will
	;  return immediately if the partner is not ready on a CONNECT
	;  attempt.   For all other devices, the connect remains pending
	;  indefinitely.
	;	
	;  Therefore, in order to save CPU cycles, simply return and allow the
	;  IO$M_STARTUP $QIO to hang indefinitely.  This forces NETACP to 
	;  initiate the subsequent cleanup via a $CANCEL, $DASSGN, or 
	;  IO$M_SHUTDOWN.  This should be fixed someday to have CNDRIVER retry
	;  every 5 seconds or so without reporting an error.
	;
	;
	;	*** NOTE:  This logic here has been retained in case it needs
	;		   to be reactivated someday.  However, it has been
	;		   found that not returning an error immediately can
	;		   cause some confusion since it can delay a circuit
	;		   initialization for 3 minutes or so in some cases.
	;		   In addition, the time spent by NETACP to continually
	;		   reinitialize the circuit has been found to be small
	;		   enough that it presents no real problem.
	;
	;
	TSTW	CDB_W_STS(R5)			; All quiet yet ?
	BNEQ	100$				; If NEQ, just wait
	MOVL	CDB_L_UCB(R5),R0		; Get UCB address
	BBS	#UCB$V_POWER,UCB$W_STS(R0),50$	; If BS, powerfial recovery
	INCB	CDB_B_RSTCNT(R5)		; Another restart attempt
	BITB	#3,CDB_B_RSTCNT(R5)		; Is this the 4th phase ?
;	BEQL	100$				; If EQL yes, wait.
	NOP
	NOP
50$:	MOVL	R5,R4				; Copy CDB address
	BSBW	ZAP_CDB				; Report the error immediately
100$:	RSB					; Wait the qio until contacted
						; by user via $CANCEL, etc


	.SBTTL	LIS_FORK, Listen action routine

;++
; LIS_FORK - Listen action routine
;
;
; This routine is entered as a fork process activated by the PADRIVER
; when some other process has sent a CONNECT to us.  We can then decide
; to ACCEPT or REJECT the connection.
;
; Inputs:	R2 -->	CONNECT_REQ message
;		R3 -->	Listening CDT
;		R4 -->	PDT
;
;		IPL = FIPL
;
;--
LIS_FORK:
	MOVL	CDT$L_AUXSTRUC(R3),R5		; Pick up UCB from listen CDT
	MOVZBL	CDT$B_RSTATION(R3),R1		; Get other guy's port
	MOVL	UCB$L_VEC_CDB(R5)[R1],R5	; Pick up the CDB
	BEQL	REJECT				; We don't have one, reject
	CMPB	CDB_B_STA(R5),#CDB_C_LSTN	; Are we listening on this trib
	BNEQ	REJECT				; If NEQ no, reject connection
	BSBW	CHECK_REMOTE			; Process connect data
	BEQL	ACCEPT				; If NEQ then from DECnet SYSAP
REJECT:	;
	;  REJECT the connection.
	;
	CLRL	R5				; Forget about CDB
	MOVL	#SS$_NORMAL,R0			; Reject reason
	REJECT					; Yes, reject him - return to
						; caller's caller.
	RSB					; Return to SCS (nop)

ACCEPT:	;
	;  ACCEPT the connection.
	;
	MOVZBL	CDB_B_RCV_CNT(R5),R0		; Pick up rec buf count
	MOVB	#CDB_C_ACPT,CDB_B_STA(R5)	; Change state to "accept"
	SETBIT	#CDB_V_ACPT,CDB_W_STS(R5)	; Inidicate ACCEPT pending
	ACCEPT	-				; ACCEPT the connection
		MSGADR	= W^MSG_FORK,-		; Message address
		DGADR	= W^DG_FORK,-		; Psuedo interrupt rtn
		ERRADR	= W^CONN_ERR,-		; Error address
		INITCR	= #1,-			; Allow for messages
		INITDG	= R0,-			; Receive buffers
		CONDAT	= CONN_DATA,-		; Accept data
		AUXSTR	= (R5)			; Auxiliary strucure (CDB)
	;
	;  Control returns to caller's caller if this request does not complete
	;  synchronously.  In that case, when the ACCEPT completes, the 
	;  following is called as a fork process NOT necessarily in the context
	;  of user's process.
	;
	;	R0  =	Status
	;	R1  =	?
	;	R2 -->  ACCEPT_RSP message
	;	R3 -->	CDT
	;	R4 -->	PDT
	;	R5 -->	CDB
	;		
	CLRBIT	#CDB_V_ACPT,CDB_W_STS(R5)	; ACCEPT no longer pending
	BLBC	R0,50$				; If LBC then failed
	MOVL	CDB_L_UCB(R5),R0		; Get UCB
	CMPB	CDT$B_RSTATION(R3),-		; Are we talking to ourselves?
		UCB$B_CN_PORT(R0)		;
	BNEQ	CONN_FIN			; If NEQ no, complete setup
	MOVL	R3,UCB$L_TWIN_CDT(R0)		; Else setup TWIN CDT
	BRB	CONN_FIN1			; Finish processing without
						; storing CDT in CDB
50$:	MOVL	R2,R3				; Copy CDT to right register
	MOVZWL	#SS$_REMRSRC,R0			; REJECT reason
	SETBIT	#CDB_V_REJECT,CDB_W_STS(R5)	; Set REJECT in progress
	REJECT					; Must REJECT on ACCEPT failure
	CLRBIT	#CDB_V_REJECT,CDB_W_STS(R5)	; Return is to caller's caller
						; - return here after a delay
						;   with R5 pointing to CDB
	BRW	CONN_ABO			; Go to common code.

100$:	BUG_CHECK  INCONSTATE,FATAL


;
; CONNECT (or ACCEPT) succeded
;
; If no status bits are set then enter the "run" state and complete the
; pending IO$M_STARTUP request.  If any status bits are set  -- which can 
; happen if we are talking to ourselves since we do both an ACCEPT and a
; CONNECT in that case -- then wait.
;
CONN_FIN:
	MOVL	R3,CDB_L_CDT(R5)		; Set ptr to CDT
CONN_FIN1:
	MOVL	R5,R4				; Copy CDT address
	CLRB	CDB_B_RSTCNT(R4)		; Init failed restart counter
	CLRL	CDB_L_ABSTIME(R4)		; Don't inhibit DISCONNECT
	MOVL	CDB_L_UCB(R4),R5		; Restore UCB pointer
	BICW	#UCB$M_POWER,UCB$W_STS(R5)	; Any powerfail recovery is done
	TSTW	CDB_W_STS(R4)			; All quiet ?
	BNEQ	40$				; If NEQ no, wait
	MOVL	CDB_L_SETMODE(R4),R3		; Get SETMODE IRP
	BEQL	50$				; If EQL then none
	CLRL	CDB_L_SETMODE(R4)		; Detach IRP from CDB
	BBC	#IO$V_STARTUP,IRP$W_FUNC(R3),50$; If BC then wrong IRP
	MOVB	#CDB_C_OPEN,CDB_B_STA(R4)	; Update current state
	SETBIT	#CDB_V_RUN, CDB_W_STS(R4)	; Allow data message traffic
	MOVZWL	#SS$_NORMAL,R0			; Setup status
	BSBW	SUC_TRB_IOPOST			; Post IRP with "success"
40$:	RSB

50$:	BUG_CHECK INCONSTATE,FATAL

CHECK_REMOTE:					; Check remote connect data
	;
	;
	;   0-15(R2)  Contain our process name (who remote is connecting to)
	;  16-31(R2)  Contain remote's process name
	;  32-47(R2)  Contain connect data
	;
	PUSHR	#^M<R0,R2,R3,R4>		; Save some registers
						;
	MOVL	R2,R4				; Make stable msg pointer
	MOVW	#OLD_C_PROT,CDB_W_REMPROT(R5)	; Assume remote is old protocol
	CMPC3	#PROC_C_NAM,PROC_NAM,32(R4)	; Check the connect data
	BEQL	10$				; If EQL then old style
	MOVW	32(R4),CDB_W_REMPROT(R5)	; Pickup version + system id's
10$:	CMPC3	#PROC_C_NAM,PROC_NAM,16(R4)	; Check the connect proc nam
						;
	POPR	#^M<R0,R2,R3,R4>		; Restore regs (but save CC's)
	RSB					; Return condition codes

;
;
; Error after connection established - VC disconnect most likely.  
;
; If the CDT is the UCB$L_TWIN_CDT then simply do a DISCONNECT.  This CDT is 
; used for receives on connects to ourselves.  SCS will call us again for the
; other half of that connection with the local CDB's CDT -- at that time, as
; in all other cases, we will run-down the CDB.
;
;  Inputs:
;	R0  =  Status
;	R3 --> CDT
;	R4 --> PDT
;
CONN_ERR:
	MOVL	CDT$L_AUXSTRUC(R3),R4	; Pick up associated CDB
	MOVL	CDB_L_UCB(R4),R5	; Pick up UCB address
	CMPL	R3,UCB$L_TWIN_CDT(R5)	; Is this the "local receive" CDT ?
	BNEQ	ZAP_CDB			; If NEQ no, ZAP the CDB
	CLRL	UCB$L_TWIN_CDT(R5)	; Else, detach it from the UCB
	MOVL	CDT$L_PDT(R3),R4	; Recover the PDT
	DISCONNECT			; Tell SCS to cleanup.
	RSB				; Done


	.SBTTL	CANCEL,  Cancel I/O routine

;++
; CANCEL, Cancels an I/O operation in progress
;
;
; This routine cancels all I/O on the tributary.
;
; Inputs:	R2 = channel number 
;		R3 = current IRP address
;		R4 = PCB address 
;		R5 = UCB address
;		R8 = Cancel reason code:  0 => $CANCEL;  1 => $DASSGN
;
;		IPL = FIPL
;
; Outputs:	R0-R3 are destroyed.
;
;
;--
CANCEL:					; Cancel an I/O operation
	PUSHR	#^M<R4,R9>		; Save registers
					;
	MOVL	R2,R0			; Copy channel number
	BSBW	XLATE_CHAN		; Translate channel
	BLBC	R0,20$			; Br if none
	CMPL	R8,#1			; $DASSGN ?
	BNEQ	10$			; If NEQ then no
	MOVZBL	CDB_B_TRB_ADDR(R9),R0	; Pick up trib address
	CLRW	UCB$W_VEC_CHAN(R5)[R0]	; Zero channel entry
10$:	BSBB	ZAP_CDB_R9		; Clear all CDB I/O
					;
20$:	POPR	#^M<R4,R9>		; Restore registers
	TSTW	UCB$W_REFC(R5)		; Last reference to unit?
	BEQL	CAN_DEV			; If EQL yes, shutdown the device
	RSB				; Return to caller


	.SBTTL	CAN_DEV,  Device shutdown routine

;++
; CAN_DEV -  Device shutdown routine
;
;
; This routine is called to shutdown the CI device.  All tributaries are
; zapped so that they will eventually run-down and be deleted.
;
; Inputs:	R3 = IRP address
;		R5 = UCB address
;
;		IPL = FIPL
;
; Outputs:	R0-R2 are clobbered.
;
;
;--
CAN_DEV:					; Shutdown the device
	BBCC	#UCB$V_CN_INITED,-		;
		UCB$W_DEVSTS(R5),50$ 		; Br if dev not inited
	PUSHR	#^M<R3,R4,R5>			;
	;
	;  Zap each tributary
	;
	MOVL	#MAX_TRB-1,R3			; Loop counter (zero indexed)
20$:	MOVL	UCB$L_VEC_CDB(R5)[R3],R4	; Get next CDB
	BEQL	30$				; Br if none
	BSBB	ZAP_CDB				; Cancel all I/O on trib
30$:	SOBGEQ	R3,20$				; Loop
	;
	;  Remove our listener
	;
	MOVL	UCB$L_LIS_CDT(R5),R3		; Pick up listening CDT
	BEQL	40$				; None
	CLRL	UCB$L_LIS_CDT(R5)		;  and clear any trace
	MOVL	UCB$L_PDT(R5),R4		; PDT address, just in case
	DISCONNECT				; Clear our name out of table
40$:	;
	;  Clean up the UCB
	;
	BICW2	#^C<UCB$M_ONLINE!UCB$M_POWER>,- ;
		UCB$W_STS(R5)			; Reset status
						;
	POPR	#^M<R3,R4,R5>			; Restore registers
50$:	RSB					; Return

	.SBTTL	ZAP_CDB,  Shutdown the tributary
 
;++
; ZAP_CDB    - Shutdown the tributary
; ZAP_CDB_R9 - Shutdown the tributary, get CDB address from R9
;
;
; This routine is called to abort all I/O pending for this tributary.
;
;    1) Disconnect the Virtual Circuit
;    2) Cancel all outstanding I/O, abort all IRP, deallocate rcv'd buffers.
;    3) Idle the CDB.
;
; Inputs:	R9 = CDB address (ZAP_CDB_R9 only, else not used)
;		R5 = UCB address
;		R4 = CDB address (ZAP_CDB only, else garbage)
;	
;		IPL = FIPL
;
; Outputs:	R0-R1 are destroyed.
;
;--
ZAP_CDB_R9:	MOVL	R9,R4			; Setup proper CDB pointer
ZAP_CDB:
	;
	;  If a DISCONNECT is issued on a connection that already has a
	;  DISCONNECT pending, SCS thinks that something is wrong the port
	;  and disconnects all circuits using it.  Therefore, make sure
	;  we do not issue a second DISCONNECT for at least 10 seconds after
	;  the last one was issued.  That should be enough time for normally
	;  functioning circuits to complete a DISCONNECT dialogue.  If the
	;  DISCONNECT is still pending after 10 seconds, its probably okay
	;  to try it again in order to allow the user to run-down all I/O on
	;  this channel.
	;
	TSTL	CDB_L_CDT(R4)			; Any CDT connected ?
	BEQL	2$				; If EQL, no DISCONNECT needed
	SUBL3	CDB_L_ABSTIME(R4),-		; Get seconds since last
		G^EXE$GL_ABSTIM,R0		; DISCONNECT
	CMPL	R0,#10				; At least 10 seconds?
	BLSSU	3$				; If LSSU can't DISCONNECT
						;
2$:	PUSHR	#^M<R2,R3,R4,R5>		; Save regs
	BSBB	5$				; Use subr call so that SCS's
						; DISCONNECT code can return to
						; a caller's caller
	POPR	#^M<R2,R3,R4,R5>		; Restore regs
3$:	RSB					; Done

5$:	;
	;
	;  DISCONNECT may return to our caller before returning here since SCS
	;  has to enter into a dialogue with the remote node.  Therefore, the
	;  stack must be clear.  
	;
	;  FORK immediately after returning from the DISCONNECT in order to
	;  make sure SCS will return all Xmt IRPs it knows about before we
	;  return the ones that are left.  This is not usually necessary since
	;  in most cases SCS will queue the DISCONNECT completion to the end of
	;  its own fork queue after all Xmt completion notifications have been
	;  queued.
	;
	;  If CDB_V_DISC is already set, then there is a DISCONNECT or FORK
	;  already in progress.  Do the DISCONNECT again, in case SCS is stuck,
	;  but simply return since the previous DISCONNECT will complete and
	;  the processing will continue from there.
	;
	CLRBIT	#CDB_V_RUN,CDB_W_STS(R4)	; No longer in RUN state
	MOVL	R4,R5				; Save CDB pointer over call
	MOVL	CDB_L_CDT(R5),R3		; Pick up CDT address
	BNEQ	10$				; If NEQ then CDT was there
	BBCS	#CDB_V_DISC,CDB_W_STS(R5),30$	; FORK to continue
	RSB					; Return if already FORKing
						;
10$:	MOVL	CDT$L_PDT(R3),R4		; Pick up PDT address	
	MOVL	G^EXE$GL_ABSTIM,CDB_L_ABSTIME(R5) ; Save DISCONNECT start time
	BBCS	#CDB_V_DISC,CDB_W_STS(R5),20$	; Show we are disconnecting
	DISCONNECT #0				; Tell SCS to do it again
	RSB					; Done
						;
20$:	DISCONNECT #0				; Do it
30$:	JSB	G^EXE$FORK			; FORK to synchronize cleanup
	MOVL	R5,R4				; Recover CDB address
	MOVL	CDB_L_UCB(R4),R5		; Recover UCB address
	SETIPL	UCB$B_FIPL(R5)			; Sync with UCB	
	CLRBIT	#CDB_V_DISC,CDB_W_STS(R4)	; Show we are back
	BSBB	40$				; Finish processing
	SETIPL	#CDB_C_FIPL			; Restore IPL
	RSB

40$:	;
	;  Complete pending IO$_SETMODE, if any
	;
	CLRL	CDB_L_CDT(R4)			; Get rid of any trace
	MOVL	CDB_L_SETMODE(R4),R3		; Recover IRP
	BEQL	50$				; None there
	CLRL	CDB_L_SETMODE(R4)		; Remove it from the CDB
	MOVQ	S^#SS$_NORMAL,R0		; Assume IO$V_SHUTDOWN
	BBC	#IO$V_SHUTDOWN,IRP$W_FUNC(R3),60$ ; If BC then IO$V_STARTUP
	BSBW	IOPOST				; Send IRP to IOPOST

50$:	;
	;  Complete all Receive IRP's
	;
	REMQUE	@CDB_Q_RCV_IRP(R4),R3		; Get next RCV IRP
	BVS	70$				; If VS then none
60$:	BSBW	ABORT_IRP_POST			; Abort the I/O request
	BRB	50$				; Get next entry

70$:	;
	;  Deallocate all Receive buffers
	;
	REMQUE	@CDB_Q_RCV_MSG(R4),R0		; Get next buffer
	BVS	80$				; If VS then empty
	BSBB	DEALLMEM			; Get rid of it
	BRB	70$				; Get next entry

80$:	;
	;  Complete all Transmit IPR's
	;
	REMQUE	@CDB_Q_XMT_IRP(R4),R3		; Get next IRP
	BVS	90$				; If VS then none
	BSBW	ABORT_IRP_POST			; Abort the I/O request
	BRB	80$				; Loop

90$:	;
	;  Idle the CDB
	;
	MOVB	#CDB_C_IDLE,CDB_B_STA(R4)	; Reinit CDB state
	RSB


	.SBTTL	MSG_FORK,  Fork process for receipt of Seq Messages

;++
; MSG_FORK - Process received MSG
;
; Inputs:
;
;	R1  =	Bytes send/received
;	R2 -->	Start of user data
;	R3 -->	CDT
;	R4 -->	PDT
;
;	IPL =	FIPL
;
; Outputs:
;
;--
MSG_FORK:
	DEALLOC_MSG_BUF_REG			; Deallocate the message buffer
	RSB


	.SBTTL	DG_FORK,  Fork process for receipt of DG

;++
; DG_FORK - Process received DG
;
; Inputs:
;
;	R0  =   0 - Received a DG
;	    =	1 - Transmit finished
;	R1  =	Bytes send/received
;	R2 -->	Start of user data
;	R3 -->	CDT
;	R4 -->	PDT
;
;	IPL =	FIPL
;
; Outputs:
;
;--
DG_FORK:
	MOVL	CDT$L_AUXSTRUC(R3),R4		; Pick up pointer to CDB
	BEQL	EMPTY				; Closed CDB, discard
	SUBL3	#1,R2,R3			; Make a biased copy of msg ptr
	SUBL	#32,R2				; Reset R2 to head of PPD buffer
	CVTWL	8(R2),R5			; Get offset to CXB header
	BGEQ	20$				; If GEQ then bug
	ADDL	R5,R2				; Reset R2 to head of CXB buffer
						;
10$:	INCL	R3				; Advance to next byte
	CMPB	#-1,(R3)			; Pad byte ?
	BNEQ	DG				; If NEQ not pad byte
	DECL	R1				; Reduce count
	BGTR	10$				; If LEQ then no data

20$:	BUG_CHECK  INCONSTATE,FATAL		; Illegal offset
						;	
EMPTY:	MOVL	R2,R0				; Pick up buffer
DEALLMEM:					;
	JMP	G^COM$DRVDEALMEM		; Deallocate buffer
						;
DG:	;
	;  Update counters
	;
	ASSUME	CDB_L_BSN EQ 4+CDB_L_BRC
	ASSUME	CDB_L_DBR EQ 4+CDB_L_BSN
	ASSUME	CDB_L_DBS EQ 4+CDB_L_DBR

	MOVAB	CDB_L_BRC(R4),R5		; Point to receive counter base
	BLBC	R0,5$				; If LBC, then rcv
	ADDL	#4,R5			; Adance to xmt counter base
5$:	ADDL	R1,(R5)				; Update byte count
	BCC	10$				; Br if no overflow
	MNEGL	#1,(R5)				; Else, latch it
10$:	INCL	8(R5)				; Update message count
	BCC	20$				; If CC, no overflow
	MNEGL	#1,8(R5)			; Else, latch it
20$:	MOVL	CDB_L_UCB(R4),R5		; Pick up ptr to UCB
	BLBS	R0,SEND_FORK			; IF LBS then xmt complete
	;
	;  RECEIVE complete - if there is a pending receive I/O request, 
	;  complete it.  Otherwise, queue the buffer.
	;
	ASSUME	CDB_V_RUN  EQ  0		;
	BLBC	CDB_W_STS(R4),EMPTY		; Br if trib not in RUN state
	DECB	CDB_B_RCV_FQ(R4)		; Dec the buffer count
	SUBW3	R2,R3,CXB$W_OFFSET(R2)		; Store offset to message
	MOVW	R1,CXB$W_LENGTH(R2)		; Set size
	REMQUE	@CDB_Q_RCV_IRP(R4),R3		; Remove waiting IRP
	BVC	FINISH_RCV_IO			; If VC then gone one, finish
						;  the I/O & exit
	INSQUE	(R2),@CDB_Q_RCV_MSG+4(R4)	; Queue receive msg for late
	BRW	FILLRCVLIST			; Fill the receive buffer pool

SEND_FORK:
	;
	;  TRANSMIT completed.  Locate and deque XMIT IRP and post it.
	;
	;  NOTE: the IRP's may be returned out of sequence on a power fail.
	;
	ROTL	#16,R1,R0			; Size in R0 high word
	MOVW	#SS$_NORMAL,R0			; Status in low word
	MOVAB	CDB_Q_XMT_IRP(R4),R1		; Address queue header
	MOVL	R1,R3				; Make a copy
20$:	MOVL	(R3),R3				; Get next IRP
	CMPL	R3,R1				; Back to head of queue?
	BEQL	50$				; If EQL then yes, bugcheck
	CMPL	R2,IRP$L_SVAPTE(R3)		; Buffer address match ?
	BNEQ	20$				; If NEQ no, try again
	REMQUE	(R3),R3				; Remove IRP from queue
	BRB	SUC_TRB_IOPOST			; Complete the I/O with trib
						; info stuffed into IOST2

50$:	BUG_CHECK  INCONSTATE,FATAL


	.SBTTL	FINISH_RCV_IO,  Finish receive I/O processing

;++
; FINISH_RCV_IO - Finish receive I/O processing
;
;
; This routine finishes receive processing and sends the IRP back to IOPOST.
; The receive free list is filled and a receive is started if needed.
;
;  Inputs:	R2 = message buffer address
;		R3 = IRP address
;		R4 = CDB address
;		R5 = UCB address
;
;		IPL = FIPL
;
;  Outputs:	R0-R4 are clobbered.  All other registers are preserved.
;
;
;--
FINISH_RCV_IO:				; Finish recieve I/O request
	MOVL	R2,IRP$L_SVAPTE(R3)	; Save block address
	MOVZWL	CXB$W_OFFSET(R2),(R2)	; Store offset to message
	ADDL	R2,(R2)			; Make it a pointer
	MOVL	IRP$L_IOST2(R3),4(R2)	; Set address of user buffer
	MOVW	CXB$W_LENGTH(R2),R1	; Get size of transfer
	CMPW	R1,IRP$W_BCNT(R3)	; Request larger than actual?
	BGTRU	10$			; Br GTRU then yes
	MOVW	R1,IRP$W_BCNT(R3)	; Set size to transfer
10$:	MOVL	IRP$W_BCNT-2(R3),R0	; Setup size of xfer in high word
	MOVW	#SS$_NORMAL,R0		; Setup status in low word
	BNEQ	SUC_TRB_IOPOST		; Br if success
	MOVZWL	#SS$_CTRLERR,R0		; Set data path error
	CLRL	R1			; Init second longword
	BRB	IOPOST			; Post it
 
ABORT_IRP_POST:
	MOVQ	S^#SS$_ABORT,R0		; Setup IOSB image
	BRB	IOPOST			; Finish up


SUC_TRB_IOPOST:				; Successful Trib I/O completion
	MOVL	#XM$M_STS_ACTIVE!-	; Set device dependent bits to indicate
		 XM$M_STS_RUNNING,R1	; that the circuit is running
	CMPB	#RBFTHR,CDB_B_RCV_FQ(R4); Receive queue under threshold ?
	BLEQU	IOPOST			; If LEQU then no
	BISL	#XM$M_STS_BUFFAIL,R1	; Signal buffer threshold problems
IOPOST:	MOVQ	R0,IRP$L_IOST1(R3)	; Store IOSB image
	JMP	G^COM$POST		; Post IRP


	.SBTTL	FILLRCVLIST,  Fill receive buffer list
	.SBTTL	ADDRCVLIST,   Move IRP buffer to free list
;++
; FILLRCVLIST - Add to the receive buffer list
; ADDRCVLIST  - Add IRP buffer to free list
;
; This routine is entered to make sure that the receive buffer pool is full.  
; If it is not, buffers are allocated and queued to the list until it is.
;
; For ADDRCVLIST, any buffer attached to the IRP is added to the free list
; even if the list is already filled.
;
; Inputs:	R3 - IRP address (ADDRCVLIST only)
;		R4 - CDB address
;		R5 - UCB address
;
; Outputs:	Only R0-R2 are clobbered.
;
;--
		.ENABL	LSB
ADDRCVLIST:					; Add IRP buffer to free list
	MOVL	IRP$L_SVAPTE(R3),R2		; Get buffer, if any
	BEQL	FILLRCVLIST			; If none, fill rcv list if needed
	CLRL	IRP$L_SVAPTE(R3)		; Detach the buffer
	PUSHQ	R3				; Save regs
	BRB	20$				; Add buffer to free list

FILLRCVLIST:
	PUSHQ	R3				; Save regs
10$:	CMPB	CDB_B_RCV_FQ(R4),CDB_B_RCV_CNT(R4) ; Should new block be added?
	BGEQU	50$				   ; If GEQU no - list filled
	ADDW3	#CXB$C_OVERHEAD,CDB_W_BUFSIZ(R4),R1; Compute block size need
	JSB	G^EXE$ALONONPAGED		   ; Allocate nonpaged memory
	BLBC	R0,50$				   ; If LBC then failure
 	MOVW	R1,IRP$W_SIZE(R2)		   ; Insert block size
20$:	;
	;  Give SCS receive datagram
	;
	MOVL	CDB_L_CDT(R4),R3		; Pick up CDT address
	CMPB	UCB$B_CN_PORT(R5),CDT$B_RSTATION(R3) ; Talking to ourselves?
	BNEQ	30$				; If NEQ, no
	MOVL	UCB$L_TWIN_CDT(R5),R3		; Yes, use other CDT
30$:	MOVL	UCB$L_PDT(R5),R4		;  and PDT address
	MOVZBW	S^#DYN$C_CXB,IRP$B_TYPE(R2)	; Insert block type
	QUEUE_DG_BUF				; Put the block on the free que
	BLBC	R0,40$				; Br if failure
	MOVL	4(SP),R4			; Pick up CDB pointer
	INCB	CDB_B_RCV_FQ(R4)		; Bump free que count
	BRB	10$				; Try for more
40$:	MOVL	R2,R0				; Pick up the buffer
	BEQL	50$				; There is none
	BSBW	DEALLMEM			; Get rid of the buffer
						;
50$:	POPQ	R3				; Restore regs
	RSB					; Return

		.DSABL	LSB

	.SBTTL	XLATE,  Translate Channel to CDB address
 
;++
; XLATE - Translate Channel to CDB address
;
; This routine is called to return the CDB address for a particular
; channel. 
;
;
; Inputs:	R3 = IRP address
;		R5 = UCB address
;
; Outputs:	R0 - status return for success of call.
;	
;		R9 = CDB address if successful
;	    	     1 otherwise
;
;		R1,R2 are clobberd, all other registers are preserved.
;
;--
XLATE:					; Translate CHAN into CDB address
	MOVZWL	IRP$W_CHAN(R3),R0	; Get channel
	BSBB	XLATE_CHAN		; Translate channel
	MOVB	R1,IRP$B_INDEX(R3)	; Save index in IRP
	MOVL	R9,IRP$L_CDB(R3)	; Store CDB address in IRP
	RSB				; Return to caller

XLATE_CHAN:
	MOVZBL	#MAX_TRB-1,R1		; Setup loop counter (zero indexed)
10$:	CMPW	R0,UCB$W_VEC_CHAN(R5)[R1] ; Channels match?
	BEQL	40$			; Br if yes - got it
	SOBGEQ	R1,10$			; Loop
30$:	MOVZWL	#SS$_DEVINACT,R0	; Return channel offline
	MOVL	#1,R9			; Setup "R9 invalid" flag
	RSB				; And leave

40$:	;
	; Found match on channel
	;
	MOVL	UCB$L_VEC_CDB(R5)[R1],R9; Get CDB address
	BEQL	50$			; Br if no CDB address - error
	MOVZWL	S^#SS$_NORMAL,R0	; Set successful return status
	RSB				; Return

50$:	BUG_CHECK  INCONSTATE,FATAL


	.SBTTL	VALIDATE_P2,  Validate P2 buffer parameters
 
;++
; VALIDATE_P2 - Validate P2 buffer parameters
;
; This routine is called to validate the P2 buffer parameters. The parameters
; are checked against a parameter table which verifies that the minimum value
; and maximum value is not violated, and that status flags are set or clear
; as required.
;
; The way in this routine is written, the require word of the verification
; table can only have 1 bit set at a time.
;
; Inputs:	R1 = Address of parameter verification table
;		R2 = Status word from UCB or CDB
;		R3 = IRP address
;		R5 = UCB address
;		R9 = If low bit clear then ptr to context block (CDB or UCB)
;		     If low bit set then no context block exists
;
;		IPL = FIPL or ASTDEL
;
; Outputs:	R0 = status return of parameters
;		R1 = i.d. of parameter causing problem on error
;
;		All other registers are preserved.
;
;--
VALIDATE_P2:				; Validate P2 buffer parameters
	PUSHR	#^M<R1,R3,R5,R6,R7,R8>	; Save registers
					; NB:R1 must be on top of stack
	MOVL	@IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	MOVZWL	IRP$W_BCNT(R3),R8	; Get size of P2 buffer
	DIVL	#6,R8			; Get number of params in P2
	BRB	40$			; Treat as none if too few bytes
10$:	;
	;  Loop to check next parameter in P2 buffer
	;
	MOVZWL	(R6)+,R0		; Get parameter type from P2
	MOVL	(R6)+,R5		; Get parameter value from P2
	MOVL	(SP),R7			; Get parameter table address
20$:	;
	;  Loop to check P2 buffer parameter to circuit parameter table
	;
	BICW3	#^C<PRM_M_TYPE>,(R7)+,R1; Get next param i.d.
	BEQL	50$			; If EQL, at end of table
	CMPW	R0,R1			; Parameters match?
	BEQL	30$			; Br if yes
	ADDL2	#PARAM_C_ENTRY-2,R7	; Else, skip to next parameter
	BRB	20$			; Try next parameter
30$:	;
	;  Match found - check min,max,valid,invalid
	;
	MOVZWL	(R7)+,R3		; Get offset/width
	BLBS	R9,33$			; If LBS then no current block
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R3,R0 ; Get offset
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R3,R3 ; Get width
	EXTZV	#0,R3,(R9)[R0],R3	; Get current value
	CMPW	R5,R3			; Value change ?
	BEQL	40$			; If EQL no, try next param
33$:	CMPW	R5,(R7)+		; Is the value too small?
	BLSSU	50$			; Br if yes - error
	CMPW	R5,(R7)+		; Is the value too big?
	BGTRU	50$			; Br if yes - error
	MOVW	(R7)+,R5		; Pick up required
	BEQL	35$			; None
	BITW	R5,R2			; Check required bit
	BEQL	50$			; Br if not on - error
35$:	BITW	(R7)+,R2		; Check invalid bits
	BNEQ	50$			; Br if on - error
40$:	SOBGTR	R8,10$			; Br if more parameters
	MOVZWL	S^#SS$_NORMAL,R0	; Set success return
	BRB	60$			; And return
					; 
50$:	MOVZWL	R1,(SP)			; Return bad parameter type
	MOVL	#SS$_BADPARAM,R0	; Set error return
60$:	POPR	#^M<R1,R3,R5,R6,R7,R8>	; Restore registers
	RSB				; Return to caller

	.SBTTL	UNPACK_P2_BUF,  Unpack a P2 parameter from P2 buffer
 
;++
; UNPACK_P2_BUF - Unpack a P2 parameter from P2 buffer
;
;
; This routine is called to get a P2 parameter from the P2 buffer.
;
; Inputs:	R1 = Parameter type code
;		R3 = IRP address
;		R5 = UCB address
;
;		IPL = IPL$_ASTDEL to allow user paging.
;
; Outputs:	R0 = SS$_NORMAL  if successful
;	  	     SS$_INSFARG otherwise
;		R2 = Parameter value if success else destroyed
;
;		All other registers are preserved.
;
;--
UNPACK_P2_BUF:				; Unpack P2 buffer
	PUSHR	#^M<R5,R6,R7>		; Save registers
	MOVL	@IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	MOVZWL	IRP$W_BCNT(R3),R7	; Get size of P2 buffer
	DIVL	#6,R7			; Get number of params in P2
	BEQL	20$			; Treat as none if too few bytes
	MOVZWL	S^#SS$_NORMAL,R0	; Assume success
10$:	;
	;  Loop to check next parameter in P2 buffer
	;
	MOVZWL	(R6)+,R5		; Get parameter type from P2
	MOVL	(R6)+,R2		; Get parameter value from P2
	CMPW	R1,R5			; Parameters match?
	BEQL	30$			; Br if yes
	SOBGTR	R7,10$			; Br if more parameters
					; 
20$:	MOVZWL	#SS$_INSFARG,R0		; Return error
30$:	POPR	#^M<R5,R6,R7>		; Restore registers
	RSB				; Return to caller

	.SBTTL	CN_END,  End of driver

	. = <.+15>&<-16>

PATCH::	.LONG	32-8
	.LONG	PATCH+8
	.BLKB	32-8
 
;++
; Label that marks the end of the driver
;--

CN_END:					; Last location in driver
 
	.END
