%TITLE	'FDL$PARSE'
%SBTTL	'FDL Parse Action Routines'
MODULE	FDLPARSE	( IDENT='V04-000',
			ADDRESSING_MODE ( EXTERNAL = GENERAL ),
			ADDRESSING_MODE ( NONEXTERNAL = GENERAL ),
			OPTLEVEL=3
			) =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! Facility:
!		RMS-32 FDL Utilities
!
! Environment:
!		VAX/VMS Operating System
!
! Abstract:
!		Routines which fill the rms control blocks
!		for the FDL parser
!
! Contents:
!		INIT_PARSE
!		LINE_PARSED
!		SET_AREA_P
!		SET_DATE_P
!		SET_JNL_P
!		SET_ACL_P
!		SET_FILE_P
!		SET_KEY_P
!		SET_RECORD_P
!		SET_ACCESS_P
!		SET_SHARING_P
!		SET_CONNECT_P
!		SET_PROT
!		ALLOCATE_XAB
!		FIND_ID
!		GET_VM
!		FREE_VM
!
!--

!
! Author:	Keith B Thompson	Creation date:	July-1981
!
!
! Modified by:
!
!	V03-011 RRB0015		Rowland R. Bradley	29 Feb 1984
!		Comment out references to ERASE_ON_DELETE and ACL support.
!		Not supported for V4.0.
!
!	V03-010 RRB0008		Rowland R. Bradley	19 Jan 1984
!		Support NULL strings in file name.
!
!	V03-009	KFH0007		Ken Henderson		10 Sep 1983
!		Support for named UICs
!
!	V03-008	KFH0006		Ken Henderson		29 Jul 1983
!		Check status of call to LIB$...
!		Added DEFERRED_WRITE, ERASE_ON_DELETE
!
!	V03-007	KFH0005		Ken Henderson		6 Jan 1983
!		Fixed allocation of keyname buffer
!
!	V03-006	KFH0004		Ken Henderson		21 Dec 1982
!		Deleted unused ref to tpa_block
!
!	V03-005	KFH0003		Ken Henderson		22 Nov 1982
!		Add support for default and main
!		parses in FDL$PARSE
!		Fix FDL$$FREE_VM to signal status
!
!	V03-004	KFH0002		Ken Henderson		6-Oct-1982
!		Add support for Journal, Access,
!		ACL, Sharing, Connect primaries
!
!	V03-003	KBT0069		Keith B. Thompson	24-Jun-1982
!		Initialize the length in fdl$ab_item
!
!	V03-002	KBT0030		Keith Thompson		30-Mar-1982
!		Fix error processing of the date & time stuff
!
!	V03-001	KFH0001		Ken Henderson	29 March 1982
!		Fixed SET_AREA_P to set LBN
!		instead of VBN for volume placement
!
!****


PSECT
	OWN	= _FDL$OWN	(PIC),
	GLOBAL	= _FDL$GLOBAL	(PIC),
	PLIT	= _FDL$PLIT	(SHARE,PIC),
	CODE	= _FDL$CODE	(SHARE,PIC);

LIBRARY	'SYS$LIBRARY:STARLET';
REQUIRE	'SRC$:FDLUTIL';
REQUIRE	'LIB$:FDLPARDEF';

EXTERNAL ROUTINE
	LIB$GET_VM,
	LIB$FREE_VM,
	FDL$$RMS_ERROR		: NOVALUE;

DEFINE_ERROR_CODES;

FORWARD ROUTINE
	SET_AREA_P	: NOVALUE,
	SET_DATE_P	: NOVALUE,
	SET_JNL_P	: NOVALUE,
	SET_ACL_P	: NOVALUE,
	SET_FILE_P	: NOVALUE,
	SET_KEY_P	: NOVALUE,
	SET_RECORD_P	: NOVALUE,
	SET_ACCESS_P	: NOVALUE,
	SET_SHARING_P	: NOVALUE,
	SET_CONNECT_P	: NOVALUE,
	SET_PROT	: NOVALUE,
	ALLOCATE_XAB,
	FIND_ID		: NOVALUE,
	FDL$$GET_VM,
	FDL$$FREE_VM	: NOVALUE;

EXTERNAL
	FDL$AB_TPARSE_BLOCK	: BLOCK [ ,BYTE ],
	FDL$AB_ITEM		: DESC_BLK,
	FDL$AB_CTRL		: BLOCK [ ,BYTE ],
	FDL$GL_PCALL,
	FDL$GL_STMNTNUM,
	FDL$GL_PRIMARY,
	FDL$GL_PRINUM,
	FDL$AB_PRICTRL,
	FDL$GL_SECONDARY,
	FDL$GL_SECNUM,
	FDL$GL_QUALIFIER,
	FDL$GL_NUMBER,
	FDL$GL_SWITCH,
	FDL$GL_OWNER_UIC,
	FDL$GL_SPARE1,
	FDL$GL_PROTECTION,
	FDL$GL_FID1,
	FDL$GL_FID2,
	FDL$GL_FID3,
	FDL$AB_AREA_BKZ		: REF VECTOR [ ,BYTE ],
	FDL$AL_DATE_TIME	: VECTOR [,LONG ],
	FDL$AB_STRING		: DESC_BLK,
	
	FDL$AB_PARSED_FAB	: REF $FAB_DECL,
	FDL$AB_PARSED_RAB	: REF $RAB_DECL;

LITERAL
	SPACE	= 32;

OWN
	HIGHEST_AREA_NO	: BYTE,
	CURRENT_XAB	: REF BLOCK [ ,BYTE ],
	END_XAB		: REF BLOCK [ ,BYTE ],

	JNL_XAB		: REF $XABJNL_DECL,	! Journal XAB
	DATE_XAB	: REF $XABDAT_DECL,	! Date XAB
	REVISION_XAB	: REF $XABRDT_DECL,	! Revision Date and Time XAB
	PROTECTION_XAB	: REF $XABPRO_DECL;	! Protection XAB


%SBTTL	'INIT_PARSE'
GLOBAL ROUTINE	FDL$$INIT_PARSE : NOVALUE =
!++
!
! Functional Description:
!
!	Init variables and allocate a buffer for the area bucket sizes
!
! Calling Sequence:
!
!	fdl$$init_parse()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	lib$get_vm
!
! Side Effects:
!
!	Allocates a buffer pointed to by FDL$AB_AREA_BKZ
!
!--

    BEGIN

    LOCAL
	BYTES;

    ! Set the parse control bits
    !
    FDL$AB_CTRL [ FDL$V_STATUS ] = _SET;
    FDL$AB_CTRL [ FDL$V_INITIAL ] = _SET;

    ! Clear the other CTRL bits except the following ones:
    !	PCALL
    !	DCL
    !	STRING_SPEC
    !	GCALL
    !
    FDL$AB_CTRL [ FDL$V_WARNING ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_PRIMARY ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_NEWPRI ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_SECONDARY ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_COMMENT ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_LINECMT ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_APOST_PRES ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_QUOTE_PRES ] = _CLEAR;
    FDL$AB_CTRL [ FDL$V_USED_STRING ] = _CLEAR;

    ! Initialize the item length for fdl$get_line
    !
    FDL$AB_ITEM [ DSC$W_LENGTH ] = 0;

    IF NOT .FDL$AB_CTRL [ FDL$V_REPARSE ]
    THEN
	BEGIN

	! Clear the pointers to xabs
	!
	JNL_XAB		= _CLEAR;
	DATE_XAB	= _CLEAR;
	REVISION_XAB	= _CLEAR;
	PROTECTION_XAB	= _CLEAR;

	END;

    ! Clear misc
    !
    FDL$GL_STMNTNUM	= 0;
    FDL$AB_PRICTRL	= _CLEAR;
    CURRENT_XAB		= _CLEAR;
    HIGHEST_AREA_NO	= 0;

    ! Allocate memory for the area bucket size array NOTE: Use lib$get_vm so
    ! we can return this in fdl$$finish_parse
    !
    BYTES = 256;

    IF NOT LIB$GET_VM ( BYTES,FDL$AB_AREA_BKZ )
    THEN
	SIGNAL_STOP ( FDL$_INSVIRMEM );

    ! Zero the values
    !
    CH$FILL( 0,.BYTES,.FDL$AB_AREA_BKZ );

    RETURN

    END;

%SBTTL	'FINISH_PARSE'
GLOBAL ROUTINE	FDL$$FINISH_PARSE =
!++
!
! Functional Description:
!
!	Ties up any loose ends and returns with the final status value
!
! Calling Sequence:
!
!	status = fdl$$finish_parse()
!
! Input Parameters:
!
!	none
!
! Implicit Inputs:
!
!	none
!
! Output Parameters:
!
!	none
!
! Implicit Outputs:
!
!	none
!
! Routine Value:
!
!	SS$_NORMAL	- If everything completed corectly
!	FDL$_WARNING	- If there were warnings duing processing
!	FDL$_FDLERROR	- If there were real problems
!
! Routines Called:
!
!	lib$free_vm
!
! Side Effects:
!	none
!
!--

    BEGIN

    LOCAL
	STATUS,
	XAB	: REF BLOCK [ ,BYTE ],
	BYTES;

    ! If successful then continue and return ok
    !
    IF .FDL$AB_CTRL [ FDL$V_STATUS ]
    THEN
	STATUS = SS$_NORMAL
    ELSE

	! If the problem was a warning then continue and return fdl$_warning
	! else return imeditaly
	!
	IF .FDL$AB_CTRL [ FDL$V_STATUS ] EQLU STS$K_WARNING
	THEN
	    STATUS = FDL$_WARNING
	ELSE
	    RETURN FDL$_FDLERROR;

    ! Travel through the xabs and fix up random things
    ! UNLESS THIS IS JUST A DEFAULT PARSE
    !
    IF (
    ( NOT .FDL$AB_CTRL [ FDL$V_DFLT_PRES ] )
    OR
    ( .FDL$AB_CTRL [ FDL$V_REPARSE ] )
    ) THEN
	BEGIN

	XAB = .FDL$AB_PARSED_FAB [ FAB$L_XAB ];

	WHILE .XAB NEQU 0
	DO
	    BEGIN

	    ! If this is a key xab fix the fill factors if neccary
	    !
	    IF .XAB [ XAB$B_COD ] EQLU XAB$C_KEY
	    THEN
		BEGIN

		! Make sure the area numbers are valid if not simply exit
		! RMS will catch it during the create
		!
		IF ( .XAB [ XAB$B_DAN ] GTRU .HIGHEST_AREA_NO ) OR
		    ( .XAB [ XAB$B_IAN ] GTRU .HIGHEST_AREA_NO )
		THEN
		    EXITLOOP;

		! Data level fill
		!
		XAB [ XAB$W_DFL ] = ( .FDL$AB_AREA_BKZ [ .XAB [ XAB$B_DAN ] ] * BLOCK_SIZE *
						    .XAB [ XAB$W_DFL ] ) / 100;

		! Index level fill
		!
		XAB [ XAB$W_IFL ] = ( .FDL$AB_AREA_BKZ [ .XAB [ XAB$B_IAN ] ] * BLOCK_SIZE *
						    .XAB [ XAB$W_IFL ] ) / 100
		END;

	    XAB = .XAB [ XAB$L_NXT ]

	    END;

	END;

    ! Deallocate memory for the area bucket size array
    !
    BYTES = 256;
	BEGIN
	LOCAL STATUS;

	IF NOT ( STATUS = LIB$FREE_VM ( BYTES,FDL$AB_AREA_BKZ ))
	THEN
	    SIGNAL_STOP ( .STATUS );
	END;

    RETURN .STATUS

    END;

%SBTTL	'LINE_PARSED'
GLOBAL ROUTINE	FDL$$LINE_PARSED =
!++
!
! Functional Description:
!
!	Main parsing routine.  Called by the parse tables it in turn
!	calles the appropiate routines to parse the fdl line.
!
! Calling Sequence:
!
!	Called from parse tables
!
! Input Parameters:
!
!	fdl$gl_primary	- Primary code
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	Values returned by called routines
!
! Routines Called:
!
!	.fdl$gl_pcall
!	set_area_p
!	set_date_p
!	set_jnl_p
!	set_acl_p	not supported V4.0
!	set_file_p
!	set_key_p
!	set_record_p
!	set_access_p
!	set_sharing_p
!	set_connect_p
!
! Side Effects:
!	none
!
!--

    BEGIN

    TPARSE_ARGS;

    LOCAL
	STATUS;

    STATUS = SS$_NORMAL;

    ! If we have processed some really bad stuff then dont bother
    !
    IF .FDL$AB_CTRL [ FDL$V_STATUS ] EQLU STS$K_ERROR
    THEN
	RETURN .STATUS;

    ! If this is an EDF call then let them process the command
    !
    IF .FDL$AB_CTRL [ FDL$V_PCALL ]
    THEN
	STATUS = (.FDL$GL_PCALL)()
    ELSE

	! If this is a primary only or line comment call ignore it
	!
	IF NOT ( .FDL$AB_CTRL [ FDL$V_NEWPRI ] OR .FDL$AB_CTRL [ FDL$V_LINECMT ] )
	THEN
	    CASE .FDL$GL_PRIMARY FROM FDL$C_ACCESS TO FDL$C_TITLE OF
			SET

			[ FDL$C_ACCESS ] : SET_ACCESS_P();

			[ FDL$C_ACL ]	: SET_ACL_P();

			[ FDL$C_AREA ]	: SET_AREA_P();

			[ FDL$C_CONNECT ] : SET_CONNECT_P();

			[ FDL$C_DATE ]	: SET_DATE_P();

			[ FDL$C_FILE ]	: SET_FILE_P();

			[ FDL$C_JNL ]	: SET_JNL_P();

			[ FDL$C_KEY ]	: SET_KEY_P();

			[ FDL$C_RECORD ] : SET_RECORD_P();

			[ FDL$C_SHARING ] : SET_SHARING_P();

			[ INRANGE ]	: 0;	! Catch all for non usefull
						! primaries

			TES;

    ! Clear new primary in case it was set
    !
    FDL$AB_CTRL [ FDL$V_NEWPRI ] = _CLEAR;

    RETURN .STATUS

    END;

%SBTTL 'SET_AREA_P'
ROUTINE	SET_AREA_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the allocation xab
!
! Calling Sequence:
!
!	set_area_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	allocate_xab
!
! Side Effects:
!	none
!
!--

    BEGIN

    ! To aviod some duplication of code ....
    ! Find out if there is a current xab  if not then get one
    ! OR If the current xab is not the same type or number of what we want
    ! then get a new one
    !
    IF ( IF .CURRENT_XAB EQLU 0
	 THEN 1
	 ELSE
	 IF ( .CURRENT_XAB [ XAB$B_COD ] NEQ XAB$C_ALL ) OR
	    ( .CURRENT_XAB [ XAB$B_AID ] NEQ .FDL$GL_PRINUM )
	 THEN 1
	 ELSE 0 )
    THEN
	BEGIN

	! Allocate memory for the new xab
	!
	ALLOCATE_XAB ( XAB$C_ALL, .FDL$GL_PRINUM );

	! Set the area number in the xab
	!
	CURRENT_XAB [ XAB$B_AID ] = .FDL$GL_PRINUM;

	! If this is area 0 then copy the allocation etc. from the fab (this
	! is because using areas overide the fab allocation and this
	! makes it look like it doesen't)
	!
	IF .CURRENT_XAB [ XAB$B_AID ] EQLU 0
	THEN
	    BEGIN

	    ! Copy Allocation, Bucket size and Extention
	    !
	    CURRENT_XAB [ XAB$L_ALQ ] = .FDL$AB_PARSED_FAB [ FAB$L_ALQ ];
	    CURRENT_XAB [ XAB$B_BKZ ] = .FDL$AB_PARSED_FAB [ FAB$B_BKS ];
	    CURRENT_XAB [ XAB$W_DEQ ] = .FDL$AB_PARSED_FAB [ FAB$W_DEQ ];
	    CURRENT_XAB [ XAB$L_ALQ ] = .FDL$AB_PARSED_FAB [ FAB$L_ALQ ];

	    IF .FDL$AB_PARSED_FAB [ FAB$B_BKS ] NEQU 0
	    THEN
		FDL$AB_AREA_BKZ [ 0 ] = .FDL$AB_PARSED_FAB [ FAB$B_BKS ]
	    ELSE
		FDL$AB_AREA_BKZ [ 0 ] = BUCKET_DEFAULT;

	    ! Also get the duplicated contigous options:
	    !
	    ! Contigous best try
	    !
	    IF .FDL$AB_PARSED_FAB [ FAB$V_CBT ]
	    THEN
		CURRENT_XAB [ XAB$V_CBT ] = _SET;

	    ! Contigous
	    !
	    IF .FDL$AB_PARSED_FAB [ FAB$V_CTG ]
	    THEN
		CURRENT_XAB [ XAB$V_CTG ] = _SET

	    END
	ELSE

	    ! Count this area
	    !
	    HIGHEST_AREA_NO = .HIGHEST_AREA_NO + 1

	END;

    ! Set the fields in the area xab
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_ALLOC TO FDL$C_VOLU OF
    SET
	[ FDL$C_ALLOC ]	: CURRENT_XAB [ XAB$L_ALQ ] = .FDL$GL_NUMBER;

	[ FDL$C_BTCONT ]: CURRENT_XAB [ XAB$V_CBT ] = .FDL$GL_SWITCH;

	[ FDL$C_BKT ]	: BEGIN

			  CURRENT_XAB [ XAB$B_BKZ ] = .FDL$GL_NUMBER;

			  ! Fill in the table for figuring fill numbers latter
			  !
			  FDL$AB_AREA_BKZ [ .FDL$GL_PRINUM ] = .FDL$GL_NUMBER

			  END;

	[ FDL$C_CONTG ]	: CURRENT_XAB [ XAB$V_CTG ] = .FDL$GL_SWITCH;

	[ FDL$C_EXACT ]	: CURRENT_XAB [ XAB$V_HRD ] = .FDL$GL_SWITCH;

	[ FDL$C_EXTND ]	: CURRENT_XAB [ XAB$W_DEQ ] = .FDL$GL_NUMBER;

	[ FDL$C_POSI ]	: CASE .FDL$GL_QUALIFIER FROM
						FDL$C_ANYPOS TO FDL$C_VIRPOS OF
		  SET
		      [ FDL$C_ANYPOS ] : CURRENT_XAB [ XAB$V_ONC ] = _SET;

		      [ FDL$C_CLUSPOS ] : CURRENT_XAB [ XAB$V_ONC ] = _SET;

		      [ FDL$C_CYLPOS ] : BEGIN
					 CURRENT_XAB [ XAB$B_ALN ] = XAB$C_CYL;
					 CURRENT_XAB [ XAB$L_LOC ] = .FDL$GL_NUMBER
					 END;

		      [ FDL$C_FIDPOS ] : BEGIN
					 CURRENT_XAB [ XAB$W_RFI0 ] = .FDL$GL_FID1;
					 CURRENT_XAB [ XAB$W_RFI2 ] = .FDL$GL_FID2;
					 CURRENT_XAB [ XAB$W_RFI4 ] = .FDL$GL_FID3
					 END;

		      [ FDL$C_FNMPOS ] : BEGIN
					 FIND_ID();
					 CURRENT_XAB [ XAB$W_RFI0 ] = .FDL$GL_FID1;
					 CURRENT_XAB [ XAB$W_RFI2 ] = .FDL$GL_FID2;
					 CURRENT_XAB [ XAB$W_RFI4 ] = .FDL$GL_FID3
					 END;

		      [ FDL$C_LOGPOS ] : BEGIN
					 CURRENT_XAB [ XAB$B_ALN ] = XAB$C_LBN;
					 CURRENT_XAB [ XAB$L_LOC ] = .FDL$GL_NUMBER
					 END;

		      [ FDL$C_NOPOS ]  : CURRENT_XAB [ XAB$B_ALN ] = _CLEAR;

		      [ FDL$C_VIRPOS ] : BEGIN
					 CURRENT_XAB [ XAB$B_ALN ] = XAB$C_VBN;
					 CURRENT_XAB [ XAB$L_LOC ] = .FDL$GL_NUMBER
					 END;
		  TES;

	[ FDL$C_VOLU ]	: BEGIN
			  CURRENT_XAB [ XAB$W_VOL ] = .FDL$GL_NUMBER;

			  ! If the guy didn't give any placement do it for him
			  !
			  IF .CURRENT_XAB [ XAB$B_ALN ] EQLU _CLEAR
			  THEN
			      CURRENT_XAB [ XAB$B_ALN ] = XAB$C_LBN;

			  END;

    TES;

    RETURN

    END;

%SBTTL 'SET_DATE_P'
ROUTINE	SET_DATE_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the revision date and time xab
!
! Calling Sequence:
!
!	set_date_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	sys$bintim
!
! Side Effects:
!	none
!
!--

    BEGIN

    ! See which xab we need
    !
    IF .FDL$GL_SECONDARY EQLU FDL$C_REV
    THEN
	BEGIN

	! If the revision xab has not been connected then connect it
	!
	IF .REVISION_XAB EQLU 0
	THEN

	    ! Allocate the xab an enter it into the chain
	    !
	    REVISION_XAB = ALLOCATE_XAB ( XAB$C_RDT, 0 )

	END
    ELSE

	! If the date xab has not been allocated then get one
	!
	IF .DATE_XAB EQLU 0
	THEN

	    ! Allocate the xab an enter it into the chain
	    !
	    DATE_XAB = ALLOCATE_XAB ( XAB$C_DAT, 0 );

    ! Fill in the correct field
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_BACKUP TO FDL$C_REV OF
    SET
	[ FDL$C_BACKUP ]: BEGIN
			  DATE_XAB [ XAB$L_BDT0 ] = .FDL$AL_DATE_TIME [ 0 ];
			  DATE_XAB [ XAB$L_BDT4 ] = .FDL$AL_DATE_TIME [ 1 ]
			  END;

	[ FDL$C_CREAT ]	: BEGIN
			  DATE_XAB [ XAB$L_CDT0 ] = .FDL$AL_DATE_TIME [ 0 ];
			  DATE_XAB [ XAB$L_CDT4 ] = .FDL$AL_DATE_TIME [ 1 ]
			  END;

	[ FDL$C_EXPR ]	: BEGIN
			  DATE_XAB [ XAB$L_EDT0 ] = .FDL$AL_DATE_TIME [ 0 ];
			  DATE_XAB [ XAB$L_EDT4 ] = .FDL$AL_DATE_TIME [ 1 ]
			  END;

	[ FDL$C_REV ]	: BEGIN
			  REVISION_XAB [ XAB$L_RDT0 ] = .FDL$AL_DATE_TIME [ 0 ];
			  REVISION_XAB [ XAB$L_RDT4 ] = .FDL$AL_DATE_TIME [ 1 ]
			  END;

    TES;

    RETURN

    END;

%SBTTL 'SET_JNL_P'
ROUTINE	SET_JNL_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the journal xab
!
! Calling Sequence:
!
!	set_jnl_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

    ! If the xab has not been connected, then connect it
    !
    IF .JNL_XAB EQLU 0
    THEN
	! Allocate the xab and enter it into the chain
	!
	JNL_XAB = ALLOCATE_XAB ( XAB$C_JNL, 0 );

    ! Fill in the correct field
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_AFTIM TO FDL$C_RU OF
    SET
	[ FDL$C_AFTIM ]	  : JNL_XAB [ XAB$V_AI ] = .FDL$GL_SWITCH;

	[ FDL$C_AFTNAM ]  : BEGIN

			    ! Allocate a buffer for the string and copy to it
			    !
			    JNL_XAB [ XAB$L_AIA ] =
			    	FDL$$GET_VM( .FDL$AB_STRING [ DSC$W_LENGTH ] );

			    CH$MOVE(	.FDL$AB_STRING [ DSC$W_LENGTH ],
			    		.FDL$AB_STRING [ DSC$A_POINTER ],
			    		.JNL_XAB [ XAB$L_AIA ] );

			    JNL_XAB [ XAB$B_AIS ] = 
			    		.FDL$AB_STRING [ DSC$W_LENGTH ]
			    END;

	[ FDL$C_AUDIT ]   : JNL_XAB [ XAB$V_AT ] = .FDL$GL_SWITCH;

	[ FDL$C_AUDNAM ]  : BEGIN
			    ! Allocate a buffer for the string and copy to it
			    !
			    JNL_XAB [ XAB$L_ATA ] =
			    	FDL$$GET_VM( .FDL$AB_STRING [ DSC$W_LENGTH ] );

			    CH$MOVE(	.FDL$AB_STRING [ DSC$W_LENGTH ],
			    		.FDL$AB_STRING [ DSC$A_POINTER ],
			    		.JNL_XAB [ XAB$L_ATA ] );

			    JNL_XAB [ XAB$B_ATS ] = 
			    		.FDL$AB_STRING [ DSC$W_LENGTH ]
			    END;

	[ FDL$C_BEFIM ]   : JNL_XAB [ XAB$V_BI ] = .FDL$GL_SWITCH;

	[ FDL$C_BEFNAM ]  : BEGIN
			    ! Allocate a buffer for the string and copy to it
			    !
			    JNL_XAB [ XAB$L_BIA ] =
			    	FDL$$GET_VM( .FDL$AB_STRING [ DSC$W_LENGTH ] );

			    CH$MOVE(	.FDL$AB_STRING [ DSC$W_LENGTH ],
			    		.FDL$AB_STRING [ DSC$A_POINTER ],
			    		.JNL_XAB [ XAB$L_BIA ] );

			    JNL_XAB [ XAB$B_BIS ] = 
			    		.FDL$AB_STRING [ DSC$W_LENGTH ]
			    END;

	[ FDL$C_RU ]	  : BEGIN
			    ! Set the recovery unit bit according to what
			    ! was specified
			    !
			    JNL_XAB [ XAB$V_RU ] = _CLEAR;
			    JNL_XAB [ XAB$V_ONLY_RU ] = _CLEAR;
			    JNL_XAB [ XAB$V_NEVER_RU ] = _CLEAR;

			    IF .FDL$GL_QUALIFIER EQLU FDL$C_IF_IN
			    THEN
				JNL_XAB [ XAB$V_RU ] = _SET

			    ELSE IF .FDL$GL_QUALIFIER EQLU FDL$C_NEC
			    THEN
				JNL_XAB [ XAB$V_ONLY_RU ] = _SET

			    ELSE IF .FDL$GL_QUALIFIER EQLU FDL$C_NEVER
			    THEN
				JNL_XAB [ XAB$V_NEVER_RU ] = _SET;

			    END;

    TES;

    RETURN

    END;

%SBTTL 'SET_ACL_P'
ROUTINE	SET_ACL_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the ACL xab
!
! Calling Sequence:
!
!	set_acl_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

! nop until there exists an ACLXAB

    RETURN

    END;

%SBTTL	'SET_FILE_P'
ROUTINE	SET_FILE_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the fab
!
! Calling Sequence:
!
!	set_file_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	SS$_NORMAL or error from set_prot
!
! Routines Called:
!
!	fdl$$get_vm
!	set_prot
!
! Side Effects:
!	none
!
!--

    BEGIN

    REGISTER
	PARSED_FAB : REF BLOCK [ ,BYTE ];

    PARSED_FAB = .FDL$AB_PARSED_FAB;

    ! Set the fab according to the secondary parsed
    !
    SELECT .FDL$GL_SECONDARY OF
    SET
	[ FDL$C_ALL ]	: PARSED_FAB [ FAB$L_ALQ ] = .FDL$GL_NUMBER;

	[ FDL$C_BKTUP ]	: 0;

	[ FDL$C_BTC ]	: PARSED_FAB [ FAB$V_CBT ] = .FDL$GL_SWITCH;

	[ FDL$C_BKTSIZ ]: BEGIN

			  PARSED_FAB [ FAB$B_BKS ] = .FDL$GL_NUMBER;

			  ! Stuff the bucket size into the array for latter
			  !
			  FDL$AB_AREA_BKZ [ 0 ] = .FDL$GL_NUMBER

			  END;

	[ FDL$C_CLUSIZ ]: 0;

	[ FDL$C_FCTX ]	: PARSED_FAB [ FAB$L_CTX ] = .FDL$GL_NUMBER;

	[ FDL$C_CONT ]	: PARSED_FAB [ FAB$V_CTG ] = .FDL$GL_SWITCH;

	[ FDL$C_CIF ]	: PARSED_FAB [ FAB$V_CIF ] = .FDL$GL_SWITCH;

	[ FDL$C_DFNAM ]	: BEGIN

			  ! Allocate a buffer for the string and copy it into it
			  !
			  PARSED_FAB [ FAB$L_DNA ] =
				FDL$$GET_VM( .FDL$AB_STRING [ DSC$W_LENGTH ] );

			  CH$MOVE( .FDL$AB_STRING [ DSC$W_LENGTH ],
				   .FDL$AB_STRING [ DSC$A_POINTER ],
				   .PARSED_FAB [ FAB$L_DNA ] );

			  PARSED_FAB [ FAB$B_DNS ] =
						.FDL$AB_STRING [ DSC$W_LENGTH ]
			  END;

	[ FDL$C_DEFWRT ] : PARSED_FAB [ FAB$V_DFW ] = .FDL$GL_SWITCH;

	[ FDL$C_DOC ]	: PARSED_FAB [ FAB$V_DLT ] = .FDL$GL_SWITCH;

	[ FDL$C_DIR ] 	: PARSED_FAB [ FAB$V_TMP ] = .FDL$GL_SWITCH;

! not supported V4.0
!	[ FDL$C_EODEL ]	: PARSED_FAB [ FAB$V_EDL ] = .FDL$GL_SWITCH;

	[ FDL$C_EXTEN ]	: PARSED_FAB [ FAB$W_DEQ ] = .FDL$GL_NUMBER;

	[ FDL$C_GBC ]	: PARSED_FAB [ FAB$W_GBC ] = .FDL$GL_NUMBER;

	[ FDL$C_MTBLSIZ]: PARSED_FAB [ FAB$W_BLS ] = .FDL$GL_NUMBER;

	[ FDL$C_MTCP ]	: PARSED_FAB [ FAB$V_POS ] = .FDL$GL_SWITCH;

	[ FDL$C_MTNEF ]	: PARSED_FAB [ FAB$V_NEF ] = .FDL$GL_SWITCH;

	[ FDL$C_MTPRO ]	: SET_PROT();

	[ FDL$C_MTREW ]	: PARSED_FAB [ FAB$V_RWO ] = .FDL$GL_SWITCH;

	[ FDL$C_MTRWC ]	: PARSED_FAB [ FAB$V_RWC ] = .FDL$GL_SWITCH;

	[ FDL$C_MAXRECN]: PARSED_FAB [ FAB$L_MRN ] = .FDL$GL_NUMBER;

	[ FDL$C_MAXVER]	: PARSED_FAB [ FAB$V_MXV ] = .FDL$GL_SWITCH;

	[ FDL$C_NAME ]	: BEGIN
			  ! Check for non-null name string
			  !
			  IF .FDL$AB_STRING [DSC$W_LENGTH] NEQ 0 
			  THEN
			      BEGIN
				  ! Allocate a buffer for the string and copy it
				  !
				  PARSED_FAB [ FAB$L_FNA ] =
					FDL$$GET_VM( .FDL$AB_STRING [ DSC$W_LENGTH ] );

				  CH$MOVE( .FDL$AB_STRING [ DSC$W_LENGTH ],
					   .FDL$AB_STRING [ DSC$A_POINTER ],
				   	   .PARSED_FAB [ FAB$L_FNA ] );
			      END;
			  PARSED_FAB [ FAB$B_FNS ] =
						.FDL$AB_STRING [ DSC$W_LENGTH ]
			  END;

	[ FDL$C_NFS ]	: PARSED_FAB [ FAB$V_NFS ] = .FDL$GL_SWITCH;

	[ FDL$C_ORG ]	: PARSED_FAB [ FAB$B_ORG ] = .FDL$GL_QUALIFIER;

	[ FDL$C_OFP ]	: PARSED_FAB [ FAB$V_OFP ] = .FDL$GL_SWITCH;

	[ FDL$C_OWNER ]	: SET_PROT();

	[ FDL$C_POC ]	: PARSED_FAB [ FAB$V_SPL ] = .FDL$GL_SWITCH;

	[ FDL$C_PROT ]	: SET_PROT();

	[ FDL$C_READC ]	: PARSED_FAB [ FAB$V_RCK ] = .FDL$GL_SWITCH;

	[ FDL$C_REVISN ]: BEGIN

			  ! If the revision xab has not been connected then connect it
			  !
			  IF .REVISION_XAB EQLU 0
			  THEN

			      ! Allocate the xab an enter it into the chain
			      !
			      REVISION_XAB = ALLOCATE_XAB ( XAB$C_RDT, 0 );

			  REVISION_XAB [ XAB$W_RVN ] = .FDL$GL_NUMBER

			  END;

	[ FDL$C_SQO ]	: PARSED_FAB [ FAB$V_SQO ] = .FDL$GL_SWITCH;

	[ FDL$C_SOC ] 	: PARSED_FAB [ FAB$V_SCF ] = .FDL$GL_SWITCH;

	[ FDL$C_SUPER ]	: PARSED_FAB [ FAB$V_SUP ] = .FDL$GL_SWITCH;

	[ FDL$C_TEMPO ]	: PARSED_FAB [ FAB$V_TMD ] = .FDL$GL_SWITCH;

	[ FDL$C_TOC ]	: PARSED_FAB [ FAB$V_TEF ] = .FDL$GL_SWITCH;

	[ FDL$C_UFO ]	: PARSED_FAB [ FAB$V_UFO ] = .FDL$GL_SWITCH;

	[ FDL$C_WIN ]	: PARSED_FAB [ FAB$B_RTV ] = .FDL$GL_NUMBER;

	[ FDL$C_WRITEC ]: PARSED_FAB [ FAB$V_WCK ] = .FDL$GL_SWITCH;

    TES;

    RETURN

    END;

%SBTTL	'SET_KEY_P'
ROUTINE	SET_KEY_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the key xab
!
! Calling Sequence:
!
!	set_key_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	allocate_xab
!
! Side Effects:
!	none
!
!--

    BEGIN

    ! Find out if there is a current xab  if not then get one
    !
    IF .CURRENT_XAB EQL 0
    THEN
	BEGIN

	ALLOCATE_XAB ( XAB$C_KEY, .FDL$GL_PRINUM );

	CURRENT_XAB [ XAB$B_REF ] = .FDL$GL_PRINUM

	END
    ELSE

	! If the current xab is not the same type or number of what we want
	! then get a new one
	!
	IF ( .CURRENT_XAB [ XAB$B_COD ] NEQ XAB$C_KEY ) OR
	   ( .CURRENT_XAB [ XAB$B_REF ] NEQ .FDL$GL_PRINUM )
	THEN
	    BEGIN

	    ALLOCATE_XAB ( XAB$C_KEY, .FDL$GL_PRINUM );

	    CURRENT_XAB [ XAB$B_REF ] = .FDL$GL_PRINUM

	    END;

    ! Set the key xab fields
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_CHANGE TO FDL$C_SEGTYP OF
    SET
	[ FDL$C_CHANGE ]: CURRENT_XAB [ XAB$V_CHG ] = .FDL$GL_SWITCH;

	[ FDL$C_DAREA ]	: CURRENT_XAB [ XAB$B_DAN ] = .FDL$GL_NUMBER;

	[ FDL$C_DFILL ]	: CURRENT_XAB [ XAB$W_DFL ] = .FDL$GL_NUMBER;

	[ FDL$C_DATKC ]	: CURRENT_XAB [ XAB$V_KEY_NCMPR ] = NOT .FDL$GL_SWITCH;

	[ FDL$C_DATRC ]	: CURRENT_XAB [ XAB$V_DAT_NCMPR ] = NOT .FDL$GL_SWITCH;

	[ FDL$C_DUPS ]	: CURRENT_XAB [ XAB$V_DUP ] = .FDL$GL_SWITCH;

	[ FDL$C_IAREA ]	: CURRENT_XAB [ XAB$B_IAN ] = .FDL$GL_NUMBER;

	[ FDL$C_IDXC ]	: CURRENT_XAB [ XAB$V_IDX_NCMPR ] = NOT .FDL$GL_SWITCH;

	[ FDL$C_IFILL ]	: CURRENT_XAB [ XAB$W_IFL ] = .FDL$GL_NUMBER;

	[ FDL$C_KYNAME ]: BEGIN
			  CURRENT_XAB [ XAB$L_KNM ] = FDL$$GET_VM ( 32 );
			  CH$COPY( .FDL$AB_STRING [ DSC$W_LENGTH ],
				   .FDL$AB_STRING [ DSC$A_POINTER ],
				   SPACE,32,
				   .CURRENT_XAB [ XAB$L_KNM ] )
			  END;

	[ FDL$C_LAREA ]	: CURRENT_XAB [ XAB$B_LAN ] = .FDL$GL_NUMBER;

	[ FDL$C_NULL ]	: CURRENT_XAB [ XAB$V_NUL ] = .FDL$GL_SWITCH;

	[ FDL$C_NULLVAL]: CURRENT_XAB [ XAB$B_NUL ] = .FDL$GL_QUALIFIER;

	[ FDL$C_PROL ]	: IF .CURRENT_XAB [ XAB$B_REF ] EQLU 0
			  THEN
			      CURRENT_XAB [ XAB$B_PROLOG ] = .FDL$GL_NUMBER;

	[ FDL$C_SEGLEN ]: CASE .FDL$GL_SECNUM FROM 0 TO 7 OF
			  SET
			      [ 0 ] : CURRENT_XAB [ XAB$B_SIZ0 ] = .FDL$GL_NUMBER;
			      [ 1 ] : CURRENT_XAB [ XAB$B_SIZ1 ] = .FDL$GL_NUMBER;
			      [ 2 ] : CURRENT_XAB [ XAB$B_SIZ2 ] = .FDL$GL_NUMBER;
			      [ 3 ] : CURRENT_XAB [ XAB$B_SIZ3 ] = .FDL$GL_NUMBER;
			      [ 4 ] : CURRENT_XAB [ XAB$B_SIZ4 ] = .FDL$GL_NUMBER;
			      [ 5 ] : CURRENT_XAB [ XAB$B_SIZ5 ] = .FDL$GL_NUMBER;
			      [ 6 ] : CURRENT_XAB [ XAB$B_SIZ6 ] = .FDL$GL_NUMBER;
			      [ 7 ] : CURRENT_XAB [ XAB$B_SIZ7 ] = .FDL$GL_NUMBER;
			  TES;

	[ FDL$C_SEGPOS ]: CASE .FDL$GL_SECNUM FROM 0 TO 7 OF
			  SET
			      [ 0 ] : CURRENT_XAB [ XAB$W_POS0 ] = .FDL$GL_NUMBER;
			      [ 1 ] : CURRENT_XAB [ XAB$W_POS1 ] = .FDL$GL_NUMBER;
			      [ 2 ] : CURRENT_XAB [ XAB$W_POS2 ] = .FDL$GL_NUMBER;
			      [ 3 ] : CURRENT_XAB [ XAB$W_POS3 ] = .FDL$GL_NUMBER;
			      [ 4 ] : CURRENT_XAB [ XAB$W_POS4 ] = .FDL$GL_NUMBER;
			      [ 5 ] : CURRENT_XAB [ XAB$W_POS5 ] = .FDL$GL_NUMBER;
			      [ 6 ] : CURRENT_XAB [ XAB$W_POS6 ] = .FDL$GL_NUMBER;
			      [ 7 ] : CURRENT_XAB [ XAB$W_POS7 ] = .FDL$GL_NUMBER;
			  TES;

	[ FDL$C_SEGTYP ]: CASE .FDL$GL_SECNUM FROM 0 TO 7 OF
			  SET
			      [ 0 ] : BEGIN
				      CURRENT_XAB [ XAB$B_DTP ] = .FDL$GL_QUALIFIER;
				      CURRENT_XAB [ XAB$B_TYP0 ] = .FDL$GL_QUALIFIER
				      END;
			      [ 1 ] : CURRENT_XAB [ XAB$B_TYP1 ] = .FDL$GL_QUALIFIER;
			      [ 2 ] : CURRENT_XAB [ XAB$B_TYP2 ] = .FDL$GL_QUALIFIER;
			      [ 3 ] : CURRENT_XAB [ XAB$B_TYP3 ] = .FDL$GL_QUALIFIER;
			      [ 4 ] : CURRENT_XAB [ XAB$B_TYP4 ] = .FDL$GL_QUALIFIER;
			      [ 5 ] : CURRENT_XAB [ XAB$B_TYP5 ] = .FDL$GL_QUALIFIER;
			      [ 6 ] : CURRENT_XAB [ XAB$B_TYP6 ] = .FDL$GL_QUALIFIER;
			      [ 7 ] : CURRENT_XAB [ XAB$B_TYP7 ] = .FDL$GL_QUALIFIER;
			  TES;

    TES;

    RETURN

    END;

%SBTTL	'SET_RECORD_P'
ROUTINE	SET_RECORD_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the fab fields concerning the record
!
! Calling Sequence:
!
!	set_record_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

    REGISTER
	PARSED_FAB	: REF BLOCK [ ,BYTE ];

    PARSED_FAB = .FDL$AB_PARSED_FAB;

    ! Set em up
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_BLKSPN TO FDL$C_SIZE OF
    SET
	[ FDL$C_BLKSPN ]: PARSED_FAB [ FAB$V_BLK ] = NOT .FDL$GL_SWITCH;

	[ FDL$C_CARCTRL]: CASE .FDL$GL_QUALIFIER FROM FDL$C_NONE TO FDL$C_PRINT OF
		    SET
			! We must clear the other flags while setting the one
			! we want (without clearing BLK if set)
			!
			[ FDL$C_NONE ]  : PARSED_FAB [ FAB$B_RAT ] =
					  .PARSED_FAB [ FAB$B_RAT ] AND
							FAB$M_BLK;
			[ FDL$C_CR ]    : PARSED_FAB [ FAB$B_RAT ] =
					  ( .PARSED_FAB [ FAB$B_RAT ] AND
						FAB$M_BLK ) OR FAB$M_CR;
			[ FDL$C_FTN ]   : PARSED_FAB [ FAB$B_RAT ] =
					  ( .PARSED_FAB [ FAB$B_RAT ] AND
						FAB$M_BLK ) OR FAB$M_FTN;
			[ FDL$C_PRINT ] : PARSED_FAB [ FAB$B_RAT ] =
					  ( .PARSED_FAB [ FAB$B_RAT ] AND
						FAB$M_BLK ) OR FAB$M_PRN;
		    TES;

	[ FDL$C_VFCSIZ ]: PARSED_FAB [ FAB$B_FSZ ] = .FDL$GL_NUMBER;

	[ FDL$C_FMT ]	: PARSED_FAB [ FAB$B_RFM ] = .FDL$GL_QUALIFIER;

	[ FDL$C_SIZE ]	: PARSED_FAB [ FAB$W_MRS ] = .FDL$GL_NUMBER;
    TES;

    RETURN

    END;

%SBTTL	'SET_ACCESS_P'
ROUTINE	SET_ACCESS_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the fab fields concerning access mode
!
! Calling Sequence:
!
!	set_access_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

    REGISTER
	PARSED_FAB	: REF BLOCK [ ,BYTE ];

    PARSED_FAB = .FDL$AB_PARSED_FAB;

    ! Set em up
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_FACBIO TO FDL$C_FACUPD OF
    SET
	[ FDL$C_FACBIO ] : PARSED_FAB [ FAB$V_BIO ] = .FDL$GL_SWITCH;

	[ FDL$C_FACDEL ] : PARSED_FAB [ FAB$V_DEL ] = .FDL$GL_SWITCH;

	[ FDL$C_FACGET ] : PARSED_FAB [ FAB$V_GET ] = .FDL$GL_SWITCH;

	[ FDL$C_FACPUT ] : PARSED_FAB [ FAB$V_PUT ] = .FDL$GL_SWITCH;

	[ FDL$C_FACBRO ] : PARSED_FAB [ FAB$V_BRO ] = .FDL$GL_SWITCH;

	[ FDL$C_FACTRN ] : PARSED_FAB [ FAB$V_TRN ] = .FDL$GL_SWITCH;

	[ FDL$C_FACUPD ] : PARSED_FAB [ FAB$V_UPD ] = .FDL$GL_SWITCH;
    TES;

    RETURN

    END;

%SBTTL	'SET_SHARING_P'
ROUTINE	SET_SHARING_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the fab fields concerning sharing
!
! Calling Sequence:
!
!	set_sharing_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

    REGISTER
	PARSED_FAB	: REF BLOCK [ ,BYTE ];

    PARSED_FAB = .FDL$AB_PARSED_FAB;

    ! Set em up
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_SHRDEL TO FDL$C_SHRUPI OF
    SET
	[ FDL$C_SHRDEL ] : PARSED_FAB [ FAB$V_SHRDEL ] = .FDL$GL_SWITCH;

	[ FDL$C_SHRGET ] : PARSED_FAB [ FAB$V_SHRGET ] = .FDL$GL_SWITCH;

	[ FDL$C_SHRMSE ] : PARSED_FAB [ FAB$V_MSE ] = .FDL$GL_SWITCH;

	[ FDL$C_SHRNIL ] : PARSED_FAB [ FAB$V_NIL ] = .FDL$GL_SWITCH;

	[ FDL$C_SHRPUT ] : PARSED_FAB [ FAB$V_SHRPUT ] = .FDL$GL_SWITCH;

	[ FDL$C_SHRUPD ] : PARSED_FAB [ FAB$V_SHRUPD ] = .FDL$GL_SWITCH;

	[ FDL$C_SHRUPI ] : PARSED_FAB [ FAB$V_UPI ] = .FDL$GL_SWITCH;
    TES;

    RETURN

    END;

%SBTTL	'SET_CONNECT_P'
ROUTINE	SET_CONNECT_P : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the Rab fields
!
! Calling Sequence:
!
!	set_connect_p()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

    REGISTER
	PARSED_RAB	: REF BLOCK [ ,BYTE ];

    PARSED_RAB = .FDL$AB_PARSED_RAB;

    ! Set em up
    !
    CASE .FDL$GL_SECONDARY FROM FDL$C_ASY TO FDL$C_WBH OF
    SET
	[ FDL$C_ASY ]	 : PARSED_RAB [ RAB$V_ASY ] = .FDL$GL_SWITCH;

	[ FDL$C_BIO ]	 : PARSED_RAB [ RAB$V_BIO ] = .FDL$GL_SWITCH;

	[ FDL$C_BUCODE ] : PARSED_RAB [ RAB$L_BKT ] = .FDL$GL_NUMBER;

	[ FDL$C_RCTX ]	 : PARSED_RAB [ RAB$L_CTX ] = .FDL$GL_NUMBER;

	[ FDL$C_EOF ]	 : PARSED_RAB [ RAB$V_EOF ] = .FDL$GL_SWITCH;

	[ FDL$C_FLOA ]	 : PARSED_RAB [ RAB$V_LOA ] = .FDL$GL_SWITCH;

	[ FDL$C_FDEL ]	 : PARSED_RAB [ RAB$V_FDL ] = .FDL$GL_SWITCH;

	[ FDL$C_KGE ]	 : PARSED_RAB [ RAB$V_KGE ] = .FDL$GL_SWITCH;

	[ FDL$C_KGT ]	 : PARSED_RAB [ RAB$V_KGT ] = .FDL$GL_SWITCH;

	[ FDL$C_KLIM ]	 : PARSED_RAB [ RAB$V_LIM ] = .FDL$GL_SWITCH;

	[ FDL$C_KRF ]	 : PARSED_RAB [ RAB$B_KRF ] = .FDL$GL_NUMBER;

	[ FDL$C_LOCMODE ] : PARSED_RAB [ RAB$V_LOC ] = .FDL$GL_SWITCH;

	[ FDL$C_REA ]	 : PARSED_RAB [ RAB$V_REA ] = .FDL$GL_SWITCH;

	[ FDL$C_RLK ]	 : PARSED_RAB [ RAB$V_RLK ] = .FDL$GL_SWITCH;

	[ FDL$C_ULK ]	 : PARSED_RAB [ RAB$V_ULK ] = .FDL$GL_SWITCH;

	[ FDL$C_MBC ]	 : PARSED_RAB [ RAB$B_MBC ] = .FDL$GL_NUMBER;

	[ FDL$C_MBF ]	 : PARSED_RAB [ RAB$B_MBF ] = .FDL$GL_NUMBER;

	[ FDL$C_NLK ]	 : PARSED_RAB [ RAB$V_NLK ] = .FDL$GL_SWITCH;

	[ FDL$C_NXR ]	 : PARSED_RAB [ RAB$V_NXR ] = .FDL$GL_SWITCH;

	[ FDL$C_RAH ]	 : PARSED_RAB [ RAB$V_RAH ] = .FDL$GL_SWITCH;

	[ FDL$C_RRL ]	 : PARSED_RAB [ RAB$V_RRL ] = .FDL$GL_SWITCH;

	[ FDL$C_TMO ]	 : PARSED_RAB [ RAB$B_TMO ] = .FDL$GL_NUMBER;

	[ FDL$C_TMENB ]	 : PARSED_RAB [ RAB$V_TMO ] = .FDL$GL_SWITCH;

	[ FDL$C_TPT ]	 : PARSED_RAB [ RAB$V_TPT ] = .FDL$GL_SWITCH;

	[ FDL$C_TTCCO ]	 : PARSED_RAB [ RAB$V_CCO ] = .FDL$GL_SWITCH;

	[ FDL$C_TTCVT ]	 : PARSED_RAB [ RAB$V_CVT ] = .FDL$GL_SWITCH;

	[ FDL$C_TTPMT ]	 : PARSED_RAB [ RAB$V_PMT ] = .FDL$GL_SWITCH;

	[ FDL$C_TTPTA ]	 : PARSED_RAB [ RAB$V_PTA ] = .FDL$GL_SWITCH;

	[ FDL$C_TTRNE ]	 : PARSED_RAB [ RAB$V_RNE ] = .FDL$GL_SWITCH;

	[ FDL$C_TTRNF ]	 : PARSED_RAB [ RAB$V_RNF ] = .FDL$GL_SWITCH;

	[ FDL$C_UIF ]	 : PARSED_RAB [ RAB$V_UIF ] = .FDL$GL_SWITCH;

	[ FDL$C_WAT ]	 : PARSED_RAB [ RAB$V_WAT ] = .FDL$GL_SWITCH;

	[ FDL$C_WBH ]	 : PARSED_RAB [ RAB$V_WBH ] = .FDL$GL_SWITCH;
    TES;

    RETURN

    END;

%SBTTL	'SET_PROT'
ROUTINE	SET_PROT : NOVALUE =
!++
!
! Functional Description:
!
!	Fill in the blanks for the protection xab
!
! Calling Sequence:
!
!	set_prot()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
!	fdl$secondary	- Secondary code
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!	none
!
!--

    BEGIN

    ! See if the protection xab has been allocated yet
    !
    IF .PROTECTION_XAB EQLU 0
    THEN

	! Allocate the xab an enter it into the chain
	!
	PROTECTION_XAB = ALLOCATE_XAB ( XAB$C_PRO, 0 );

    ! Set the fields according to the secondary
    !
    SELECTONEU .FDL$GL_SECONDARY OF
    SET
	[ FDL$C_MTPRO ]	: PROTECTION_XAB [ XAB$B_MTACC ] = .FDL$GL_QUALIFIER;

	[ FDL$C_PROT ]	: PROTECTION_XAB [ XAB$W_PRO ] = NOT .FDL$GL_PROTECTION;

	[ FDL$C_OWNER ]	: PROTECTION_XAB [ XAB$L_UIC ] = .FDL$GL_OWNER_UIC;
    TES;

    RETURN

    END;

%SBTTL	'ALLOCATE_XAB'
ROUTINE	ALLOCATE_XAB ( XAB_TYPE, XAB_NUM ) =
!++
!
! Functional Description:
!
!	Allocates an RMS extended attribute block from virtual memory
!
!	*************************************************************
!
!	NOTE: THIS ROUTINE ASSUMES XABs ARE CONNECTED TO THE $FAB !!!
!	IT WILL NOT WORK WITH XABs THAT ARE CONNECTED TO THE $RAB !!!
!
!	*************************************************************
!
! Calling Sequence:
!
!	allocate_xab( xab_type, xab_num )
!
! Input Parameters:
!
!	xab_type	- The RMS code for the type of xab wanted ie. XAB$C_xab
!	xab_num		- Which xab is desired (for key and area xabs)
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	Pointer to the new xab (also pointed to by current xab)
!
! Routines Called:
!
!	fdl$$get_vm
!
! Side Effects:
!
!	current_xab pointes to the new xab
!
!--

    BEGIN

    LOCAL
	XAB	: REF BLOCK [ ,BYTE ],
	FOUND,
	XAB_LEN,
	NEW_XAB;

    ! Find the size of the type of xab we want.
    !
    XAB_LEN = ( SELECTONEU .XAB_TYPE OF
		SET
		[ XAB$C_ALL ] : XAB$C_ALLLEN;
		[ XAB$C_DAT ] : XAB$C_DATLEN;
		[ XAB$C_JNL ] : XAB$C_JNLLEN;
		[ XAB$C_KEY ] : XAB$C_KEYLEN;
		[ XAB$C_PRO ] : XAB$C_PROLEN;
		[ XAB$C_RDT ] : XAB$C_RDTLEN;
		TES );

    FOUND = _CLEAR;

    ! See if the xab we need already exists
    ! (if we're in the second parse)
    !
    IF (
    ( .FDL$AB_CTRL [ FDL$V_REPARSE ] )
    AND
    ( ( .XAB_TYPE EQLU XAB$C_ALL ) OR ( .XAB_TYPE EQLU XAB$C_KEY ) )
    ) THEN
	BEGIN

	XAB = .FDL$AB_PARSED_FAB [ FAB$L_XAB ];

	WHILE .XAB NEQU 0
	DO
	    BEGIN

	    IF (
		(( .XAB_TYPE EQLU XAB$C_ALL )
		AND
		( .XAB [ XAB$B_COD ] EQLU XAB$C_ALL )
		AND
		( .XAB [ XAB$B_AID ] EQLU .XAB_NUM ))
	    OR
		(( .XAB_TYPE EQLU XAB$C_KEY )
		AND
		( .XAB [ XAB$B_COD ] EQLU XAB$C_KEY )
		AND
		( .XAB [ XAB$B_REF ] EQLU .XAB_NUM ))
	    ) THEN
		BEGIN

		NEW_XAB = .XAB;
		FOUND = _SET;
		EXITLOOP;

		END;

	    XAB = .XAB [ XAB$L_NXT ];

	    END;

	END;

    IF NOT .FOUND
    THEN
	BEGIN

	! Allocate a buffer for the new xab
	!
	NEW_XAB = FDL$$GET_VM( .XAB_LEN );

	! If this is the first xab link it to the fab else just connect it to
	! the last xab in the chain
	!
	IF .FDL$AB_PARSED_FAB [ FAB$L_XAB ] EQL 0
	THEN
	    FDL$AB_PARSED_FAB [ FAB$L_XAB ] = .NEW_XAB
	ELSE
	    END_XAB [ XAB$L_NXT ] = .NEW_XAB;

	END_XAB = .NEW_XAB;

	END;

    ! Make this xab the current one
    !
    CURRENT_XAB = .NEW_XAB;

    IF NOT .FOUND
    THEN
	BEGIN

	! Init. some stuff in it
	!
	CURRENT_XAB [ XAB$B_COD ] = .XAB_TYPE;
	CURRENT_XAB [ XAB$B_BLN ] = .XAB_LEN;
	CURRENT_XAB [ XAB$L_NXT ] = 0;

	END;

    RETURN .CURRENT_XAB

    END;

%SBTTL	'FIND_ID'
ROUTINE FIND_ID : NOVALUE =
!++
!
! Functional Description:
!
!	Finds a file ID of a file specified by the FDL$STRING descriptor
!
! Calling Sequence:
!
!	find_id()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	fdl$$get_vm
!
! Side Effects:
!	none
!
!--

    BEGIN

    LOCAL
	FAB	: REF BLOCK [ ,BYTE ],
	NAM	: REF BLOCK [ ,BYTE ];

    ! Get the address space for the FAB and the Name block
    !
    FAB = FDL$$GET_VM( FAB$K_BLN );

    NAM = FDL$$GET_VM( NAM$K_BLN + ESA_BUF_SIZ );

    !  +--------------+
    !  I    nam blk   I
    !  +--------------+
    !  I  exp str buf I
    !  +--------------+
    !
    ! Init the blocks and fill in all of the good stuff
    !
    $FAB_INIT ( FAB = .FAB,
		FNA = .FDL$AB_STRING [ DSC$A_POINTER ],
		FNS = .FDL$AB_STRING [ DSC$W_LENGTH ],
		NAM = .NAM );

    $NAM_INIT ( ESA = .NAM + NAM$K_BLN,
		ESS = ESA_BUF_SIZ,
		NAM = .NAM );

    ! Parse and search for the file
    !
    IF $PARSE( FAB=.FAB )
    THEN

	IF $SEARCH( FAB=.FAB )
	THEN
	    BEGIN

	    ! Get the old file ID
	    !
	    FDL$GL_FID1 = .NAM [ NAM$W_FID_NUM ];
	    FDL$GL_FID2 = .NAM [ NAM$W_FID_SEQ ];
	    FDL$GL_FID3 = .NAM [ NAM$W_FID_RVN ]

	    END
	ELSE
	    SIGNAL( FDL$_RFLOC )
    ELSE
	SIGNAL( FDL$_RFLOC );

    ! Deallocate the space we used
    !
    FDL$$FREE_VM( FAB$K_BLN, .FAB );
    FDL$$FREE_VM( NAM$K_BLN+ESA_BUF_SIZ, .NAM );

    RETURN

    END;

%SBTTL	'GET_VM'
GLOBAL ROUTINE FDL$$GET_VM( BYTES ) =
!++
!
! Functional Description:
!
!	Allocate virtual memory and zeros it
!
! Calling Sequence:
!
!	fdl$$get_vm( bytes )
!
! Input Parameters:
!
!	bytes	- number of bytes to allocate
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	address of the start of the buffer
!
! Routine Called:
!
!	lib$get_vm
!
! Side Effects:
!	none
!
!--

    BEGIN

    LOCAL
	VM_POINTER;

    ! If we don't succede signal an error and stop
    !
    IF NOT LIB$GET_VM ( BYTES,VM_POINTER )
    THEN
	SIGNAL_STOP ( FDL$_INSVIRMEM );

    ! Zero this address space
    !
    CH$FILL ( 0,.BYTES,.VM_POINTER );

    RETURN .VM_POINTER

    END;

%SBTTL	'FREE_VM'
GLOBAL ROUTINE FDL$$FREE_VM( BYTES,ADDR ) : NOVALUE =
!++
!
! Functional Description:
!
!	Deallocate virtual memory
!
! Calling Sequence:
!
!	fdl$$free_vm( bytes,addr )
!
! Input Parameters:
!
!	bytes	- number of bytes to deallocate
!	addr	- address of block
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routine Called:
!
!	lib$free_vm
!
! Side Effects:
!	none
!
!--

    BEGIN

    LOCAL
	STATUS;

    ! If we don't succede signal an error and stop
    !
    IF NOT ( STATUS = LIB$FREE_VM ( BYTES,ADDR ) )
    THEN
	SIGNAL_STOP ( .STATUS );

    RETURN

    END;

END ELUDOM
