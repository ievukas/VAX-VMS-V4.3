%TITLE 'EDT$IOMOD - I/O for VAX/VMS'
MODULE EDT$IOMOD (				! I/O for VAX/VMS
		IDENT = 'V04-000'			! FILE: IOMOD.B32 EDIT: REM2102
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	EDT -- The DEC Standard Editor
!
! ABSTRACT:
!
!	This module contains all the I/O interface code for VAX/VMS
!	systems.
!
! ENVIRONMENT: VAX/VMS only
!
! AUTHOR: Bob Kushlis, CREATION DATE: 28-JUL-1979
!
! MODIFIED BY:
!
! Dan Szymanski, 04-DEC-80, 02
!	FAB$M_MXV added in EDT$$OPN_OFIDEF  so that the output file if created with
!	a maximized version number.
!
! Dan Szymanski, 16-DEC-80, 03
!	Trailing : removed during recursive translation of SYS$INPUT in EDT$$TI_OPN .
!
! John Sauter, 19-Dec-1980, 04
!	Added calls to trace package under conditional compilation.
!
! 2-005	- Regularized the headers.  JBS 17-Feb-1981
! 2-006	- Make PIC, get the event flag numbers dynamicly, carry protection to
!	   output files from the first input file, and manipulate storage using
!	   LIB$GET_VM and LIB$FREE_VM.  JBS 17-Feb-1981
! 2-007	- Add a new entry point to close the work file, and removed some globals
!	   made unnecessary by it.  JBS 18-Feb-1981
! 2-008	- Make EDT$$FATAL_IOERR  global, to avoid calls to SY_EXIT.  JBS 19-Feb-1981
! 2-009	- Add EDT$$G_IOFI_NFND , remove IO_FNF and make IO_STS not
!	   global.  JBS 19-Feb-1981
! 2-010	- Fix module name.  JBS 06-Mar-1981
! 2-011	- Fix remaining IO_ entry points.  JBS 30-Mar-1981
! 2-012	- Only get event flags if we don't already have them.  JBS 02-Apr-1981
! 2-013	- Use the ASSERT macro.  JBS 01-Jun-1981
! 2-014	- Put the work file on SYS$SCRATCH, and use EDTWORK as a logical name
!	   for it.  JBS 01-Jun-1981
! 2-015	- Fix a typo that caused buckets to never be marked dirty.  JBS 04-Jun-1981
! 2-016	- In response to a request from the VMS group, make all terminals $QIOs be
!	   $QIOWs, for compatibility with the VMS 3.0 terminal driver, which will
!	   not always use buffered I/O.  Maybe later we can find time to smarten up
!	   the code.  JBS 06-Jun-1981
! 2-017	- Arrange to allocate the event flags before entering change mode, if necessary.
!	   JBS 06-Jun-1981
! 2-018	- Fix up the protection.  The work file needs only system delete, owner read,
!	   write and delete.  Other output files have the same protection as the primary
!	   input file.  JBS 08-Jul-1981
! 2-019	- Use the new message codes.  JBS 05-Aug-1981
! 2-020	- Add a missing call to $$TRACE, to pick up a prompt.  JBS 06-Aug-1981
! 2-021	- Correct a call to $$TRACE_READ, which was clobbering TT_CHAN.  JBS 07-Aug-1981
! 2-022	- Use EDT$$ALO_HEAP  and EDT$$DEA_HEAP  instead of
!	   LIB$GET_VM and LIB$FREE_VM.  JBS 07-Aug-1981
! 2-023	- Correct a bug in reading trace files.  JBS 19-Aug-1981
! 2-024	- When reading a trace file, don't interact with the terminal.  This will allow
!	   EDT running in a batch job to read trace files.  JBS 20-Aug-1981
! 2-025	- If the terminal type is unknown, but it is an ANSI-mode scope terminal, assume
!	   it is a VT100.  This is needed because the terminal type distinguishes the
!	   VT100 from the VT101, VT102, VT125, etc which are compatible with it.
!	   JBS 16-Nov-1981
! 2-026	- Put a test in EDT$$TI_OPN so it is a noop if called twice.  This is needed because
!	   in tracing EDT it is called from startup as well as init.  JBS 17-Dec-1981
! 2-027 - Set default terminal width to system's terminal width.  SMB 23-Dec-1981
! 2-028 - make file i/o routines pass back status to caller.  STS 06-Jan-1982
! 2-029	- Run through PRETTY.  JBS 12-Jan-1982
! 2-030 - Pass error information from opn_ifi back to fileio. STS 13-Jan-1982
! 2-031 - Pass error info from opn_ofi back to fileio. STS 13-Jan-1982
! 2-032 - Pass error info from read and write routines back. STS 15-Jan-1982
! 2-033 - Pass error info from delete journal file. STS 18-Jan-1982
! 2-034 - Make sure NAM$B_RSL is non-zero. STS 19-Jan-1982
! 2-035	- Remove an extra dot in RHB handling.  JBS 21-Jan-1982
! 2-036 - Add check for VFC file when opening and getting. STS 22-Jan-1982
! 2-037	- Don't call a PRN file VFC.  JBS 30-Jan-1982
! 2-038 - Pass workfile bucket back in descriptor. STS 02-Feb-1982
! 2-039 - Delete edt$$get_fnam. STS 12-Feb-1982
! 2-040 - Add descriptor to parameters passed to edt$$wf_wr and edt$$wf_rd.
!	  STS 15-Feb-1982
! 2-041	- Track the new terminal driver's data structures.  JBS 21-Feb-1982
! 2-042 - Initialize record attribute for primary file to CR. STS 05-Mar-1982
! 2-043 - Don't signal on exceeded disk if ctx bit not set. STS 18-Mar-1982
! 2-044	- Add a parameter to control use of related file name.  JBS 24-Mar-1982
! 2-045	- Only remember input file name and attributes on the first input open,
!	   even if it fails.  JBS 26-Mar-1982
! 2-046	- Add a flag for non-standard input file.  JBS 26-Mar-1982
! 2-047 - Add a rename module.  SMB 31-Mar-1982
! 2-048 - Change CLOSE to delete an output file or journal file.  SMB 08-Apr-1982
! 2-049	- Make the FORWARD declaration of CLOSE agree with the body.  JBS 09-Apr-1982
! 2-050	- Remove EDT$$GET_IFIATTR, no longer used.  JBS 09-Apr-1982
! 2-051	- Don't do 0-length terminal QIOs.  JBS 09-Apr-1982
! 2-052	- Make EDT$$WF_CLS return a value and use the new message.  JBS 12-Apr-1982
! 2-053 - Add the parse routine.  SMB 13-Apr-1982
! 2-054 - Get device type during parse of output file.  SMB 26-Apr-1982
! 2-055 - Fix bug in RENAMing given an explicit file version number.  SMB 04-May-1982
! 2-056 - Check for Process Permanent File on the Parse of output file.  SMB 11-May-1982
! 2-057 - Make minor modifications based on code review input.  SMB 25-May-1982
! 2-058	- Don't check for record too long--check in EDT$WFREAINP instead.  JBS 02-Jun-1982
! 2-059 - Change file attributes on EXIT with sequenced file.  SMB 07-Jun-1982
! 2-060 - Pass back STV on parse of output file.  SMB 14-Jun-1982
! 2-061	- Revise handling of file name defaulting.  JBS 16-Jun-1982
! 2-062 - Pass back STV on flush of output buffer. STS 01-Jul-1982
! 2-063	- Use an action routine with $PUTMSG so we can control access to the screen.
!	   JBS 06-Jul-1982
! 2-064 - Make the status and stv vector global. STS 20-Jul-1982
! 2-065 - Save and restore all terminal characteristics.  SMB 28-Jul-1982
! 2-066 - Correctly report terminal read errors. STS 06-Aug-1982
! 2-067	- Add EDT$$INIT_IO.  JBS 27-Aug-1982
! 2-068	- Add EDT$$G_TI_SCROLL and start on long typeahead.  JBS 31-Aug-1982
! 2-069	- Add EDT$$G_TI_EDIT; if the terminal is not a VT100,
!	   don't use autorepeat.  JBS 02-Sep-1982
! 2-070	- Use escape mode to minimize the number of QIOs required.  JBS 03-Sep-1982
! 2-071	- Don't read the typeahead buffer in escape mode.  JBS 07-Sep-1982
! 2-072	- Don't use escape mode when either tracing is active or a keypad
!	   prompt is specified.  This is to keep the QA system working,
!	   since we don't implement escape mode on the PDP-11s.  JBS 08-Sep-1982
! 2-073	- Add another case of not using escape mode when there is a keypad
!	   prompt.  JBS 09-Sep-1982
! 2-074	- In trace mode, initialize with autorepeat enabled, for PDP-11 compatibility.
!	   JBS 10-Sep-1982
! 2-075	- Add EDT$$G_TI_DUMB.  JBS 16-Oct-1982
! 2-076	- Try to reduce the number of buffered I/Os.  JBS 10-Nov-1982
! 2-077 - Don't do copies to and from workfile - but pass addresses.  11-Nov-1982
! 2-078 - Allocate cache only as needed, and open workfile only after
!	   cache is exhausted. STS 16-Nov-1982
! 2-079	- VT125s should default to AUTOREPEAT.  JBS 01-Dec-1982
! 2-080 - Signal any errors from opening the terminal. STS 13-Dec-1982
! 2-081 - Signal errors reading from terminal and add more detail
! 	   to error messages when opening terminal fails. STS 15-Dec-1982
! 2-082 - Add routine edt$$ti_deas to deassign the terminal channel. STS 21-Dec-1982
! 2-083	- In EDT$$TI_DEAS, set OWN storage to its initial state and signal any errors.  JBS 28-Dec-1982
! 2-084	- Don't deassign the terminal channel if tracing.  JBS 29-Dec-1982
! 2-085	- Allocate window blocks from the end to speed up FIND_WINDOW, and do some code bumming in FIND_WINDOW
!	   to the same end.  JBS 03-Jan-1983
! 2-086	- Revise the logic for handling control Y so that we loop waiting for a character.  JBS 19-Jan-1983
! 2-087	- Add EDT$$TERM_RCC.  JBS 26-Jan-1983
! 2-088	- Remove reference to EDT$$OUT_ERRMSG, not used.  JBS 22-Mar-1983
! 2-089	- Don't do fancy output if the file type is .TMP.  JBS 01-Apr-1983
! 2-090	- On exit, set application keypad mode or numeric keypad mode, as the user requests.  JBS 01-Apr-1983
! 2-091	- Don't force maximum version number unless requested.  JBS 04-Apr-1983
! 2-092	- Improve the appearance of the listing.  JBS 14-Jun-1983
! 2-093	- Fix a typo caused by edit 2-092.  JBS 16-Jun-1983
! 2-094	- Defend the terminal QIOs against SYS$INPUT not being a terminal.  JBS 21-Jun-1983
! 2-095	- Try improving performance by extending files less often.  JBS 22-Aug-1983
! 2-096	- More performance improvements based on Chris Saether's advice.  JBS 29-Aug-1983
! 2-097 - Add test for VT55 and treat it as a VT52.  REM 3-Nov-1983
! 2-098 - Support EDT$$G_DEC_CRT.  REM 2-Mar-1984
! 2-099 - Add logic to make TT2$V_APP_KEYPAD & TT2$V_DECCRT2 always return false
!	  if they are not defined in STARLET.  REM 6-Mar-1984
! 2-100 - Removed macros for the previous fix and inserted conditional compila-
!	  tion around the usage of the cells in question.  REM 19-Mar-1984
! 2-101 - Added logic to cause the rename function (that renames the temp file
!	  to be the new output file) to propagate the ACL from the input file.
!	  This compiles only if XAB$B_PROT_OPT is defined.  REM 21-Mar-1984
! 2-102 - Fixed conditional compilation so that VT102s etc. get EDT$$G_DEC_CRT
!	  properly set.  REM 1-May-1984
!--


%SBTTL 'Declarations'
!
! TABLE OF CONTENTS:
!

REQUIRE 'EDTSRC:TRAROUNAM';

FORWARD ROUTINE
    EDT$$IO_ERRMSG : NOVALUE,
    PUTMSG_ACTION,
    EDT$$FATAL_IOERR : NOVALUE,
    EDT$$INIT_IO : NOVALUE,
    EDT$$WF_OPN,
    EDT$$WF_CLS,
    WF_OPN,
    FIND_WINDOW,
    EDT$$WF_WR : NOVALUE,
    WRITE_WINDOW : NOVALUE,
    REPLACE_WINDOW,
    GET_WF : NOVALUE,
    EDT$$WF_RD : NOVALUE,
    EDT$$PAR_FNAME,
    EDT$$OPN_INOUT,
    EDT$$OPN_IFIDEF,
    EDT$$OPN_OFIDEF,
    EDT$$CLS_FI,
    EDT$$RD_IFI,
    EDT$$WR_OFI,
    EDT$$REN_FI,
    EDT$$FLUSH_OBUF,
    CC_ENABLE,
    CC_AST : NOVALUE,
    EDT$$TERM_RCC : NOVALUE,
    EDT$$TI_OPN,
    EDT$$TI_RES,
    EDT$$TI_DEAS : NOVALUE,
    EDT$$RD_CMDLN,
    EDT$$TI_WRLN : NOVALUE,
    EDT$$TI_GETCH : NOVALUE,
    EDT$$TI_WRSTR : NOVALUE,
    EDT$$TI_RDTYAHED,
    EDT$$TI_RDSTR : NOVALUE,
    EDT$$TI_ENTERCHM : NOVALUE,
    EDT$$TI_LEAVECHM : NOVALUE;

!
! INCLUDE FILES:
!

REQUIRE 'EDTSRC:EDTREQ';

REQUIRE 'EDTSRC:SYSSYM';

REQUIRE 'TRACESEL';				! Turn tracing on or off

REQUIRE 'EDTSRC:TRACEMAC';			! Define $$TRACE macro

!
! MACROS:	None
!
!
! EQUATED SYMBOLS:
!

FIELD
    ITEM_FIELDS = 				! Item list fields
	SET
	BF_LEN = [0, 0, 16, 0],			! Buffer length
	I_CODE = [0, 16, 16, 0],		! Item code
	BUF_ADR = [1, 0, 32, 0],		! Buffer address
	RLEN_ADR = [2, 0, 32, 0]		! Return length address
	TES;

FIELD
    SETM_FIELDS = 				! SETMODE fields
	SET
	S_CLASS = [0, 0, 8, 0],			! Class
	S_TYPE = [0, 8, 8, 0],			! Type
	S_WID = [0, 16, 16, 0],			! Terminal width
	S_CHAR = [1, 0, 32, 0]			! Characteristics
	TES;

LITERAL
    EDT$K_FAC_NO = 133,
    WINDOW_SIZE = 11,				! The number of buckets in a cache slot
    NUM_WINDOW = 100;				! The number of windows to cache

!
! OWN STORAGE:
!

OWN
    CACHE_ADDR : VECTOR [NUM_WINDOW],		! The start address of the heap storage for this window
    CACHE_TIMER,				! Counter incremented for each reference
    CACHE_WINDOW : VECTOR [NUM_WINDOW],		! The number of the window in a slot
    CACHE_REF : VECTOR [NUM_WINDOW],		! The timer at the last reference to this window
    CACHE_DIRTY : VECTOR [NUM_WINDOW, BYTE];	! The window dirty flag.

OWN
    WF_CACHE_FULL,
    WF_OPEN,
    MYBUF : BLOCK [CH$ALLOCATION (256)],
    MYBUF2 : BLOCK [CH$ALLOCATION (256)],
    INPUT_NAME : BLOCK [NAM$C_MAXRSS, BYTE],
    INPUT_NAME_LEN,
    INPUT_RAT,
    INPUT_RFM,
    INPUT_PROT,
    INPUT_MRS,
    ATTRIBUTES_SET : INITIAL (0),		! 1 = input attributes have been set
    ATTRIBUTES_DEFAULTED : INITIAL (0),		! 1 = input attributes = default attributes
    JOURNAL_NAM : $NAM_DECL,			! NAM block for the journal file (so we can delete it)
    NAM_BLOCK : $NAM_DECL,		! NAM  block for last output file opened (so we can delete it)
    TERM_IN_RAB : $RAB_DECL,
    TERM_OUT_RAB : $RAB_DECL,
    IOSB : VECTOR [4, WORD],
    TT_CHAN,
    TT_OPEN : INITIAL (0),			! 1 = terminal open
    T_DEVCHAR : BLOCK [4, BYTE],		! Terminal independent characteristics
    t_devclass : BLOCK [4, BYTE],		! Device class
    T_DEVDEP : BLOCK [4, BYTE],			! Terminal dependent characteristics
    t_devextdep : BLOCK [4, BYTE],		! Terminal extended characteristics
    t_devtype : BLOCK [4, BYTE],		! Terminal type
    T_DEVWID : BLOCK [4, BYTE],			! Terminal width
    INPUT_EFN,
    OUTPUT_EFN,
    HAVE_EFNS : INITIAL (0),			! 1 = event flags allocated
    WF_IFI,
    IO_WF_RAB : $RAB_DECL,
    IO_MVEC : INITIAL (2),			! Message to print from EDT$$IO_ERRMSG
    IO_STS,
    IO_STV;

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    EDT$$FMT_STR,
    EDT$$FMT_CRLF,				! Terminate a line
    EDT$$FMT_MSG,
    EDT$$SC_RESET,
    EDT$$MSG_TOSTR,
    EDT$$ALO_HEAP,
    EDT$$DEA_HEAP : NOVALUE;

EXTERNAL
    EDT$$G_TI_PLEN,
    EDT$$G_TI_RESET,
    EDT$$G_JOU_IFI,
    EDT$$G_EDIT_MOD,
    EDT$$G_TI_TYP,
    EDT$$G_TI_WID,
    EDT$$G_CC : VOLATILE,
    EDT$$G_DEC_CRT,
    EDT$$G_EIGHT_BIT,
    EDT$$T_FMT_BUF,
    EDT$$A_FMT_CUR,
    EDT$$T_RDAHED : BLOCK [CH$ALLOCATION (K_RDAHED_LEN)],	! Read-ahead buffer
    EDT$$G_RDAHED,				! Number of characters in read-ahead buffer
    EDT$$G_TI_SCROLL,				! 1 = terminal has scrolling regions
    EDT$$G_TI_EDIT,				! 1 = terminal has editing features (ICM, DCH, IL, DL)
    EDT$$G_ENB_AUTRPT,				! 1 = OK to use Autorepeat
    EDT$$G_TI_DUMB,				! 1 = terminal driver needs CR to avoid wrapping lines
    EDT$$T_PMT_KPD : VECTOR [, BYTE];		! Counted string of keypad prompt

OWN
    VFCHD : BLOCK [CH$ALLOCATION (255)];	! Sequence no. in VFC files.

GLOBAL
    EDT$$G_IO_MVEC : INITIAL (2),
    EDT$$G_IO_STS,
    EDT$$G_IO_STV;

%IF edt$$tr_act
%THEN

GLOBAL
    EDT$$L_TR_INFLG;				! 1 iff input from trace file

%FI

EXTERNAL ROUTINE
    STR$COPY_R,
    LIB$GET_EF,
    LIB$FREE_EF;

!+
! This module uses the following message codes:
!-
MESSAGES ((EDITORABO, OPNINTRM, OPNOUTTRM, ERRINPTRM, INSMEM, IOERRWRK, WORFILCLO));

%SBTTL 'EDT$$IO_ERRMSG  - print an I/O error message'

GLOBAL ROUTINE EDT$$IO_ERRMSG 			! Print an I/O error message
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Put out an I/O (RMS) error message.  The status and stv have already
!	been placed in the message vector by fiohndlr.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!    EDT$$G_IO_MVEC
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Sends text to the screen.
!
!--

    BEGIN
    $PUTMSG (MSGVEC = EDT$$G_IO_MVEC, ACTRTN = PUTMSG_ACTION);
    END;					! of routine EDT$$IO_ERRMSG


%SBTTL 'PUTMSG_ACTION - Dispose of $PUTMSG''s text'
ROUTINE PUTMSG_ACTION (				! Dispose of $PUTMSG's text
    TEXT_DESC					! The text to be printed
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by $PUTMSG for each line to output.
!	Output the text through EDT's formatting routines, and tell
!	$PUTMSG to not output it.
!
! FORMAL PARAMETERS:
!
!  TEST_DESC		A descriptor for the line of text to be output
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Always 0, to tell $PUTMSG not to output the text itself
!
! SIDE EFFECTS:
!
!	Sends text to the screen.
!
!--

    BEGIN

    MAP
	TEXT_DESC : REF BLOCK [8, BYTE];

!+
! Send the string to the format buffer.
!-
    EDT$$FMT_STR (.TEXT_DESC [DSC$A_POINTER], .TEXT_DESC [DSC$W_LENGTH]);
!+
! Terminate the line.
!-
    EDT$$FMT_CRLF ();
!+
! Tell $PUTMSG to not output the line.
!-
    RETURN (0);
    END;					! of routine PUTMSG_ACTION

%SBTTL 'EDT$$FATAL_IOERR  - put out an I/O error message and abort'

GLOBAL ROUTINE EDT$$FATAL_IOERR (		! Put out an I/O error message and abort
    N						! Not used
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Put out an I/O error message and abort.
!
! FORMAL PARAMETERS:
!
!	N		Not used.
!
! IMPLICIT INPUTS:
!
!	EDT$$G_EDIT_MOD
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Calls EDT$$SC_RESET  and EDT$$IO_ERRMSG .
!	Never returns to its caller.
!--

    BEGIN
!+
! Reset any screen modes.
!-

    IF (.EDT$$G_EDIT_MOD EQL CHANGE_MODE) THEN EDT$$SC_RESET ();

    EDT$$IO_ERRMSG ();
    SIGNAL_STOP (EDT$_EDITORABO);
    END;					! of routine EDT$$FATAL_IOERR


%SBTTL 'EDT$$INIT_IO - Initialize the I/O system'

GLOBAL ROUTINE EDT$$INIT_IO 			! Initialize the I/O system
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do any initialization needed before any devices are opened.
!	On VMS, this is none.  It must remain none because of callable EDT.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    RETURN;
    END;					! of routine EDT$$INIT_IO


%SBTTL 'WF_OPN  - Open work file'
ROUTINE WF_OPN 					! Open work file
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Open the work file.  Abort if it fails.
!	The work file is opened in SYS$SCRATCH.  The cache area is allocated from virtual memory.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IO_STS
!	IO_STV
!	WF_IFI
!	CACHE_ADDR
!
! ROUTINE VALUE:
!
!	1
!
! SIDE EFFECTS:
!
!	Opens the work file.  Prints an error message and does not
!	return if the open fails.
!	Calls EDT$$ALO_HEAP  to get virtual memory to hold the cache.
!
!--

    BEGIN

    LOCAL
	XABPRO : $XABPRO_DECL,
	WORK_FAB : $FAB_DECL;

!+
! Set up the FAB, RAB and XAB for the open.
!-
    $FAB_INIT (FAB = WORK_FAB, FAC = <GET, PUT, BIO>, FOP = <TMD>, ALQ = WINDOW_SIZE, RAT = CR, RFM = UDF,
	RTV = 20, SHR = NIL, XAB = XABPRO);
    WORK_FAB [FAB$L_FNA] = UPLIT (BYTE ('EDTWORK'));
    WORK_FAB [FAB$B_FNS] = %CHARCOUNT ('EDTWORK');
    WORK_FAB [FAB$L_DNA] = UPLIT (BYTE ('SYS$SCRATCH:.TMP'));
    WORK_FAB [FAB$B_DNS] = %CHARCOUNT ('SYS$SCRATCH:.TMP');
    $RAB_INIT (RAB = IO_WF_RAB, ROP = <BIO>, FAB = WORK_FAB, CTX = 0);
    $XABPRO_INIT (XAB = XABPRO, PRO = <D, RWD>);

    IF (IO_STS = $RMS_CREATE (FAB = WORK_FAB))
    THEN
	BEGIN
	WF_IFI = .WORK_FAB [FAB$W_IFI];

	IF ( NOT (IO_STS = $RMS_CONNECT (RAB = IO_WF_RAB))) THEN IO_STV = .IO_WF_RAB [RAB$L_STV];

	END
    ELSE
	IO_STV = .WORK_FAB [FAB$L_STV];

!+
! Make sure the file was successfully opened.
!-

    IF ( NOT .IO_STS) THEN SIGNAL_STOP (EDT$_IOERRWRK, 0, .IO_STS, .IO_STV);

    WF_OPEN = 1;
    IO_WF_RAB [RAB$L_STS] = 1;
    RETURN (1);
    END;					! of routine WF_OPN

%SBTTL 'EDT$$WF_OPN  - Open work file'

GLOBAL ROUTINE EDT$$WF_OPN 			! Open work file
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize work system
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The work file cache.
!
! ROUTINE VALUE:
!
!	Always 1; signals all errors.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    DECR I FROM NUM_WINDOW - 1 TO 0 DO
	BEGIN
	CACHE_WINDOW [.I] = -1;
	CACHE_REF [.I] = 0;
	CACHE_DIRTY [.I] = 0;
	CACHE_ADDR [.I] = 0;
	END;

    WF_OPEN = 0;
    WF_CACHE_FULL = 0;
    CACHE_TIMER = 0;
    RETURN (1);
    END;					! of routine EDT$$WF_OPN


%SBTTL 'EDT$$WF_CLS  - close the work file'

GLOBAL ROUTINE EDT$$WF_CLS 			! Close the work file
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Close the work file.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CACHE_ADDR
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Always 1; signals all errors.
!
! SIDE EFFECTS:
!
!	Errors are signalled.
!	Releases all the heap storage in the work file cache.
!
!--

    BEGIN

    LOCAL
	WORK_FAB : $FAB_DECL;

    IF .WF_OPEN
    THEN
	BEGIN
!+
! Disconnect the RAB
!-
	IO_STS = $RMS_DISCONNECT (RAB = IO_WF_RAB);
	IO_STV = IO_WF_RAB [RAB$L_STV];

	IF .IO_STS
	THEN
	    BEGIN
!+
! Move the IFI into the FAB
!-
	    $FAB_INIT (FAB = WORK_FAB);
	    WORK_FAB [FAB$W_IFI] = .WF_IFI;
!+
! And close the file.
!-
	    IO_STS = $RMS_CLOSE (FAB = WORK_FAB);
	    IO_STV = .WORK_FAB [FAB$L_STV];
	    END;

	IF ( NOT .IO_STS) THEN SIGNAL_STOP (EDT$_WORFILCLO, 0, .IO_STS, .IO_STV);

	END;

!+
! Now release the cache.
!-

    DECR I FROM NUM_WINDOW - 1 TO 0 DO

	IF (.CACHE_ADDR [.I] NEQA 0) THEN EDT$$DEA_HEAP (%REF (WINDOW_SIZE*512), CACHE_ADDR [.I]);

    RETURN (1);
    END;					! of routine EDT$$WF_CLS


%SBTTL 'FIND_WINDOW - Find the window containing a bucket'
ROUTINE FIND_WINDOW (				! Locate a specified bucket
    BUKT_NUM, 					! The bucket to locate
    ADDR					! Where to put window number (address of bucket)
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Locate the window which contains a specified bucket in the cache.  If it
!	is not in the cache return -1; otherwise the window number is returned.
!
! FORMAL PARAMETERS:
!
!  BUKT_NUM		The bucket we are trying to locate.
!
!  ADDR			Address of a longword to receive the address of the requested
!			bucket.
!
! IMPLICIT INPUTS:
!
!	CACHE_WINDOW
!	CACHE_ADDR
!
! IMPLICIT OUTPUTS:
!
!	CACHE_TIMER		Incremented if window found
!	CACHE_REF		Set to CACHE_TIMER for the window found
!
! ROUTINE VALUE:
!
!	The number of the window containing this bucket, or -1 if none found.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	P_CACHE_WINDOW : REF VECTOR [NUM_WINDOW],	! to improve the code in the loop
	WINDOW_NUM;

!+
! Compute the window which contains this bucket.
!-
    WINDOW_NUM = (.BUKT_NUM - 1)/WINDOW_SIZE;
!+
! Search the cache to find the window, if found, then compute the address
! of the requested bucket and return it.
!-
    P_CACHE_WINDOW = CACHE_WINDOW [0];

    DECR I FROM NUM_WINDOW - 1 TO 0 DO

	IF (.P_CACHE_WINDOW [.I] EQL .WINDOW_NUM)
	THEN
	    BEGIN
	    .ADDR = .CACHE_ADDR [.I] + ((.BUKT_NUM - 1) MOD WINDOW_SIZE)*512;
	    CACHE_TIMER = .CACHE_TIMER + 1;
	    CACHE_REF [.I] = .CACHE_TIMER;
	    RETURN (.I);
	    END;

!+
! Not in the cache, return failure.
!-
    RETURN (-1);
    END;					! of routine FIND_WINDOW

%SBTTL 'EDT$$WF_WR  - Mark bucket as modified'

GLOBAL ROUTINE EDT$$WF_WR (			! Mark bucket as modified
    NUM, 					! Bucket number
    REC_DESC					! descriptor for bucket address
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when the current bucket has been modified by
!	the work file and it is going to a new bucket.  This is a logical write
!	function, but since we are using a cache, it merely marks the bucket
!	as dirty.
!
! FORMAL PARAMETERS:
!
!  NUM		the bucket number being "written".
!
!  REC_DESC     address of a descriptor for the bucket
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	CACHE_DIRTY
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Calls FIND_WINDOW.  The bucket had better be in the cache.
!
!--

    BEGIN

    MAP
	REC_DESC : REF BLOCK [, BYTE];

    LOCAL
	ADDR,
	FIND_WINDOW_VAL;

    FIND_WINDOW_VAL = FIND_WINDOW (.NUM, ADDR);
    ASSERT (.FIND_WINDOW_VAL GEQ 0);
    CACHE_DIRTY [.FIND_WINDOW_VAL] = 1;
    END;					! of routine EDT$$WF_WR


%SBTTL 'WRITE_WINDOW - write out a window'
ROUTINE WRITE_WINDOW (				! Write out a window
    WINDOW_NUM					! The window number to write
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION
!
!	Write out an entire window.
!
! FORMAL PARAMETERS:
!
!  WINDOW_NUM		The slot from which the window is written.
!
! IMPLICIT INPUTS:
!
!	CACHE_ADDR
!	CACHE_WINDOW
!
! IMPLICIT OUTPUTS:
!
!	CACHE_DIRTY
!	IO_WF_RAB
!	IO_STS
!	IO_STV
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Writes on the work file.
!	I/O errors print an error and do not return to the caller.
!
!--

    BEGIN
!+
! Mark the window as clean.
!-
    CACHE_DIRTY [.WINDOW_NUM] = 0;

    IF ( NOT .WF_OPEN) THEN WF_OPN ();

!+
! Setup the RAB with the address and length and record number.
!-
    IO_WF_RAB [RAB$L_RBF] = .CACHE_ADDR [.WINDOW_NUM];
    IO_WF_RAB [RAB$W_RSZ] = WINDOW_SIZE*512;
    IO_WF_RAB [RAB$L_BKT] = .CACHE_WINDOW [.WINDOW_NUM]*WINDOW_SIZE + 1;
!+
! Attempt to write it out.
!-

    WHILE 1 DO

	IF ( NOT (IO_STS = $RMS_WRITE (RAB = IO_WF_RAB)))
	THEN

	    IF (.IO_STS EQL RMS$_EOF)
	    THEN
		EXITLOOP
	    ELSE
		BEGIN
		IO_STV = .IO_WF_RAB [RAB$L_STV];
		SIGNAL_STOP (EDT$_IOERRWRK, 0, .IO_STS, .IO_STV);
		EXITLOOP;
		END

	ELSE
	    EXITLOOP;

    END;					! of routine WRITE_WINDOW

%SBTTL 'REPLACE_WINDOW - read a new window into the cache'
ROUTINE REPLACE_WINDOW (			! Read a new bucket into the cache
    BUKT_NUM					! The number of the bucket to read in
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when a new work-file window must be read into the
!	cache.  We find the least recently used window for replacement, and write
!	it out.
!
! FORMAL PARAMETERS:
!
!  BUKT_NUM		the number of the bucket which we need to put in the cache.
!
! IMPLICIT INPUTS:
!
!	CACHE_REF
!	CACHE_DIRTY
!
! IMPLICIT OUTPUTS:
!
!	CACHE_TIMER
!	CACHE_REF
!	CACHE_WINDOW
!
! ROUTINE VALUE:
!
!	The window number the bucket was allocated to.
!
! SIDE EFFECTS:
!
!	May call WRITE_WINDOW
!
!--

    BEGIN

    LOCAL
	WINDOW_NUM,
	OLD_TIME,
	OLD_NUM;

!+
! Determine which window the bucket is in.
!-
    WINDOW_NUM = (.BUKT_NUM - 1)/WINDOW_SIZE;

    IF (.WINDOW_NUM GEQ NUM_WINDOW) THEN WF_CACHE_FULL = 1;

    IF .WF_CACHE_FULL
    THEN
	BEGIN
!+
! Find the least recently used window in the cache.
!-
	OLD_TIME = 999999999;

	DECR I FROM NUM_WINDOW - 1 TO 0 DO

	    IF (.CACHE_REF [.I] LSSU .OLD_TIME)
	    THEN
		BEGIN
		OLD_TIME = .CACHE_REF [.I];
		OLD_NUM = .I;
		END;

	ASSERT (.OLD_TIME LSSU 999999999);
!+
! Write the sucker out if it is dirty.
!-

	IF (.CACHE_DIRTY [.OLD_NUM] NEQ 0)
	THEN
	    BEGIN
	    WRITE_WINDOW (.OLD_NUM);
	    END;

	END
    ELSE
	OLD_NUM = NUM_WINDOW - 1 - .WINDOW_NUM;

!+
! Now, place the new bucket in the cache.
!-
    CACHE_TIMER = .CACHE_TIMER + 1;
    CACHE_REF [.OLD_NUM] = .CACHE_TIMER;
    CACHE_WINDOW [.OLD_NUM] = .WINDOW_NUM;
    RETURN (.OLD_NUM);
    END;					! of routine REPLACE_WINDOW

%SBTTL 'GET_WF - find a bucket in the cache, or read it in'
ROUTINE GET_WF (				! Find a bucket in the cache, or read it in
    BUKT_NUM, 					! The number of the bucket to locate
    BUF_ADDR, 					! Return the bucket's address here
    READ					! 1 = read from disk if not in cache
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine finds a bucket in the cache, or reads it in if necessary.
!
! FORMAL PARAMETERS:
!
!  BUKT_NUM		The number of the bucket we are trying to locate.
!
!  BUF_ADDR		Address of a longword in which the bucket's address is returned.
!
!  READ			Flag indicating that we should read the file from disk if it
!			is not in the cache.
!
! IMPLICIT INPUTS:
!
!	CACHE_ADDR
!
! IMPLICIT OUTPUTS:
!
!	IO_WF_RAB, if READ = 1
!	IO_STS and IO_STV, if READ = 1
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Calls FIND_WINDOW and REPLACE_WINDOW.
!	Never returns on I/O errors.
!
!--

    BEGIN

    LOCAL
	ALLOC_STATUS,
	WINDOW_ADDR,
	WINDOW_NUM;

!+
! First, see if it is in the cache.
!-

    IF (FIND_WINDOW (.BUKT_NUM, .BUF_ADDR) GEQ 0) THEN RETURN;

!+
! It's not, find a block to replace and read a block.
!-
    WINDOW_NUM = REPLACE_WINDOW (.BUKT_NUM);
    WINDOW_ADDR = .CACHE_ADDR [.WINDOW_NUM];

    IF ((.WINDOW_ADDR EQLA 0) AND NOT .WF_CACHE_FULL)
    THEN
	BEGIN
	ALLOC_STATUS = EDT$$ALO_HEAP (%REF (WINDOW_SIZE*512), CACHE_ADDR [.WINDOW_NUM]);

	IF ( NOT .ALLOC_STATUS)
	THEN
	    BEGIN
	    WF_CACHE_FULL = 1;
	    WINDOW_NUM = REPLACE_WINDOW (.BUKT_NUM);
	    END;

	WINDOW_ADDR = .CACHE_ADDR [.WINDOW_NUM];
	ASSERT (.WINDOW_ADDR NEQA 0);
	.BUF_ADDR = .WINDOW_ADDR + ((.BUKT_NUM - 1) MOD WINDOW_SIZE)*512;
	END
    ELSE
	BEGIN
	ASSERT (.WINDOW_ADDR NEQA 0);
	.BUF_ADDR = .WINDOW_ADDR + ((.BUKT_NUM - 1) MOD WINDOW_SIZE)*512;
!+
! Check to see if we should read it in.
!-

	IF .READ
	THEN
	    BEGIN

	    IF ( NOT .WF_OPEN) THEN WF_OPN ();

	    IO_WF_RAB [RAB$L_UBF] = .WINDOW_ADDR;
	    IO_WF_RAB [RAB$W_USZ] = WINDOW_SIZE*512;
	    IO_WF_RAB [RAB$L_BKT] = (.BUKT_NUM - 1)/WINDOW_SIZE*WINDOW_SIZE + 1;

	    IF ( NOT (IO_STS = $RMS_READ (RAB = IO_WF_RAB)))
	    THEN

		IF (.IO_STS NEQ RMS$_EOF)
		THEN
		    BEGIN
		    IO_STV = .IO_WF_RAB [RAB$L_STV];
		    SIGNAL_STOP (EDT$_IOERRWRK, 0, .IO_STS, .IO_STV);
		    END;

	    END;

	END;

    END;					! of routine GET_WF

%SBTTL 'EDT$$WF_RD  - get new current work file bucket'

GLOBAL ROUTINE EDT$$WF_RD (			! Get a new current work file bucket
    BUKT_NUM, 					! The number of the bucket to read
    REC_DESC					! descriptor for record address
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called get a new current work file bucket.  The
!	cache is searched, and if it is not there, a window is selected
!	for replacement and the bucket is read in.
!
! FORMAL PARAMETERS:
!
!  BUKT_NUM		The number of the bucket to read.
!
!  REC_DESC		Descriptor containing address of a longword in which the address of the bucket
!			is returned.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Calls GET_WF with READ = 1.
!
!--

    BEGIN

    MAP
	REC_DESC : REF BLOCK [, BYTE];

    LOCAL
	BUF_ADDR,
	LEN;

    GET_WF (.BUKT_NUM, BUF_ADDR, 1);		! find address in cache
    REC_DESC [DSC$A_POINTER] = .BUF_ADDR;
    END;					! of routine EDT$$WF_RD


%SBTTL 'EDT$$PAR_FNAME  - parse a file name'

GLOBAL ROUTINE EDT$$PAR_FNAME (			! Parse a file name
    RAB, 					! Address of the RAB
    FILE_DESC, 					! descriptor of filename
    RLF, 					! 1 = use input file as a related file name
    DSK, 					! set if file can be renamed
    STS, 					! RMS status
    STV						! RMS stv word
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses a file name to determine if valid before
!	later attempting an open.
!
! FORMAL PARAMETERS:
!
!  RAB			The address of the RAB to connect.
!
!  FILE_DESC		The address of a descriptor containing the filename
!
!  RLF			1 = use the input file as a related file name (EXIT rather than WRITE)
!
!  DSK			1 flags renameable file (disk or DECtape), 0 otherwise
!
!  STS			The RMS status returned
!
!  STV			The RMS stv word returned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IO_STS
!	IO_STV
!
! ROUTINE VALUE:
!
!	If successful, 1; if failed, 0.
!
! SIDE EFFECTS:
!
!	Passes back a '1' in DSK if this file can be renamed
!
!--

    BEGIN

    MAP
	FILE_DESC : REF BLOCK [, BYTE];

    LOCAL
	FNA,
	RSA,
	RSL,
	FNS,
	WORK_FAB : $FAB_DECL,
	RELAT_NAM : $NAM_DECL,
	NAM_BLOCK : $NAM_DECL;

    FNA = .FILE_DESC [DSC$A_POINTER];		! get file name
    FNS = .FILE_DESC [DSC$W_LENGTH];		! and its length
!+
! Initialize the NAM block.
!-
    $NAM_INIT (NAM = NAM_BLOCK, ESA = MYBUF, ESS = MIN (255, NAM$C_MAXRSS));
!+
! Set up the related name from the input file, if requested.
!-

    IF .RLF
    THEN
	BEGIN
	$NAM_INIT (NAM = RELAT_NAM, ESA = MYBUF2, ESS = NAM$C_MAXRSS, RSA = INPUT_NAME, RSS = NAM$C_MAXRSS);
	RELAT_NAM [NAM$B_RSL] = .INPUT_NAME_LEN;
	$$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_RLNAM, .RELAT_NAM [NAM$B_RSL], .RELAT_NAM [NAM$L_RSA]);
	NAM_BLOCK [NAM$L_RLF] = RELAT_NAM;
	END;

!+
! Setup the FAB
!-
    $FAB_INIT (FAB = WORK_FAB, FOP = <OFP>, NAM = NAM_BLOCK);
    WORK_FAB [FAB$L_FNA] = .FNA;
    WORK_FAB [FAB$B_FNS] = .FNS;
!+
! Attempt the parse, set up the status and return
!-
    IO_STS = $RMS_PARSE (FAB = WORK_FAB);
    IO_STV = .WORK_FAB [FAB$L_STV];

    IF .IO_STS
    THEN
	BEGIN
!+
! Is this a renameable device?
!-

	IF (((.WORK_FAB [FAB$L_DEV] AND DEV$M_FOD) NEQ 0)	! File oriented device
	    AND ((.WORK_FAB [FAB$L_DEV] AND DEV$M_RND) NEQ 0)	! Random access device
	    AND ((.WORK_FAB [FAB$L_DEV] AND DEV$M_IDV) NEQ 0)	! Open for input
	    AND ((.WORK_FAB [FAB$L_DEV] AND DEV$M_SQD) EQL 0)	! Not a magtape
	    AND ((.NAM_BLOCK [NAM$L_FNB] AND NAM$M_PPF) EQL 0))	! Not a process permanent file
	THEN
	    BEGIN
!+
! If the file type is .TMP we shouldn't do the rename, since that will
! cause the version number to be incremented by two, and won't help
! the problem of purging a partial file after a crash.
!-

	    IF (.NAM_BLOCK [NAM$B_TYPE] EQL 4)
	    THEN
		BEGIN

		IF CH$EQL (4, .NAM_BLOCK [NAM$L_TYPE], 4, UPLIT (BYTE ('.TMP')), 0)
		THEN
		    .DSK = 0
		ELSE
		    .DSK = 1;

		END
	    ELSE
		.DSK = 1;

	    END
	ELSE
	    .DSK = 0;

	IF (.NAM_BLOCK [NAM$B_ESL] NEQ 0)
	THEN
	    BEGIN
	    RSL = .NAM_BLOCK [NAM$B_ESL];
	    RSA = .NAM_BLOCK [NAM$L_ESA];
	    STRING_DESC (.FILE_DESC, RSL, .RSA);	! get resultant filename
	    END;

	END;

    .STS = .IO_STS;
    .STV = .IO_STV;
    RETURN (.IO_STS);
    END;					! of routine EDT$$PAR_FNAME


%SBTTL 'EDT$$OPN_IFIDEF  - Open a file for input by name and default name'

GLOBAL ROUTINE EDT$$OPN_IFIDEF (		! Open a file for input by name and default name
    RAB, 					! Address of the RAB
    FILE_DESC, 					! descriptor of filename
    DNA, 					! Address of the default name string
    DNS, 					! Length of the default name string
    RLF, 					! 1 = use input file as related file
    STS, 					! RMS status
    STV, 					! RMS stv word
    VFC, 					! 1 = this file has sequence numbers
    NONSTD					! 1 = this is not a "standard" text file
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens a file for input using a name string and default
!	name string.
!
! FORMAL PARAMETERS:
!
!  RAB			The address of the RAB to connect.
!
!  FILE_DESC		The address of a descriptor containing the filename
!
!  DNA			The address of the default name string.
!
!  DNS			The length of the default name string.
!
!  RLF			1 = use the input file as a related file
!
!  STS			The RMS status returned
!
!  STV			The RMS stv word returned
!
!  VFC			returned as 1 = this file has sequence numbers, 0 = it doesn't
!
!  NONSTD		returned as 1 = this file is not a standard text file, 0 = it is
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IO_STS
!	IO_STV
!
! ROUTINE VALUE:
!
!	If successful, the IFI; if the open failed, 0.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FILE_DESC : REF BLOCK [, BYTE],
	RAB : REF $RAB_DECL;

    LOCAL
	FNA,
	RSA,
	RSL,
	FNS,
	XABPRO : $XABPRO_DECL,
	WORK_FAB : $FAB_DECL,
	RELAT_NAM : $NAM_DECL,
	NAM_BLOCK : $NAM_DECL;

    FNA = .FILE_DESC [DSC$A_POINTER];		! get file name
    FNS = .FILE_DESC [DSC$W_LENGTH];		! and its length
!+
! Initialize the NAM and XAB blocks.
!-
    $NAM_INIT (NAM = NAM_BLOCK, ESA = MYBUF2, ESS = MIN (255, NAM$C_MAXRSS), RSA = MYBUF, 	!
	RSS = MIN (255, NAM$C_MAXRSS));
    $XABPRO_INIT (XAB = XABPRO);
!+
! Setup the FAB and RAB
!-
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_FNAM, .FNS, .FNA);
    $FAB_INIT (FAB = WORK_FAB, FAC = <GET>, RAT = CR, RFM = VAR, FOP = <SQO, OFP>, MRS = 255, SHR = GET,
	NAM = NAM_BLOCK, XAB = XABPRO);
    WORK_FAB [FAB$L_FNA] = .FNA;
    WORK_FAB [FAB$B_FNS] = .FNS;
    $RAB_INIT (RAB = .RAB, RAC = SEQ, ROP = <LOC, RAH>, UBF = MYBUF, USZ = 255, FAB = WORK_FAB, RHB = VFCHD,
	CTX = 0);
!+
! Move in the default name string.
!-
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_DNAM, .DNS, .DNA);
    WORK_FAB [FAB$L_DNA] = .DNA;
    WORK_FAB [FAB$B_DNS] = .DNS;
!+
! Set up the related name from the input file, if requested.
!-

    IF .RLF
    THEN
	BEGIN
	$NAM_INIT (NAM = RELAT_NAM, ESA = MYBUF2, ESS = NAM$C_MAXRSS, RSA = INPUT_NAME, RSS = NAM$C_MAXRSS);
	RELAT_NAM [NAM$B_RSL] = .INPUT_NAME_LEN;
	$$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_RLNAM, .RELAT_NAM [NAM$B_RSL], .RELAT_NAM [NAM$L_RSA]);
	NAM_BLOCK [NAM$L_RLF] = RELAT_NAM;
	END;

!+
! Attempt the open and then the connect, setting up the status and STV
! if either of them fails.
!-
    IO_STS = $RMS_OPEN (FAB = WORK_FAB);
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_OPN_STS, %UPVAL, WORK_FAB [FAB$L_STS]);
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_OPN_STV, %UPVAL, WORK_FAB [FAB$L_STV]);

    IF .IO_STS
    THEN
	BEGIN
	RSL = .NAM_BLOCK [NAM$B_RSL];
	STRING_DESC (.FILE_DESC, RSL, MYBUF);
	END
    ELSE
	BEGIN

	IF (.NAM_BLOCK [NAM$B_ESL] NEQ 0)
	THEN
	    BEGIN
	    RSL = .NAM_BLOCK [NAM$B_ESL];
	    RSA = .NAM_BLOCK [NAM$L_ESA];
	    STRING_DESC (.FILE_DESC, RSL, .RSA);	! get resultant filename
	    END;

	END;

!+
! If this is the first time, remember the input file name so we can
! use it as a related name.
!-

    IF (( NOT .ATTRIBUTES_SET) AND ( NOT .ATTRIBUTES_DEFAULTED))
    THEN
	BEGIN
	INPUT_NAME_LEN = .FILE_DESC [DSC$W_LENGTH];
	CH$MOVE (.INPUT_NAME_LEN, .FILE_DESC [DSC$A_POINTER], INPUT_NAME);
	END;

    IF .IO_STS
    THEN
	BEGIN
	$$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_OPN_IFI, 2, WORK_FAB [FAB$W_IFI]);
	IO_STS = $RMS_CONNECT (RAB = .RAB);
	$$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_CON_STS, %UPVAL, RAB [FAB$L_STS]);
	$$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_CON_STV, %UPVAL, RAB [FAB$L_STV]);

	IF .IO_STS
	THEN
!+
! Succeeded, return the IFI
!-
	    BEGIN
	    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_RNAM, .NAM_BLOCK [NAM$B_RSL], .NAM_BLOCK [NAM$L_RSA]);
	    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_CON_ISI, 2, RAB [RAB$W_ISI]);
!+
! Get the record format, so we know if it has a VFC field or not.
! If the PRN bit is set, the file is not considered a VFC file, since
! the information in the record prefix is not a line number.
!-

	    IF ((.WORK_FAB [FAB$B_RFM] EQL FAB$C_VFC) AND ((.WORK_FAB [FAB$B_RAT] AND FAB$M_PRN) EQL 0))
	    THEN
		.VFC = 1			! This file has sequence numbers
	    ELSE
		.VFC = 0;			! This file does not have sequence numbers

!+
! Check the file's attributes to see if it is a "standard" text file.
!-
	    .NONSTD = 0;

	    IF ((.WORK_FAB [FAB$B_RFM] NEQ FAB$C_VAR) AND (.WORK_FAB [FAB$B_RFM] NEQ FAB$C_VFC))
	    THEN
		.NONSTD = 1;

	    IF (.WORK_FAB [FAB$B_RAT] NEQ FAB$M_CR) THEN .NONSTD = 1;

	    IF (.WORK_FAB [FAB$B_ORG] NEQ FAB$C_SEQ) THEN .NONSTD = 1;

!+
! If this is the first input open, remember the file's attributes.
!-

	    IF (( NOT .ATTRIBUTES_SET) AND ( NOT .ATTRIBUTES_DEFAULTED))
	    THEN
		BEGIN
		ATTRIBUTES_SET = 1;
		INPUT_PROT = .XABPRO [XAB$W_PRO];
!+
! If PRN format, make the output CR format.
!-

		IF ((.WORK_FAB [FAB$B_RAT] AND FAB$M_PRN) NEQ 0)
		THEN
		    BEGIN
		    INPUT_RAT = (.WORK_FAB [FAB$B_RAT] AND NOT FAB$M_PRN) OR FAB$M_CR;
		    INPUT_RFM = FAB$C_VAR;
		    END
		ELSE
		    BEGIN
		    INPUT_RAT = .WORK_FAB [FAB$B_RAT];
		    INPUT_RFM = .WORK_FAB [FAB$B_RFM];
		    END;

		INPUT_MRS = MIN (.WORK_FAB [FAB$W_MRS], 255);

		IF (.INPUT_MRS EQL 0) THEN INPUT_MRS = 255;

		END;

	    .STV = .IO_STV;
	    .STS = .IO_STS;
	    RETURN (.WORK_FAB [FAB$W_IFI]);
	    END
	ELSE
	    IO_STV = .RAB [RAB$L_STV]

	END
    ELSE
	IO_STV = .WORK_FAB [FAB$L_STV];

!+
! Failed, return 0 and set input attributes = default atttributes
!-
    ATTRIBUTES_DEFAULTED = 1;
    .STV = .IO_STV;
    .STS = .IO_STS;
    RETURN (0);
    END;					! of EDT$$OPN_IFIDEF


%SBTTL 'EDT$$OPN_INOUT  - Open a file for input and output by name and default name'

GLOBAL ROUTINE EDT$$OPN_INOUT (			! Open a file for input by name and default name
    RAB, 					! Address of the RAB
    FILE_DESC, 					! descriptor of filename
    DNA, 					! Address of the default name string
    DNS, 					! Length of the default name string
    STS, 					! RMS status
    STV						! RMS stv word
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens a file for input and output using a name string and default
!	name string.  It is used only for the journal file.
!
! FORMAL PARAMETERS:
!
!  RAB			The address of the RAB to connect.
!
!  FILE_DESC		The address of a descriptor containing the filename
!
!  DNA			The address of the default name string.
!
!  DNS			The length of the default name string.
!
!  STS			The RMS status returned
!
!  STV			The RMS stv word returned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IO_STS
!	IO_STV
!
! ROUTINE VALUE:
!
!	If successful, the IFI; if the open failed, 0.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FILE_DESC : REF BLOCK [, BYTE],
	RAB : REF $RAB_DECL;

    LOCAL
	FNA,
	RSA,
	RSL,
	FNS,
	XABPRO : $XABPRO_DECL,
	WORK_FAB : $FAB_DECL,
	RELAT_NAM : $NAM_DECL;

    FNA = .FILE_DESC [DSC$A_POINTER];		! get file name
    FNS = .FILE_DESC [DSC$W_LENGTH];		! and its length
!+
! Initialize the NAM and XAB blocks.
! Since only the journal file is opened for I/O, we save the NAM block
! in case we later delete the journal file.
!-
    $NAM_INIT (NAM = JOURNAL_NAM, ESA = MYBUF2, ESS = NAM$C_MAXRSS, RSA = MYBUF, RSS = NAM$C_MAXRSS);
    $NAM_INIT (NAM = RELAT_NAM, RSA = INPUT_NAME, RSS = NAM$C_MAXRSS);
    RELAT_NAM [NAM$B_RSL] = .INPUT_NAME_LEN;
    $XABPRO_INIT (XAB = XABPRO, PRO = <RD, RWD>);
!+
! Setup the FAB and RAB
!-
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_FNAM, .FNS, .FNA);
    $FAB_INIT (FAB = WORK_FAB, ALQ = 1, DEQ = 5, FAC = <GET, PUT>, FOP = <SQO, DFW, OFP>, SHR = NIL,
	RAT = CR, RFM = VAR, MRS = 255, NAM = JOURNAL_NAM, XAB = XABPRO);
    WORK_FAB [FAB$L_FNA] = .FNA;
    WORK_FAB [FAB$B_FNS] = .FNS;
    $RAB_INIT (RAB = .RAB, RAC = SEQ, ROP = <LOC, RAH, WBH>, UBF = MYBUF, USZ = 255, FAB = WORK_FAB,
	RHB = VFCHD, CTX = 0);
!+
! Move in the default name string.
!-
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_DNAM, .DNS, .DNA);
    WORK_FAB [FAB$L_DNA] = .DNA;
    WORK_FAB [FAB$B_DNS] = .DNS;
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_RLNAM, .RELAT_NAM [NAM$B_RSL], .RELAT_NAM [NAM$L_RSA]);
    JOURNAL_NAM [NAM$L_RLF] = RELAT_NAM;
!+
! Attempt the open and then the connect, setting up the status and STV
! if either of them fails.
!-
    IO_STS = $RMS_OPEN (FAB = WORK_FAB);
    JOURNAL_NAM [NAM$L_RLF] = 0;
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_OPN_STS, %UPVAL, WORK_FAB [FAB$L_STS]);
    $$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_OPN_STV, %UPVAL, WORK_FAB [FAB$L_STV]);

    IF .IO_STS
    THEN
	BEGIN
	RSL = .JOURNAL_NAM [NAM$B_RSL];
	STRING_DESC (.FILE_DESC, RSL, MYBUF);
	END
    ELSE
	BEGIN

	IF (.JOURNAL_NAM [NAM$B_ESL] NEQ 0)
	THEN
	    BEGIN
	    RSL = .JOURNAL_NAM [NAM$B_ESL];
	    RSA = .JOURNAL_NAM [NAM$L_ESA];
	    STRING_DESC (.FILE_DESC, RSL, .RSA);	! get resultant filename
	    END;

	END;

    IF .IO_STS
    THEN
	BEGIN
	$$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_OPN_IFI, 2, WORK_FAB [FAB$W_IFI]);
	IO_STS = $RMS_CONNECT (RAB = .RAB);
	$$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_CON_STS, %UPVAL, RAB [FAB$L_STS]);
	$$TRACE (EDT$$TR_IFO, EDT$$TR_SIFO_CON_STV, %UPVAL, RAB [FAB$L_STV]);

	IF .IO_STS
	THEN
!+
! Succeeded, return the IFI
!-
	    BEGIN
	    .STV = .IO_STV;
	    .STS = .IO_STS;
	    RETURN (.WORK_FAB [FAB$W_IFI]);
	    END
	ELSE
	    IO_STV = .RAB [RAB$L_STV]

	END
    ELSE
	IO_STV = .WORK_FAB [FAB$L_STV];

!+
! Failed, return 0
!-
    .STV = .IO_STV;
    .STS = .IO_STS;
    RETURN (0);
    END;					! of routine EDT$$OPN_INOUT


%SBTTL 'EDT$$OPN_OFIDEF  - open a file for output by name and default name'

GLOBAL ROUTINE EDT$$OPN_OFIDEF (		! Open a file for output by name and default name
    RAB, 					! Address of the RAB
    FILE_DESC, 					! descriptor of filename
    DNA, 					! Address of the default name string
    DNS, 					! Length of the default name string
    SEQ, 					! 1 = VFC format
    RLF, 					! 1 = use input file as related name
    DFA, 					! 1 = use default file attributes, 2 = journal attributes
    FORCE_MAXV, 				! 1 = force maximum version number
    STS, 					! rms status word
    STV						! rms stv word
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens a file for output using a name string and default
!	name string.
!
! FORMAL PARAMETERS:
!
!  RAB			The address of the RAB to connect.
!
!  FILE_DESC		The address of a descriptor containing filename
!
!  DNA			The address of the default file name string.
!
!  DNS			The length of the default file name string.
!
!  SEQ			Flag indicating that the file should be created with VFC format.
!
!  RLF			Flag indicating that open should use primary input file as related file
!
!  DFA			Flag indicating that the open should use input, journal or default file attributes
!
!  FORCE_MAXV		Force maximum version number.
!
!  STS			RMS status returned
!
!  STV			RMS STV word returned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IO_STS
!	IO_STV
!
! ROUTINE VALUE:
!
!	If the file is opened successfully, the IFI; otherwise, 0.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FILE_DESC : REF BLOCK [, BYTE],
	RAB : REF $RAB_DECL;

    LOCAL
	RSA,
	RSL,
	FNA,
	FNS,
	XABPRO : $XABPRO_DECL,
	WORK_FAB : $FAB_DECL,
	NAM_BLOCK_PTR : REF $NAM_DECL,
	RELAT_NAM : $NAM_DECL;

    FNA = .FILE_DESC [DSC$A_POINTER];
    FNS = .FILE_DESC [DSC$W_LENGTH];
!+
! Setup the FAB, RAB and XAB for the open.	
!-
    $$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_FNAM, .FNS, .FNA);
    $FAB_INIT (  FAB = WORK_FAB
		,ALQ = 1
		,DEQ = 0
		,FAC = <PUT>
		,FOP = <SQO, DFW, OFP>
		,SHR = NIL);
!+
! Maximize version number if requested.
!-

    IF .FORCE_MAXV THEN WORK_FAB [FAB$L_FOP] = .WORK_FAB [FAB$L_FOP] OR FAB$M_MXV;

    CASE .DFA FROM 0 TO 2 OF
	SET

	[0] : 					! EXIT
	    BEGIN

	    IF .ATTRIBUTES_SET
	    THEN
		BEGIN
!+
! Use file attributes from the primary input file.
!-
		$XABPRO_INIT (XAB = XABPRO);
		XABPRO [XAB$W_PRO] = .INPUT_PROT;
		WORK_FAB [FAB$L_XAB] = XABPRO;
!+
! If the input file was VFC sequenced, then a /SEQ on EXIT means give me
! a VFC file with the same attributes as the input file.  The
! absence of /SEQ means give me the default attributes.
!-

		IF (.INPUT_RFM EQL FAB$C_VFC)
		THEN

		    IF (.SEQ NEQ 0)
		    THEN
			BEGIN
			WORK_FAB [FAB$B_RAT] = .INPUT_RAT;
			WORK_FAB [FAB$B_RFM] = FAB$C_VFC;
			WORK_FAB [FAB$W_MRS] = .INPUT_MRS;
			END
		    ELSE
			BEGIN
			WORK_FAB [FAB$B_RAT] = FAB$M_CR;
			WORK_FAB [FAB$B_RFM] = FAB$C_VAR;
			WORK_FAB [FAB$W_MRS] = 255;
			END

		ELSE
		    BEGIN
!+
! The input file was not sequenced, so set the record attributes depending
! on whether or not the /SEQ qualifier was specified
!-
		    WORK_FAB [FAB$B_RAT] = .INPUT_RAT;

		    IF (.SEQ EQL 0)
		    THEN
			WORK_FAB [FAB$B_RFM] = .INPUT_RFM
		    ELSE
			WORK_FAB [FAB$B_RFM] = FAB$C_VFC;

		    WORK_FAB [FAB$W_MRS] = .INPUT_MRS;
		    END;

		END
	    ELSE
		BEGIN
!+
! Use EDT's default file attributes unless  /SEQ is given
!-
		WORK_FAB [FAB$B_RAT] = FAB$M_CR;

		IF (.SEQ EQL 0) THEN WORK_FAB [FAB$B_RFM] = FAB$C_VAR ELSE WORK_FAB [FAB$B_RFM] = FAB$C_VFC;

		WORK_FAB [FAB$W_MRS] = 255;
		END;

!+
! Initialize the name blocks.
!-
	    $NAM_INIT (NAM = NAM_BLOCK, ESA = MYBUF2, ESS = MIN (255, NAM$C_MAXRSS), RSA = MYBUF,
		RSS = MIN (255, NAM$C_MAXRSS));
	    NAM_BLOCK_PTR = NAM_BLOCK;
	    WORK_FAB [FAB$L_NAM] = .NAM_BLOCK_PTR;
	    END;

	[1] : 					! WRITE
	    BEGIN
!+
! Use EDT's default file attributes unless WRITE /SEQ is given
!-
	    WORK_FAB [FAB$B_RAT] = FAB$M_CR;

	    IF (.SEQ EQL 0) THEN WORK_FAB [FAB$B_RFM] = FAB$C_VAR ELSE WORK_FAB [FAB$B_RFM] = FAB$C_VFC;

	    WORK_FAB [FAB$W_MRS] = 255;
!+
! Initialize the name blocks.
!-
	    $NAM_INIT (NAM = NAM_BLOCK, ESA = MYBUF2, ESS = MIN (255, NAM$C_MAXRSS), RSA = MYBUF,
		RSS = MIN (255, NAM$C_MAXRSS));
	    NAM_BLOCK_PTR = NAM_BLOCK;
	    WORK_FAB [FAB$L_NAM] = .NAM_BLOCK_PTR;
	    END;

	[2] : 					! JOURNAL
	    BEGIN
!+
! Use journal attributes
!-
	    $XABPRO_INIT (XAB = XABPRO, PRO = <RD, RWD>);
	    WORK_FAB [FAB$L_XAB] = XABPRO;
	    WORK_FAB [FAB$B_RAT] = FAB$M_CR;
	    WORK_FAB [FAB$B_RFM] = FAB$C_VAR;
	    WORK_FAB [FAB$W_MRS] = 255;
!+
! Initialize the special name block for the journal file.
!-
	    $NAM_INIT (NAM = JOURNAL_NAM, ESA = MYBUF2, ESS = MIN (255, NAM$C_MAXRSS), RSA = MYBUF,
		RSS = MIN (255, NAM$C_MAXRSS));
	    NAM_BLOCK_PTR = JOURNAL_NAM;
	    WORK_FAB [FAB$L_NAM] = .NAM_BLOCK_PTR;
	    END;
	TES;

!+
! Specify the file name.
!-
    WORK_FAB [FAB$L_FNA] = .FNA;
    WORK_FAB [FAB$B_FNS] = .FNS;
!+
! Initialize the RAB.
!-
    $RAB_INIT (RAB = .RAB, RAC = SEQ, ROP = <LOC, WBH>, UBF = MYBUF, USZ = 255, FAB = WORK_FAB, RHB = VFCHD,
	CTX = 0);
!+
! Move in the default name string.
!-
    $$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_DNAM, .DNS, .DNA);
    WORK_FAB [FAB$L_DNA] = .DNA;
    WORK_FAB [FAB$B_DNS] = .DNS;
!+
! Set up the related name from the input file, if requested.
!-

    IF .RLF
    THEN
	BEGIN
	$NAM_INIT (NAM = RELAT_NAM, ESA = MYBUF2, ESS = NAM$C_MAXRSS, RSA = INPUT_NAME, RSS = NAM$C_MAXRSS);
	RELAT_NAM [NAM$B_RSL] = .INPUT_NAME_LEN;
	$$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_RLNAM, .RELAT_NAM [NAM$B_RSL], .RELAT_NAM [NAM$L_RSA]);
	NAM_BLOCK_PTR [NAM$L_RLF] = RELAT_NAM;
	END;

!+
! Attempt the open and connect.  Return the IFI if they succeed, otherwise
! set up IO_STS and IO_STV and return 0.
!-
    IO_STS = $RMS_CREATE (FAB = WORK_FAB);
    $$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_CRE_STS, %UPVAL, WORK_FAB [FAB$L_STS]);
    $$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_CRE_STV, %UPVAL, WORK_FAB [FAB$L_STV]);

    IF .IO_STS
    THEN
	BEGIN
	RSL = .NAM_BLOCK_PTR [NAM$B_RSL];
	STRING_DESC (.FILE_DESC, RSL, MYBUF);
	END
    ELSE
	BEGIN

	IF (.NAM_BLOCK_PTR [NAM$B_ESL] NEQ 0)
	THEN
	    BEGIN
	    RSL = .NAM_BLOCK_PTR [NAM$B_ESL];
	    RSA = .NAM_BLOCK_PTR [NAM$L_ESA];
	    STRING_DESC (.FILE_DESC, RSL, .RSA);	! get resultant filename
	    END;

	END;

    IF .IO_STS
    THEN
	BEGIN
	$$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_CRE_IFI, 2, WORK_FAB [FAB$W_IFI]);
	IO_STS = $RMS_CONNECT (RAB = .RAB);
	$$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_CON_STS, %UPVAL, RAB [RAB$L_STS]);
	$$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_CON_STV, %UPVAL, RAB [RAB$L_STV]);

	IF .IO_STS
	THEN
	    BEGIN
	    $$TRACE (EDT$$TR_IFO, EDT$$TR_SOFO_RNAM, .NAM_BLOCK_PTR [NAM$B_RSL], .NAM_BLOCK_PTR [NAM$L_RSA]);
	    $$TRACE (EDT$$TR_OFO, EDT$$TR_SOFO_CON_ISI, 2, RAB [RAB$W_ISI]);
	    .STV = .IO_STV;
	    .STS = .IO_STS;
	    RETURN (.WORK_FAB [FAB$W_IFI]);
	    END
	ELSE
	    IO_STV = .RAB [RAB$L_STV]

	END
    ELSE
	IO_STV = .WORK_FAB [RAB$L_STV];

    .STV = .IO_STV;
    .STS = .IO_STS;
    RETURN (0);
    END;					! of routine EDT$OPN_OFIDEF


%SBTTL 'EDT$$CLS_FI  - close a file'

GLOBAL ROUTINE EDT$$CLS_FI (			! Close a file
    IFI, 					! Internal file identifier
    RAB, 					! Address of the RAB
    DEL, 					! 1 = delete an output file, 2 = delete the journal file
    NAME_DESC, 					! name of the file
    STS, 					! Resulting RMS status
    STV						! Resulting RMS STV
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Close a file and optionally delete it.
!
! FORMAL PARAMETERS:
!
!  IFI			The internal file identifier.
!
!  RAB			The RAB which was connected.
!
!  DEL			1 = delete the last file opened, 2 = delete the journal file
!
!  NAME_DESC		Name of the file
!
!  STS			Resulting RMS STS value
!
!  STV			Resulting RMS STV value
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN

    MAP
	RAB : $RAB_DECL,
	NAME_DESC : BLOCK [8, BYTE];

    LOCAL
	WORK_FAB : $FAB_DECL;

    $$TRACE (EDT$$TR_CLO, EDT$$TR_SCLO_IFI, 2, IFI);
!+
! Disconnect the RAB
!-
    .STS = $RMS_DISCONNECT (RAB = .RAB);
    .STV = .RAB [RAB$L_STV];

    IF ..STS
    THEN
	BEGIN
!+
! Move the IFI into the FAB
!-
	$FAB_INIT (FAB = WORK_FAB);
	WORK_FAB [FAB$W_IFI] = .IFI;
!+
! Mark the file for deletion if that is requested.
! Either the journal file or the latest output file can be deleted (if CTRL/C
! was typed), so use the appropriate name block.
!-

	IF (.DEL NEQ 0)
	THEN
	    BEGIN

	    IF (.DEL EQL 1) THEN WORK_FAB [FAB$L_NAM] = NAM_BLOCK ELSE WORK_FAB [FAB$L_NAM] = JOURNAL_NAM;

	    WORK_FAB [FAB$L_FOP] = (.WORK_FAB [FAB$L_FOP] OR FAB$M_DLT OR FAB$M_NAM);
	    END;

!+
! And close the file.
!-
	.STS = $RMS_CLOSE (FAB = WORK_FAB);
	.STV = .WORK_FAB [FAB$L_STV];
	END;

    RETURN (..STS);
    END;					! of routine EDT$$CLS_FI


%SBTTL 'EDT$$RD_IFI  - get a record from a file open for input'

GLOBAL ROUTINE EDT$$RD_IFI (			! Get a record from a file open for input
    RAB, 					! Address of the RAB
    FILE_DESC, 					! descriptor for record read
    RHB_DESC, 					! decriptor for header info
    STS, 					! rms status
    STV, 					! rms stv
    VFC						! 1 = file has sequence numbers
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Get a record from a file which is open for input.
!
! FORMAL PARAMETERS:
!
!  RAB			The address of the RAB to connect.
!
!  FILE_DESC		The address of a descriptor containing filename
!
!  RHB_DESC 		The address of header info descriptor
!
!  STS			RMS status returned
!
!  STV			RMS STV word returned
!
!  VFC			1 = file has sequence numbers, 0 = it doesn't
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	If error or EOF, 0; if success, 1.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	REC_ADDR,
	REC_LEN;

    MAP
	RHB_DESC : REF BLOCK [, BYTE],
	RAB : REF $RAB_DECL;

    $$TRACE (EDT$$TR_IFR, EDT$$TR_SIFR_ISI, 2, RAB [RAB$W_ISI]);
    VFCHD = 0;
!+
! Do the get.
!-
    .STS = $RMS_GET (RAB = .RAB);
    .STV = .RAB [RAB$L_STV];
    $$TRACE (EDT$$TR_IFR, EDT$$TR_SIFR_STS, %UPVAL, RAB [RAB$L_STS]);
    $$TRACE (EDT$$TR_IFR, EDT$$TR_SIFR_STV, %UPVAL, RAB [RAB$L_STV]);
!+
! Return the record address and length.
!-
    $$TRACE (EDT$$TR_IFR, EDT$$TR_SIFR_REC, .RAB [RAB$W_RSZ], .RAB [RAB$L_RBF]);
    REC_ADDR = .RAB [RAB$L_RBF];
    REC_LEN = .RAB [RAB$W_RSZ];
    STRING_DESC (.FILE_DESC, REC_LEN, .REC_ADDR);
!+
! If the file has sequence numbers, the sequence number of this record is in
! the first two bytes of the record prefix, in binary.
!-

    IF (.VFC EQL 1) THEN REC_LEN = 2 ELSE REC_LEN = 0;

    STRING_DESC (.RHB_DESC, REC_LEN, VFCHD);
!+
! Check for bad status.
!-

    IF ( NOT ..STS) THEN RETURN (0);

    RETURN (1);
    END;					! of routine EDT$$RD_IFI


%SBTTL 'EDT$$WR_OFI  - put a record to an output file'

GLOBAL ROUTINE EDT$$WR_OFI (			! Put a record to an output file
    RAB, 					! Address of the RAB
    FILE_DESC, 					!
    RHB_DESC, 					!
    STS, 					!
    STV						!
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Put a record to an output file.
!
! FORMAL PARAMETERS:
!
!  RAB			The address of the RAB to connect.
!
!  FILE_DESC		The address of a descriptor containing filename
!
!  RHB_DESC 		The address of header info descriptor
!
!  STS			RMS status returned
!
!  STV			RMS STV word returned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	1 if the operation succeeds, status if it fails.
!
! SIDE EFFECTS:
!
!	Signals on error.
!
!--

    BEGIN

    MAP
	RHB_DESC : REF BLOCK [8, BYTE],
	FILE_DESC : REF BLOCK [8, BYTE],
	RAB : REF $RAB_DECL;

    $$TRACE (EDT$$TR_OFW, EDT$$TR_SOFW_ISI, 2, RAB [RAB$W_ISI]);
!+
! Set up the record address and size.
!-
    RAB [RAB$L_RBF] = .FILE_DESC [DSC$A_POINTER];
    RAB [RAB$W_RSZ] = .FILE_DESC [DSC$W_LENGTH];
    $$TRACE (EDT$$TR_OFW, EDT$$TR_SOFW_REC, .RAB [RAB$W_RSZ], .RAB [RAB$L_RBF]);
!+
! Set up the two bytes of record header, in case this file has sequence numbers.
! If for some reason this file has record headers longer than two bytes, the
! remaining bytes will be zero.
!-
    CH$COPY (.RHB_DESC [DSC$W_LENGTH], .RHB_DESC [DSC$A_POINTER], 0, 255, VFCHD);
!+
! Do the operation, if it succeeds, then return good status.
!-

    WHILE 1 DO
	BEGIN
	.STS = $RMS_PUT (RAB = .RAB);
	.STV = .RAB [RAB$L_STV];
	$$TRACE (EDT$$TR_OFW, EDT$$TR_SOFW_STS, %UPVAL, RAB [RAB$L_STS]);
	$$TRACE (EDT$$TR_OFW, EDT$$TR_SOFW_STV, %UPVAL, RAB [RAB$L_STV]);

	IF (..STS) THEN RETURN (1);

!+
! Check for the execeeded quota status.  Use the CTX field of the rab
! to indicate whether or not this file has already exceeded.
!-

	IF ((..STS EQL RMS$_EXT) AND (..STV EQL SS$_EXDISKQUOTA))
	THEN
	    BEGIN

	    IF .RAB [RAB$L_CTX] THEN RETURN (0) ELSE RAB [RAB$L_CTX] = .RAB [RAB$L_CTX] + 1;

	    END
	ELSE
	    EXITLOOP;

	END;

!+
! Bad status other than exceeded disk quota, put out a message and return 0.
!-
    RETURN (0);
    END;					! of routine EDT$$WR_OFI


%SBTTL 'EDT$$REN_FI  - rename a temporary file to a permanent file'

GLOBAL ROUTINE EDT$$REN_FI (			! Rename a file
			     OLD_FILE_DESC	! descriptor of old filename
			    ,NEW_FILE_DESC	! descriptor of new filename
			    ,FORCE_MAXV		! Force maximum version number
			    ,STS		! rms status word
			    ,STV		! rms status value word
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine renames a temporary file to a permanent output file
!	name string.
!
! FORMAL PARAMETERS:
!
!  OLD_FILE_DESC	The address of a descriptor containing an old filename
!
!  NEW_FILE_DESC	The address of a descriptor containing a new filename
!
!  FORCE_MAXV		Force maximum version number
!
!  STS			RMS status returned
!
!  STV			RMS status value word returned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IO_STS		The last I/O error message from IOMOD
!	IO_STV
!
! ROUTINE VALUE:
!
!	If the file is renamed successfully, 1; otherwise, 0.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	OLD_FILE_DESC : REF BLOCK [, BYTE],
	NEW_FILE_DESC : REF BLOCK [, BYTE];

    LOCAL
	O_RSA,
	O_RSL,
	O_FNA,
	O_FNS,
	N_RSA,
	N_RSL,
	N_DNA,
	N_DNS,
	OLD_FAB : $FAB_DECL,
	NEW_FAB : $FAB_DECL,
%IF %DECLARED(%QUOTE XAB$B_PROT_OPT) %THEN
	XABPRO : $XABPRO_DECL,
%FI
	OLD_NAM_BLOCK : $NAM_DECL,
	OLD_NAM_BLOCK_PTR : REF $NAM_DECL,
	NEW_NAM_BLOCK : $NAM_DECL,
	NEW_NAM_BLOCK_PTR : REF $NAM_DECL;

    O_FNA = .OLD_FILE_DESC [DSC$A_POINTER];
    O_FNS = .OLD_FILE_DESC [DSC$W_LENGTH];
    N_DNA = .NEW_FILE_DESC [DSC$A_POINTER];
    N_DNS = .NEW_FILE_DESC [DSC$W_LENGTH];
!+
! Setup the FAB for the open.
!-
    $FAB_INIT (FAB = OLD_FAB);
%IF %DECLARED(%QUOTE XAB$B_PROT_OPT) %THEN
    $FAB_INIT (FAB = NEW_FAB, XAB= XABPRO);
    $XABPRO_INIT (XAB = XABPRO, PROT_OPT = <PROPAGATE>);
%ELSE
    $FAB_INIT (FAB = NEW_FAB);
%FI
!+
! Initialize the name blocks.
!-
    $NAM_INIT (  NAM = OLD_NAM_BLOCK
		,RSA = MYBUF
		,RSS = MIN (255, NAM$C_MAXRSS));
    OLD_NAM_BLOCK_PTR = OLD_NAM_BLOCK;
    OLD_FAB [FAB$L_NAM] = .OLD_NAM_BLOCK_PTR;

    $NAM_INIT (  NAM = NEW_NAM_BLOCK
		,RSA = MYBUF2
		,RSS = MIN (255, NAM$C_MAXRSS));
    NEW_NAM_BLOCK_PTR = NEW_NAM_BLOCK;
    NEW_FAB [FAB$L_NAM] = .NEW_NAM_BLOCK_PTR;
!+
! Specify the file name.
!-
    OLD_FAB [FAB$L_FNA] = .O_FNA;
    OLD_FAB [FAB$B_FNS] = .O_FNS;
!+
! In order to create the next highest version number when an explicit file
! version number is given in the file spec, we must pass ';' as the file name.
!-

    IF .FORCE_MAXV
    THEN
	BEGIN
	NEW_FAB [FAB$L_FNA] = UPLIT (BYTE (';'));
	NEW_FAB [FAB$B_FNS] = 1;		! Length of FNA string
	END;

    NEW_FAB [FAB$L_DNA] = .N_DNA;
    NEW_FAB [FAB$B_DNS] = .N_DNS;
!+
! Attempt the the rename.  Return FAB$L_STS
!-
    IO_STS = $RMS_RENAME (OLDFAB = OLD_FAB, NEWFAB = NEW_FAB);

    IF .IO_STS
    THEN
	BEGIN
	O_RSL = .OLD_NAM_BLOCK_PTR [NAM$B_RSL];
	STRING_DESC (.OLD_FILE_DESC, O_RSL, MYBUF);
	N_RSL = .NEW_NAM_BLOCK_PTR [NAM$B_RSL];
	STRING_DESC (.NEW_FILE_DESC, N_RSL, MYBUF2);
	END
    ELSE
	BEGIN

	IF (.OLD_NAM_BLOCK_PTR [NAM$B_ESL] NEQ 0)
	THEN
	    BEGIN
	    O_RSL = .OLD_NAM_BLOCK_PTR [NAM$B_ESL];
	    O_RSA = .OLD_NAM_BLOCK_PTR [NAM$L_ESA];
	    STRING_DESC (.OLD_FILE_DESC, O_RSL, .O_RSA)	! get resultant filename
	    END;

	IF (.NEW_NAM_BLOCK_PTR [NAM$B_ESL] NEQ 0)
	THEN
	    BEGIN
	    N_RSL = .NEW_NAM_BLOCK_PTR [NAM$B_ESL];
	    N_RSA = .NEW_NAM_BLOCK_PTR [NAM$L_ESA];
	    STRING_DESC (.NEW_FILE_DESC, N_RSL, .N_RSA)	! get resultant filename
	    END;

	END;

    .STS = .IO_STS;
    IO_STV = .OLD_FAB [FAB$L_STV];
    .STV = .IO_STV;
    RETURN (.IO_STS);
    END;					! of routine EDT$$REN_FI


%SBTTL 'EDT$$FLUSH_OBUF  - flush output buffers'

GLOBAL ROUTINE EDT$$FLUSH_OBUF (		! Flush output buffers
    RAB, 					! Address of the RAB
    STV						!
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine flushes the buffers for a file which is open for output.
!
! FORMAL PARAMETERS:
!
!  RAB			Address of the RAB, representing the file whose buffers
!			 are to be flushed.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The status code from the RMS $FLUSH call
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RAB : REF $RAB_DECL;

    LOCAL
	STATUS;

    $$TRACE (EDT$$TR_FLU, EDT$$TR_SFLU_ISI, 2, RAB [RAB$W_ISI]);
    STATUS = ($RMS_FLUSH (RAB = .RAB));
    .STV = .RAB [RAB$L_STV];
    RETURN (.STATUS)
    END;					! of routine EDT$$FLUSH_OBUF


%SBTTL 'CC_ENABLE - enable for control C traps'
ROUTINE CC_ENABLE 				! Enable for control C traps
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Enable for control C traps.  When a control C trap is intercepted, the routine
!	CC_AST will be called.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	TT_CHAN
!	CC_AST
!	T_DEVCLASS
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The status code from $QIOW, or 1.
!
! SIDE EFFECTS:
!
!	Allocates and deallocates an event flag.
!
!--

    BEGIN

    LOCAL
	GETEF_STATUS,
	FREEEF_STATUS,
	EF,
	QIO_STATUS;

!+
! This routine is not called if we are reading a trace file.
!-
    $$TRACE_READING (<ASSERT (0)>);
!+
! Do nothing if SYS$INPUT is not a terminal.
!-

    IF (.t_devclass NEQ DC$_TERM) THEN RETURN (1);

!+
! Get an event flag for the QIO.
!-
    GETEF_STATUS = LIB$GET_EF (EF);

    IF ( NOT .GETEF_STATUS) THEN SIGNAL_STOP (.GETEF_STATUS);

    QIO_STATUS = $QIOW (EFN = .EF, CHAN = .TT_CHAN, FUNC = IO$_SETMODE + IO$M_CTRLCAST, P1 = CC_AST);
    FREEEF_STATUS = LIB$FREE_EF (EF);

    IF ( NOT .FREEEF_STATUS) THEN SIGNAL_STOP (.FREEEF_STATUS);

    RETURN (.QIO_STATUS);
    END;					! of routine CC_ENABLE

%SBTTL 'CC_AST - take a control C trap'
ROUTINE CC_AST 					! Take a control C trap
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the AST routine for CTRL/C.  Simply set the EDT$$G_CC  flag and
!	re-enable the AST.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	EDT$$G_CC
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Calls CC_ENABLE to re-enable control C traps.
!
!--

    BEGIN
    EDT$$G_CC = 1;
    CC_ENABLE ();
    END;					! of routine CC_AST

%SBTTL 'EDT$$TERM_RCC - restore from control C'

GLOBAL ROUTINE EDT$$TERM_RCC 			! Restore from control C
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do any system-dependent restoration of the terminal that is needed
!	after a control C is processed.  None is needed on VAX/VMS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    RETURN;
    END;					! of routine EDT$$TERM_RCC


%SBTTL 'EDT$$TI_OPN  - open the terminal'

GLOBAL ROUTINE EDT$$TI_OPN 			! Open the terminal
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens the files SYS$INPUT and SYS$OUTPUT for terminal
!	I/O.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	TT_OPEN
!
! IMPLICIT OUTPUTS:
!
!	TERM_IN_RAB
!	IO_STS
!	IO_STV
!	TERM_OUT_RAB
!	TT_OPEN
!	EDT$$G_TI_TYP
!	EDT$$G_DEC_CRT
!	EDT$$G_EIGHT_BIT
!	EDT$$G_TI_SCROLL
!	EDT$$G_TI_EDIT
!	EDT$$G_ENB_AUTRPT
!	EDT$$G_TI_DUMB
!	T_DEVCLASS, etc
!
! ROUTINE VALUE:
!
!	1
!
! SIDE EFFECTS:
!
!	If SYS$INPUT or SYS$OUTPUT won't open, calls EDT$$IO_ERRMSG ,
!	then exits without returning to the caller.
!
!--

    BEGIN

    LOCAL
	EF_STATUS,
	EF,
	QIO_STATUS,
	ITEM_LIST : BLOCKVECTOR [7, 3] FIELD (ITEM_FIELDS),	! Storage for terminal char.
	TT_INFO : BLOCK [2] FIELD (SETM_FIELDS),	! For setting terminal char
	NAME_BUF : VECTOR [64, BYTE],
	NAME_DESC : VECTOR [2],
	RES_DESC : VECTOR [2],
	WORK_FAB : $FAB_DECL;

!+
! If the open has already taken place, return immediately.
!-

    IF .TT_OPEN THEN RETURN (1);

!+
! Don't pass this way again.
!-
    TT_OPEN = 1;
!+
! Open the trace file, and write the first record on it.
!-

%IF edt$$tr_act
%THEN
    BEGIN

    EXTERNAL ROUTINE
	EDT$$TR_OPN : ADDRESSING_MODE (GENERAL);

    EXTERNAL
	EDT$$L_TR_INFLG;			! 1 iff input from trace file

    LOCAL
	OPEN_STATUS,
	TRACE_READ_STATUS;

    OPEN_STATUS = EDT$$TR_OPN (EDT$$L_TR_INFLG);

    IF ( NOT .OPEN_STATUS) THEN SIGNAL_STOP (.OPEN_STATUS);

    $$TRACE (EDT$$TR_START, EDT$$TR_SSTART_INIT, 0, 0);
!+
! If we are reading a trace file, read the first two records and don't open
! the terminal.
!-
    TRACE_READ_STATUS = $$TRACE_READ (EDT$$TR_START, EDT$$TR_SSTART_INIT, 0, 0, 0);

    IF (.TRACE_READ_STATUS)
    THEN
	BEGIN
	$$TRACE_READ (EDT$$TR_START, EDT$$TR_SSTART_TERM, %UPVAL, EDT$$G_TI_TYP, 0);
	EDT$$G_DEC_CRT = 1;
	EDT$$G_EIGHT_BIT = 0;
	EDT$$G_TI_SCROLL = 1;
	EDT$$G_ENB_AUTRPT = 1;
	EDT$$G_TI_EDIT = 0;
	EDT$$G_TI_DUMB = 0;
	t_devclass = DC$_TERM;
	$$TRACE (EDT$$TR_START, EDT$$TR_SSTART_TERM, %UPVAL, EDT$$G_TI_TYP);
	END;

    END;
%FI

!+
! If we are reading a trace file, bail out now.
!-
    $$TRACE_READING (<RETURN (1)>);
!+
! Open the SYS$INPUT file for terminal input.
!-
    $FAB_INIT (FAB = WORK_FAB, FAC = <GET>, RAT = CR);
    WORK_FAB [FAB$L_FNA] = UPLIT BYTE('SYS$INPUT');
    WORK_FAB [FAB$B_FNS] = 9;
    $RAB_INIT (RAB = TERM_IN_RAB, RAC = SEQ, UBF = MYBUF, USZ = 255, FAB = WORK_FAB, RHB = VFCHD, CTX = 0);

    IF (EDT$$G_IO_STS = $RMS_OPEN (FAB = WORK_FAB))
    THEN
	BEGIN
	EDT$$G_IO_STS = $RMS_CONNECT (RAB = TERM_IN_RAB);

	IF ( NOT .EDT$$G_IO_STS) THEN EDT$$G_IO_STV = .TERM_IN_RAB [RAB$L_STV];

	END
    ELSE
	EDT$$G_IO_STV = .WORK_FAB [FAB$L_STV];

    IF ( NOT .EDT$$G_IO_STS)
    THEN
	BEGIN
	SIGNAL_STOP (EDT$_OPNINTRM, 0, .EDT$$G_IO_STS, .EDT$$G_IO_STV);
	END;

!+
! Open the SYS$OUTPUT file for terminal output.
!-
    $FAB_INIT (FAB = WORK_FAB, FAC = <PUT>, RAT = CR);
    WORK_FAB [FAB$L_FNA] = UPLIT BYTE('SYS$OUTPUT');
    WORK_FAB [FAB$B_FNS] = 10;
    $RAB_INIT (RAB = TERM_OUT_RAB, RAC = SEQ, UBF = MYBUF, USZ = 255, FAB = WORK_FAB, RHB = VFCHD, CTX = 0);

    IF (EDT$$G_IO_STS = $RMS_CREATE (FAB = WORK_FAB))
    THEN
	BEGIN
	EDT$$G_IO_STS = $RMS_CONNECT (RAB = TERM_OUT_RAB);

	IF ( NOT .EDT$$G_IO_STS) THEN EDT$$G_IO_STV = .TERM_OUT_RAB [RAB$L_STV];

	END
    ELSE
	EDT$$G_IO_STV = .WORK_FAB [FAB$L_STV];

    IF ( NOT .EDT$$G_IO_STS) THEN SIGNAL_STOP (EDT$_OPNOUTTRM, 0, .EDT$$G_IO_STS, .EDT$$G_IO_STV);

!+
! Now also open the terminal for $QIOs.
!-
    EDT$$G_DEC_CRT = 0;		! Make sure this variable is initialized
    NAME_DESC [0] = 9;
    NAME_DESC [1] = NAME_BUF;
    EDT$$CPY_MEM (9, UPLIT ('SYS$INPUT'), NAME_BUF);
    RES_DESC [1] = NAME_BUF;
    RES_DESC [0] = 64;

    WHILE ($TRNLOG (LOGNAM = NAME_DESC, RSLLEN = NAME_DESC [0], RSLBUF = RES_DESC) EQL SS$_NORMAL) DO
	BEGIN

	IF (CH$RCHAR (NAME_BUF) EQL 27)
	THEN
	    BEGIN
	    NAME_DESC [1] = CH$PTR (NAME_BUF, 4);
	    NAME_DESC [0] = .NAME_DESC [0] - 4;
	    END
	ELSE
	    NAME_DESC [1] = CH$PTR (NAME_BUF);

	IF (CH$RCHAR (CH$PTR (.NAME_DESC [1], .NAME_DESC [0] - 1)) EQL %C':')
	THEN
	    NAME_DESC [0] = .NAME_DESC [0] - 1;

	END;

    NAME_DESC [1] = NAME_BUF;

    IF $ASSIGN (DEVNAM = NAME_DESC, CHAN = TT_CHAN)
    THEN
	BEGIN
!+
! Set up the item list for the $GETDVI routine.  We need to access device
! type, characteristics, width, dependent characteristics, extended
! characteristics, and class.
!-

	INCR I FROM 0 TO 5 DO
	    BEGIN
	    ITEM_LIST [.I, BF_LEN] = 4;
	    ITEM_LIST [.I, RLEN_ADR] = 0;
	    END;

!
	ITEM_LIST [0, I_CODE] = DVI$_DEVCHAR;
	ITEM_LIST [0, BUF_ADR] = T_DEVCHAR;
	ITEM_LIST [1, I_CODE] = DVI$_DEVCLASS;
	ITEM_LIST [1, BUF_ADR] = t_devclass;
	ITEM_LIST [2, I_CODE] = DVI$_DEVDEPEND;
	ITEM_LIST [2, BUF_ADR] = T_DEVDEP;
	ITEM_LIST [3, I_CODE] = DVI$_DEVDEPEND2;
	ITEM_LIST [3, BUF_ADR] = t_devextdep;
	ITEM_LIST [4, I_CODE] = DVI$_DEVTYPE;
	ITEM_LIST [4, BUF_ADR] = t_devtype;
	ITEM_LIST [5, I_CODE] = DVI$_DEVBUFSIZ;
	ITEM_LIST [5, BUF_ADR] = T_DEVWID;
	ITEM_LIST [6, I_CODE] = 0;		! End of item list
!+
! Get an event flag
!-
	EF_STATUS = LIB$GET_EF (EF);

	IF ( NOT .EF_STATUS) THEN SIGNAL_STOP (.EF_STATUS);

	$GETDVI (EFN = .EF, CHAN = .TT_CHAN, DEVNAM = NAME_DESC, ITMLST = ITEM_LIST);
	$WAITFR (EFN = .EF);

	IF (.t_devclass EQL DC$_TERM)
	THEN
	    BEGIN
!+
! Get terminal width.  If this is not a terminal, then the width has
! previously been initialized to '80'
!-
	    EDT$$G_TI_WID = .T_DEVWID;
!+
! Get terminal type.
!-

	    SELECTONE .t_devtype OF
		SET

		[DT$_VT52, DT$_VT55] :
		    BEGIN
		    EDT$$G_TI_TYP = TERM_VT52;
		    EDT$$G_TI_SCROLL = 0;
		    EDT$$G_ENB_AUTRPT = 0;
		    EDT$$G_TI_EDIT = 0;
		    EDT$$G_TI_DUMB = 0;
		    END;

		[DT$_VT100, DT$_VT125] :
		    BEGIN
		    EDT$$G_TI_TYP = TERM_VT100;
		    EDT$$G_TI_SCROLL = 1;
		    EDT$$G_ENB_AUTRPT = 1;
		    EDT$$G_TI_EDIT = .t_devextdep [TT2$V_EDIT];
		    EDT$$G_TI_DUMB = 0;
		    edt$$g_dec_crt = 1
		    END;

		[OTHERWISE] :
		    BEGIN
		    EDT$$G_TI_TYP = TERM_HCPY;	! In case this is not a CRT
		    EDT$$G_TI_SCROLL = 0;
		    EDT$$G_ENB_AUTRPT = 0;
		    EDT$$G_TI_EDIT = 0;
!+
! The terminal driver has extended characteristics if any bit is set in
! T_DEVEXTDEP.  If this is a CRT with at least VT100 functionality, treat
! it as a VT100.
!-

		    IF (.T_DEVDEP [TT$V_SCOPE] AND .t_devextdep [TT2$V_ANSICRT])
		    THEN
			BEGIN
			EDT$$G_TI_TYP = TERM_VT100;
			EDT$$G_TI_SCROLL = .t_devextdep [TT2$V_DECCRT];
			EDT$$G_TI_EDIT = .t_devextdep [TT2$V_EDIT];
!+
! Set the terminal "service class" specifier.
!-

%IF %DECLARED(%QUOTE TT2$V_DECCRT2) %THEN
			IF .t_devextdep [TT2$V_DECCRT2] THEN
			    edt$$g_dec_crt = 2
			ELSE
%FI
			    edt$$g_dec_crt = 1
			END;

		    EDT$$G_TI_DUMB = 0;
		    END;
		TES;

!+
! Set the eight-bit flag and store the page length.
!-
	    EDT$$G_EIGHT_BIT = .T_DEVDEP [TT$V_EIGHTBIT];
	    EDT$$G_TI_PLEN = .T_DEVDEP [TT$V_PAGE];
!+
! Set LOWER attribute and disable escape sequences if not already done
!-

	    IF (.T_DEVDEP [TT$V_ESCAPE] OR ( NOT .T_DEVDEP [TT$V_LOWER]))
	    THEN
		BEGIN
		TT_INFO [S_CLASS] = .t_devclass;
		TT_INFO [S_TYPE] = .t_devtype;
		TT_INFO [S_WID] = .T_DEVWID;
		TT_INFO [S_CHAR] = .T_DEVDEP;
		BLOCK [TT_INFO [S_CHAR], TT$V_ESCAPE] = 0;
		BLOCK [TT_INFO [S_CHAR], TT$V_LOWER] = 1;
!
		QIO_STATUS = $QIOW (EFN = .EF, CHAN = .TT_CHAN, FUNC = IO$_SETMODE, P1 = TT_INFO);

		IF ( NOT .QIO_STATUS) THEN SIGNAL_STOP (.QIO_STATUS);

		EDT$$G_TI_RESET = 1;
		END;

!+
! Free up the event flag
!-
	    EF_STATUS = LIB$FREE_EF (EF);

	    IF ( NOT .EF_STATUS) THEN SIGNAL_STOP (.EF_STATUS);

!+
! Enable control-c handling.
!-
	    CC_ENABLE ();
	    END
	ELSE
	    EDT$$G_TI_TYP = TERM_UNKNOWN;

	END;

!+
! Write second startup record.
!-
    $$TRACE (EDT$$TR_START, EDT$$TR_SSTART_TERM, %UPVAL, EDT$$G_TI_TYP);
    RETURN (1);
    END;					! of routine EDT$$TI_OPN


%SBTTL 'EDT$$TI_RES  - restore the terminal'

GLOBAL ROUTINE EDT$$TI_RES 			! Restore the terminal
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine restores the terminal characteristics to what they
! 	were when EDT was entered.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	T_DEVCHAR
!	T_DEVCLASS
!	T_DEVDEP
!	T_DEVTYPE
!	T_DEVWID
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 = unsuccessful
!	1 = successful
!
! SIDE EFFECTS:
!
!	Changes the logical terminal characteristics
!
!--

    BEGIN

    LOCAL
	QIO_STATUS,
	EF_STATUS,
	EF,
	TT_INFO : BLOCK [2] FIELD (SETM_FIELDS);	! Terminal characteristics

!+
! If SYS$INPUT is not a terminal, do nothing.
!-

    IF (.t_devclass NEQ DC$_TERM) THEN RETURN (1);

    TT_INFO [S_CLASS] = .t_devclass;
    TT_INFO [S_TYPE] = .t_devtype;
    TT_INFO [S_WID] = .T_DEVWID;
    TT_INFO [S_CHAR] = .T_DEVDEP;
!+
! Get an event flag
!-
    EF_STATUS = LIB$GET_EF (EF);

    IF ( NOT .EF_STATUS) THEN SIGNAL_STOP (.EF_STATUS);

    QIO_STATUS = $QIOW (EFN = .EF, CHAN = .TT_CHAN, FUNC = IO$_SETMODE, P1 = TT_INFO);
!+
! Free up the event flag
!-
    EF_STATUS = LIB$FREE_EF (EF);

    IF ( NOT .EF_STATUS) THEN SIGNAL_STOP (.EF_STATUS);

    IF (.QIO_STATUS) THEN RETURN (1) ELSE RETURN (0);

    END;					! of routine EDT$$TI_RES


%SBTTL 'EDT$$TI_DEAS - deassign the terminal'

GLOBAL ROUTINE EDT$$TI_DEAS 			! Deassign the terminal channel
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine deassigns the terminal channel and restores OWN storage.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	TT_CHAN
!	EDT$$L_TR_INFLG
!	T_DEVCLASS
!	T_DEVDEP
!	T_DEVEXTDEP
!	T_DEVTYPE
!
! IMPLICIT OUTPUTS:
!
!	ATTRIBUTES_SET
!	ATTRIBUTES_DEFAULTED
!	TT_OPEN
!
! ROUTINE VALUE:
!
!	0 = unsuccessful
!	1 = successful
!
! SIDE EFFECTS:
!
!	Sets application keypad mode or numeric keypad mode
!	Deassigns the terminal channel
!
!--

    BEGIN

%IF edt$$tr_act
%THEN

    EXTERNAL
	EDT$$L_TR_INFLG;			! 1 iff input from trace file

%FI

    LOCAL
	STATUS,
	term_set;

!+
! Set either application keypad mode or numeric keypad mode depending on the user's stated
! preference.  This only applies to VT100 and VT52 terminals.
!-
    term_set = 1;

%IF edt$$tr_act
%THEN

    IF .edt$$l_tr_inflg THEN term_set = 0;

%FI

    IF (.t_devclass NEQ DC$_TERM) THEN term_set = 0;

    IF ( NOT .t_devdep [tt$v_scope]) THEN term_set = 0;

    IF ( NOT (	.t_devextdep [TT2$V_DECCRT] OR
		(.t_devtype EQL DT$_VT52)   OR
		(.t_devtype EQL DT$_VT55)	) ) THEN term_set = 0;

    IF .term_set
    THEN
%IF %DECLARED(%QUOTE TT2$V_APP_KEYPAD) %THEN
	IF .t_devextdep [TT2$V_APP_KEYPAD]
	THEN
	    EDT$$TI_WRSTR (UPLIT (BYTE (ASC_K_ESC, '=')), 2)
	ELSE
%FI
	    EDT$$TI_WRSTR (UPLIT (BYTE (ASC_K_ESC, '>')), 2);
!+
! Make sure all of this module's OWN storage is back to its initial state
! in case we get called again.
!-
    ATTRIBUTES_SET = 0;
    ATTRIBUTES_DEFAULTED = 0;
!+
! If we are taking input from the terminal, close the terminal's channel.
!-

%IF edt$$tr_act
%THEN

    IF ( NOT .EDT$$L_TR_INFLG) THEN STATUS = $DASSGN (CHAN = .TT_CHAN) ELSE STATUS = 1;

%ELSE
    STATUS = $DASSGN (CHAN = .TT_CHAN);
%FI

    TT_OPEN = 0;

    IF ( NOT .STATUS) THEN SIGNAL_STOP (.STATUS);

    END;					! of routine EDT$$TI_DEAS


%SBTTL 'EDT$$RD_CMDLN  - read a command line'

GLOBAL ROUTINE EDT$$RD_CMDLN (			! Read a command line
    PROMPT, 					! The address of the prompt string
    PR_LEN, 					! The length of the prompt string
    BUF, 					! The address of the receiving buffer
    LEN, 					! Address of a longword to receive the length read
    BUF_LN					! Optional length of the buffer
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read a command line.  A line is read from the terminal.
!
! FORMAL PARAMETERS:
!
!  PROMPT		The address of the prompt string
!  PR_LEN		The length of the prompt string
!  BUF			The address of the receiving buffer
!  LEN			The address of a longword to receive the length read
!  BUF_LN		(optional) the length of the buffer, defaults to 255
!
! IMPLICIT INPUTS:
!
!	TERM_IN_RAB
!
! IMPLICIT OUTPUTS:
!
!	TERM_IN_RAB
!	IO_STS
!
! ROUTINE VALUE:
!
!	Return value is 1 if EOF, 0 otherwise.
!
! SIDE EFFECTS:
!
!	Calls $IO_ERRMSG for I/O errors.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    ASSERT (.EDT$$G_RDAHED EQL 0);
    IO_STS = 0;

    WHILE ( NOT .IO_STS) DO
	BEGIN
	$$TRACE (EDT$$TR_KEY, EDT$$TR_SK_PROMPT, .PR_LEN, .PROMPT);
	TERM_IN_RAB [RAB$L_PBF] = .PROMPT;
	TERM_IN_RAB [RAB$B_PSZ] = .PR_LEN;
	TERM_IN_RAB [RAB$L_UBF] = .BUF;
	TERM_IN_RAB [RAB$W_USZ] = 255;
	TERM_IN_RAB [RAB$L_ROP] = RAB$M_PMT;

	IF (ACTUALCOUNT () EQL 5) THEN TERM_IN_RAB [RAB$W_USZ] = .BUF_LN;

	$$TRACE (EDT$$TR_IDLE, EDT$$TR_SIDLE_KIN, 0, 0);

	IF ( NOT $$TRACE_READ (EDT$$TR_KEY, EDT$$TR_SK_STS, %UPVAL, IO_STS, 0))
	THEN
	    IO_STS = $RMS_GET (RAB = TERM_IN_RAB);

	$$TRACE (EDT$$TR_KEY, EDT$$TR_SK_STS, %UPVAL, IO_STS);

	IF ( NOT $$TRACE_READ (EDT$$TR_KEY, EDT$$TR_SK_LN, .TERM_IN_RAB [RAB$W_USZ], .BUF, .LEN))
	THEN
	    .LEN = .TERM_IN_RAB [RAB$W_RSZ];

	$$TRACE (EDT$$TR_KEY, EDT$$TR_SK_LN, ..LEN, .BUF);

	IF (.IO_STS EQL RMS$_EOF) THEN RETURN (1);

	IF ( NOT .IO_STS)
	THEN
	    BEGIN
	    EDT$$G_IO_STS = .IO_STS;
	    EDT$$G_IO_STV = .TERM_IN_RAB [RAB$L_STV];
	    EDT$$FMT_MSG (EDT$_ERRINPTRM);
	    EDT$$IO_ERRMSG ();
	    END;

	END;

    RETURN (0);
    END;					! of routine EDT$$RD_CMDLN


%SBTTL 'EDT$$TI_WRLN  - write a line to the terminal'

GLOBAL ROUTINE EDT$$TI_WRLN (			! Write a line to the terminal
    BUF, 					! Starting address of the line
    LEN						! Length of the line
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes a line to the terminal.
!	If an error is detected, it is considered fatal, since
!	we are not commnunicating with the user.
!
! FORMAL PARAMETERS:
!
!  BUF			the address of the buffer containing the line.
!  LEN			the length of the line to be written.
!
! IMPLICIT INPUTS:
!
!	TERM_OUT_RAB
!
! IMPLICIT OUTPUTS:
!
!	TERM_OUT_RAB
!	IO_STV, if there is an error
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Calls EDT$$FATAL_IOERR  on an I/O error.
!
!--

    BEGIN

    LOCAL
	STAT;

    TERM_OUT_RAB [RAB$L_RBF] = .BUF;
    TERM_OUT_RAB [RAB$W_RSZ] = .LEN;
    $$TRACE (EDT$$TR_SCR, EDT$$TR_SSCR_LN, .LEN, .BUF);
    $$TRACE_READING (<RETURN (0)>);

    IF (STAT = $RMS_PUT (RAB = TERM_OUT_RAB)) THEN RETURN;

    EDT$$G_IO_STV = .TERM_OUT_RAB [RAB$L_STV];
    EDT$$FATAL_IOERR (.STAT);
    END;					! of routine EDT$$TI_WRLN


%SBTTL 'EDT$$TI_GETCH  - Get one character'

GLOBAL ROUTINE EDT$$TI_GETCH (			! Get one character
    C						! Where to store character
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read a single character from the terminal.
!
! FORMAL PARAMETERS:
!
!  C			Where to store character read
!
! IMPLICIT INPUTS:
!
!	TT_CHAN
!	INPUT_EFN
!	HAVE_EFNS
!	T_DEVCLASS
!
! IMPLICIT OUTPUTS:
!
!	EDT$$G_RDAHED
!	EDT$$T_RDAHED
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STS,
	TMASK : VECTOR [2],
	FUNC_VAL;

    ASSERT (.EDT$$G_RDAHED EQL 0);
!+
! If SYS$INPUT is not a terminal, just return a control Z.
!-

    IF (.t_devclass NEQ DC$_TERM)
    THEN
	BEGIN
	.C = ASC_K_CTRL_Z;
	RETURN;
	END;

!+
! Make sure we have the event flags to drive the terminal.
!-

    IF ( NOT .HAVE_EFNS) THEN EDT$$TI_ENTERCHM ();

    TMASK [0] = 32;
    TMASK [1] = UPLIT (-1, -1, -1, -1, -1, -1, -1, -1);
    $$TRACE (EDT$$TR_IDLE, EDT$$TR_SIDLE_KIN, 0, 0);
    ASSERT (.HAVE_EFNS);

    IF ( NOT $$TRACE_READ (EDT$$TR_KEY, EDT$$TR_SK_CH_NE, K_RDAHED_LEN, EDT$$T_RDAHED, EDT$$G_RDAHED))	!
    THEN

	DO
	    BEGIN
	    FUNC_VAL = IO$_READVBLK + IO$M_NOECHO + IO$M_NOFILTR + IO$M_TRMNOECHO;

	    IF (( NOT edt$$tr_act) AND (.EDT$$T_PMT_KPD [0] EQL 0)) THEN FUNC_VAL = .FUNC_VAL + IO$M_ESCAPE;

	    STS = $QIOW (EFN = .INPUT_EFN, CHAN = .TT_CHAN, P1 = EDT$$T_RDAHED, P2 = K_RDAHED_LEN, 	!
		P4 = TMASK, IOSB = IOSB, FUNC = .FUNC_VAL);

	    IF ( NOT .STS) THEN SIGNAL_STOP (EDT$_ERRINPTRM, 0, .STS);

	    EDT$$G_RDAHED = .IOSB [1] + .IOSB [3];
!+
! Keep doing the QIO until we get something.  We can get nothing if we were interrupted by a control Y
! and then continued by a CONTINUE command.
!-
	    END
	UNTIL (.EDT$$G_RDAHED GTR 0);

    $$TRACE (EDT$$TR_KEY, EDT$$TR_SK_CH_NE, .EDT$$G_RDAHED, EDT$$T_RDAHED);
    .C = CH$RCHAR (EDT$$T_RDAHED);
    EDT$$G_RDAHED = .EDT$$G_RDAHED - 1;

    IF (.EDT$$G_RDAHED GTR 0) THEN CH$MOVE (.EDT$$G_RDAHED, CH$PLUS (EDT$$T_RDAHED, 1), EDT$$T_RDAHED);

    END;					! of EDT$$TI_GETCH


%SBTTL 'EDT$$TI_WRSTR  - write to terminal without carriage control'

GLOBAL ROUTINE EDT$$TI_WRSTR (			! Write to the terminal without implied carriage control
    BUF, 					! Address of the buffer to write
    LEN						! Length of that buffer
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write a buffer on the terminal without implied carraige control.
!
! FORMAL PARAMETERS:
!
!  BUF			Address of the buffer to write
!
!  LEN			Length of that buffer
!
! IMPLICIT INPUTS:
!
!	TT_CHAN
!	OUTPUT_EFN
!	HAVE_EFNS
!	T_DEVCLASS
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
!+
! Do nothing if the length is zero or SYS$INPUT is not a terminal.
!-

    IF ((.LEN GTR 0) AND (.t_devclass EQL DC$_TERM))
    THEN
	BEGIN
!+
! Make sure the event flags are allocated.
!-

	IF ( NOT .HAVE_EFNS) THEN EDT$$TI_ENTERCHM ();

	ASSERT (.HAVE_EFNS);
	$$TRACE (EDT$$TR_SCR, EDT$$TR_SSCR_CH, .LEN, .BUF);
	$$TRACE_READING (<RETURN (0)>);
	ASSERT ($WAITFR (EFN = .OUTPUT_EFN));
	ASSERT ($QIOW (EFN = .OUTPUT_EFN, CHAN = .TT_CHAN, P1 = .BUF, P2 = .LEN,
		FUNC = IO$_WRITEVBLK + IO$M_NOFORMAT));
	END;

    END;					! of routine EDT$$TI_WRSTR


%SBTTL 'EDT$$TI_RDTYAHED  - read a character from typeahead'

GLOBAL ROUTINE EDT$$TI_RDTYAHED (		! Read a character from typeahead
    TEXT					! Address of the string read
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the type-ahead buffer.  It returns the string in
!	TEXT, the number of characters read as its value.
!
! FORMAL PARAMETERS:
!
!  TEXT			Address of the string read
!
! IMPLICIT INPUTS:
!
!	INPUT_EFN
!	OUTPUT_EFN
!	HAVE_EFNS
!	T_DEVCLASS
!
! IMPLICIT OUTPUTS:
!
!	IOSB
!
! ROUTINE VALUE:
!
!	The number of characters read
!
! SIDE EFFECTS
!
!	NONE
!
!--

    BEGIN

    LOCAL
	RETURN_VALUE,
	TMASK : VECTOR [2];

!+
! If SYS$INPUT is not a terminal there can be no typeahead.
!-

    IF (.t_devclass NEQ DC$_TERM) THEN RETURN (0);

!+
! Make sure the event flag numbers are allocated.
!-

    IF ( NOT .HAVE_EFNS) THEN EDT$$TI_ENTERCHM ();

    ASSERT (.HAVE_EFNS);
    TMASK [0] = 32;
    TMASK [1] = UPLIT (-1, 0, 0, %X'80000000', -1, 0, 0, 0);
!+
! In trace mode we cannot process typeahead.
!-

%IF ( NOT edt$$tr_act)
%THEN
    ASSERT ($WAITFR (EFN = .OUTPUT_EFN));
    ASSERT ($QIOW (EFN = .INPUT_EFN, CHAN = .TT_CHAN, P1 = .TEXT, P2 = K_RDAHED_LEN, P3 = 0, P4 = TMASK,
	    IOSB = IOSB, FUNC = IO$_READVBLK + IO$M_NOECHO + IO$M_NOFILTR + IO$M_TIMED));
    RETURN_VALUE = .IOSB [1] + .IOSB [3];
%ELSE
    RETURN_VALUE = 0;
%FI

    RETURN (.RETURN_VALUE);
    END;					! of routine EDT$$TI_RDTYAHED


%SBTTL 'EDT$$TI_RDSTR  - read characters until control or DEL'

GLOBAL ROUTINE EDT$$TI_RDSTR (			! Read characters until control or DEL
    BUF, 					! Address of the buffer to read into
    LEN, 					! Length of that buffer
    LEN_READ					! Store here the number of characters read
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads characters with echo on until any control character or
!	a DEL character are seen.
!
! FORMAL PARAMETERS:
!
!  BUF			Address of the buffer to read into.
!
!  LEN			Length of the buffer.
!
!  LEN_READ		Address of a longword to receive the number of characters read.
!
! IMPLICIT INPUTS:
!
!	TT_CHAN
!	OUTPUT_EFN
!	T_MASK
!	EDT$$T_FMT_BUF
!	EDT$$A_FMT_CUR
!	IOSB
!	HAVE_EFNS
!	T_DEVCLASS
!
! IMPLICIT OUTPUTS:
!
!	IOSB
!	EDT$$A_FMT_CUR
!	EDT$$T_RDAHED
!	EDT$$G_RDAHED
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	TMASK : VECTOR [2],
	TERM : VECTOR [K_RDAHED_LEN, BYTE],	! The string that terminated the line, if any
	LEN_TERM;				! number of characters in the terminator

!+
! If SYS$INPUT is not a terminal just return control Z.
!-

    IF (.t_devclass NEQ DC$_TERM)
    THEN
	BEGIN
	.LEN_READ = 0;
	EDT$$T_RDAHED = ASC_K_CTRL_Z;
	EDT$$G_RDAHED = 1;
	RETURN;
	END;

!+
! Make sure the event flags are allocated.
!-

    IF ( NOT .HAVE_EFNS) THEN EDT$$TI_ENTERCHM ();

    ASSERT (.EDT$$G_RDAHED EQL 0);
    ASSERT (.HAVE_EFNS);
!+
! Set up the terminator mask.
!-
    TMASK [0] = 32;
    TMASK [1] = UPLIT (-1, 0, 0, %X'80000000', -1, 0, 0, 0);
    $$TRACE (EDT$$TR_KEY, EDT$$TR_SK_PROMPT, .EDT$$A_FMT_CUR - EDT$$T_FMT_BUF, EDT$$T_FMT_BUF);
    $$TRACE (EDT$$TR_IDLE, EDT$$TR_SIDLE_KIN, 0, 0);

    IF $$TRACE_READ (EDT$$TR_KEY, EDT$$TR_SK_CH, MIN (.LEN, 72), .BUF, .LEN_READ)
    THEN
	BEGIN
!+
! Since we got the record from the trace file, get the terminator from the trace file.
!-

	LOCAL
	    READ_STATUS;

	TERM [0] = 0;
	READ_STATUS = $$TRACE_READ (EDT$$TR_KEY, EDT$$TR_SK_TERM_NE, K_RDAHED_LEN, TERM, LEN_TERM);
	ASSERT (.READ_STATUS);
	END
    ELSE

	DO
	    BEGIN
!+
! Make sure output is complete.
!-

	    LOCAL
		FUNC_VAL,
		QIO_STATUS;

	    ASSERT ($WAITFR (EFN = .OUTPUT_EFN));
	    FUNC_VAL = IO$_READPROMPT + IO$M_TRMNOECHO + IO$M_NOFILTR;

	    IF (( NOT edt$$tr_act) AND (.EDT$$T_PMT_KPD [0] EQL 0)) THEN FUNC_VAL = .FUNC_VAL + IO$M_ESCAPE;

	    QIO_STATUS = $QIOW (EFN = .INPUT_EFN, CHAN = .TT_CHAN, P1 = .BUF, P2 = MIN (.LEN, 72),
		P4 = TMASK, P5 = EDT$$T_FMT_BUF, P6 = .EDT$$A_FMT_CUR - EDT$$T_FMT_BUF, IOSB = IOSB,
		FUNC = .FUNC_VAL);

	    IF ( NOT .QIO_STATUS) THEN SIGNAL_STOP (.QIO_STATUS);

	    .LEN_READ = .IOSB [1];		! Number of bytes read
	    LEN_TERM = .IOSB [3];		! Number of bytes in the terminator string
	    CH$MOVE (.LEN_TERM, CH$PLUS (.BUF, ..LEN_READ), TERM);
!+
! Keep doing the QIO until we get something.  We can get nothing if a control Y interrupts us
! and we are later continued.
!-
	    END
	UNTIL ((.IOSB [1] + .IOSB [3]) GTR 0);

    EDT$$A_FMT_CUR = EDT$$T_FMT_BUF;
!+
! Make sure the line read and its terminator are recorded in the trace file.
!-
    $$TRACE (EDT$$TR_KEY, EDT$$TR_SK_CH, ..LEN_READ, .BUF);
    $$TRACE (EDT$$TR_KEY, EDT$$TR_SK_TERM_NE, .LEN_TERM, TERM);
!+
! If we had a terminator return it by placing it in the type-ahead buffer.
!-

    IF (.LEN_TERM GTR 0)
    THEN
	BEGIN
	CH$MOVE (.LEN_TERM, TERM, EDT$$T_RDAHED);
	EDT$$G_RDAHED = .LEN_TERM;
	END;

    END;					! of EDT$$TI_RDSTR


%SBTTL 'EDT$$TI_ENTERCHM  - enter change mode'

GLOBAL ROUTINE EDT$$TI_ENTERCHM 		! Enter change mode
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Enter change mode.  Allocate event flags.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	HAVE_EFNS
!	T_DEVCLASS
!
! IMPLICIT OUTPUTS:
!
!	INPUT_EFN
!	OUTPUT_EFN
!	HAVE_EFNS
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Allocates two event flags for full-duplex terminal I/O, if necessary.
!
!--

    BEGIN

    LOCAL
	INPUT_EF_STATUS,
	OUTPUT_EF_STATUS;

!+
! If the event flags are already allocated, or if SYS$INPUT is not a terminal, do nothing.
!-

    IF ((.HAVE_EFNS) OR (.t_devclass NEQ DC$_TERM)) THEN RETURN;

!+
! Allocate event flags for input and output.
!-
    INPUT_EF_STATUS = LIB$GET_EF (INPUT_EFN);

    IF ( NOT .INPUT_EF_STATUS) THEN SIGNAL_STOP (.INPUT_EF_STATUS);

    OUTPUT_EF_STATUS = LIB$GET_EF (OUTPUT_EFN);

    IF ( NOT .OUTPUT_EF_STATUS) THEN SIGNAL_STOP (.OUTPUT_EF_STATUS);

    $SETEF (EFN = .OUTPUT_EFN);
    HAVE_EFNS = 1;
    ASSERT (.HAVE_EFNS);
    END;					! of routine EDT$$TI_ENTERCHM


%SBTTL 'EDT$$TI_LEAVECHM  - leave change mode'

GLOBAL ROUTINE EDT$$TI_LEAVECHM 		! Leave change mode
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Leave change mode.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	HAVE_EFNS
!	INPUT_EFN
!	OUTPUT_EFN
!
! IMPLICIT OUTPUTS:
!
!	HAVE_EFNS
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	FREE_INPUT_STATUS,
	FREE_OUTPUT_STATUS;

!+
! If we don't have the event flags, do nothing.
!-

    IF ( NOT .HAVE_EFNS) THEN RETURN;

    ASSERT ($WAITFR (EFN = .OUTPUT_EFN));
    FREE_INPUT_STATUS = LIB$FREE_EF (INPUT_EFN);

    IF ( NOT .FREE_INPUT_STATUS) THEN SIGNAL_STOP (.FREE_INPUT_STATUS);

    FREE_OUTPUT_STATUS = LIB$FREE_EF (OUTPUT_EFN);

    IF ( NOT .FREE_OUTPUT_STATUS) THEN SIGNAL_STOP (.FREE_OUTPUT_STATUS);

    HAVE_EFNS = 0;
    ASSERT ( NOT .HAVE_EFNS);
    END;					! of routine EDT$$TI_LEAVECHM

!<BLF/PAGE>

END						! of module EDT$IOMOD

ELUDOM
