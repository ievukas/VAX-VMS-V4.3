MODULE copyspecs (  ! Manipulates input and output specifications for COPY utility
                    LANGUAGE (BLISS32),
                    IDENT = 'V04-000'
                    ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	COPY Command
!
! ABSTRACT:
!
!	This module obtains input and output specifications from the CLI and opens
!	the associated files.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, unprivileged user mode utility,
!	operates at non-AST level.
!
!--
!++
!
! AUTHOR:	Carol Peters,	CREATION DATE:	14 April 1978 14:17
!
! Modified by:
!
!	V03-011	TSK0010		Tamar Krichevsky	  8-May-1984
!		Rearrange the calls to CLI$GET_VALUE and LIB$FIND_FILE, for
!		input filename processing.  This will fix the problem of
!		COPY a.a,a.a,a.a,a.a NL: copying every other file, instead of 
!		every file.
!
!	V03-010	TSK0009		Tamar Krichevsky	 20-Apr-1984
!		Before the input file is opened, clear the longest record
!		length field in the input file's file header XAB.  This will
!		insure that the LRL value will be correct for record oriented
!		devices.  RMS does not clear this field if it is inappropriate.
!		As a result, the LRL could be carried from one file to another.
! 		For example, given the command -- COPY foo.txt,SYS$INPUT a.a --
!		SYS$INPUT inherited the LRL form foo.txt.  (Not kosher!)
!
!	V03-009	TSK0008		Tamar Krichevsky	 28-Mar-1984
!		Fix IF statement in COPY$OPN_OUTFIL which sets up the 
!		default name string as ";*".  It was broken by TSK007.
!
!	V03-008	TSK0007		Tamar Krichevsky	 2-Mar-1984
!		Convert input file parsing and searching to LIB$FIND_FILE.
!		Place the check for WILD_OUTPUT before the potential reparse
!		of the output file.  RMS changed how it set the bits in the
!		NAM$L_FNB field.
!
!	V03-007	TSK0006		Tamar Krichevsky	16-Feb-1984
!		Copy the input and output file names form the command line
!		into the appropriate buffers.   They were getting lost and
!		some error messages were being displayed like so:
!		"Error opening  as input"
!
!		Also add in check to see if the input file's record format
!		is VFC and the fixed control region size is zero.  The SOS
!		editor created files like this.  It knew that the smallest 
!		fixed header size was two bytes; so it assumed 2 when it
!		saw 0.  RMS compenstated for this by setting the size to
!		two bytes.  Unfortunately, the incompatible attributes 
!		comparison would fail because the input file's HSZ field in
!		the XABFHC was zero, but the output file's HSZ was two.
!		When COPY encounters such an input file, it will change the
!		HSZ field to two.
!
!	V03-006	TSK0005		Tamar Krichevsky	3-Oct-1983
!		Move the $DISPLAY, which was added in V03-005, to after the
!		the check for a successful file $CREATE or $OPEN.  Otherwise,
!		an extra message is issued when the file can not be accessed 
!		for the $DISPLAY.
!
!	V03-005	LMP0150		L. Mark Pilant,		9-Sep-1983  11:19
!		Add a $DISPLAY to COPY$OPN_OUTFIL so that the protection
!		of the created file may be obtained.
!
!	V03-004	TSK0004		Tamar Krichevsky	8-Aug-1983
!		Fix ACCVIO during append operations.  Output file's XABPRO
!		should not be removed from XAB chain until file is closed.
!
!	V03-003	TSK0004		Tamar Krichevsky	8-Aug-1983
!		Modify COPY$OPN_OUTFILE, SETUP_OUTXAB and APPLY_OUT_QUAL so 
!		that file protection and revision inforamtion is not propogated 
!		to the output file from the input file.  Fix bug which clears 
!		the expiration date when the output device is mag-tape. Fix 
!		bug in /PROTECTION qualifier so that unspecified fields are 
!		left alone.
!
!	V03-002 TSK0003		Tamar Krichevsky	4-Feb-1982
!		Change over to the new CLI.  Move external declarations from
!		COPY.REQ into this module.
!
!	V03-001 TSK0002		Tamar Krichevsky	4-Feb-1982
!		Copy the buckets size from the input FAB in the output XAB to 
!		insure that the file is created with the correct bucket size.
!		When a file is created, if there are any allocation XABs, the 
!		bucket size in the FAB is ignored.  Therefore, if the input file 
!		has several areas, and area 0 does not have largest BKZ, something
!		other than the BKZ in the first (and only, in COPY's case) XABALL
!		must be used.  The largest bucket size is kept in the input file's
!               FAB. ***************** NOTE:  This works only if the ISAM files (the
!		worst offenders) are copied block mode.  IF FOR ANY REASON ISAM FILES
!		ARE COPIED USING RECORD MODE IN THE FUTURE, THIS PROCEDURE WILL HAVE TO
!		BE CHANGED.
!
!	X00025  TSK0001		Tamar Krichevsky	5-Feb-1982
!		Have Global Buffer Count (GBC) transferred from input FAB to
!		outout FAB.
!
!	X00024	KRM0038		Karl Malik	12-Jan-1982
!		Warn the user (in COPY$OPN_OUTFIL) if the output file
!		was forced to stream format ( in a network copy to
!		a 10,20 or RT system ).
!
!	X00023	KRM0035		Karl Malik	31-Dec-1981
!		Check for network quoted string in single output filespec
!		& if found, do not force multiple output files.
!
!	X00022	WMC0030		Wayne Cardoza	15-Dec-1981
!		Disallow output directory wildcards remaining after the output
!		file parse with the related input file.
!
!	X00021	WMC0021		Wayne Cardoza	8-Dec-1981
!		Set no_output_spec if only directory is wild and no explicit
!		filename components.
!
!	X00020	KFH0001		Ken Henderson	28-Sep-1981
!		Expiration and Backup dates are not copied from input file,
!		but instead are defaulted.
!
!	X00019	WMC0001		Wayne Cardoza	22-Jul-1981
!		Explicit protection specification should not cause old dates
!		to be preserved if a file spec is also present.
!
!	X00018	SPF0001		S. Forgey	27-Jan-1981
!		Allow wildcard directories in output file specifications to
!		go along with RMS now handling "sticky" directories.
!
!	X00017	JAK0017		J. Krycka	18-Sep-1980
!		Alter the X00006 special check for network access in setting up
!		the output Allocation XAB (i.e., gat ALQ and DEQ values from the
!		FHC XAB).
!
!	X00016	TMH0015		Tim Halvorsen	24-Mar-1980
!		Force creation of a new file (creation date, owner, prot)
!		if the output file specification is explicit to maintain
!		compatibility with release 1 behavior.  This involves changing
!		the previous update to remove remove xabpro,rdt,dat if
!		explicit output filespec as long as /PROT was not specified
!		(If /PROT specified, xabpro must not be removed to allow it
!		to work).
!
!	X00015	TMH0014		Tim Halvorsen	19-Mar-1980
!		Do not remove output XABPRO,RDT,DAT blocks if concat_follows
!		flag is set because we were only trying to prevent changing
!		characteristics on existing files -- concatenation always
!		produces a new file.  Also, inhibit wildcard directories on
!		output file specifications.
!
!	X00014	TMH0013		Tim Halvorsen	17-Mar-1980
!		Issue ENDPRM2 call at the same time as ENDPRM1 call
!		to eliminate problems with parameter ordering (in MCR,
!		the parameters appear in reverse order).
!
!	X00013	JAK0003		J. Krycka	14-Jan-1980
!		Undo X00005 change so that COPY will be able to use block I/O
!		to copy relative and indexed files over the network.
!
!	X00012	TMH0012		T. Halvorsen	29-Dec-1979
!		Remove XABPRO on appends since changing both owner or
!		protection is prohibited (see X00010)
!
!	X00011	TMH0011		T. Halvorsen	15-Nov-1979
!		Call CLI back with ENDPRM2 after output filespec is
!		obtained to signal any unprocessed qualifiers.
!
!	X00010	TMH0010		T. Halvorsen	13-Nov-1979
!		Zero the owner UIC field of the XABPRO on appends since
!		changing the owner UIC for an existing file is prohibited.
!
!	X00009	TMH0009		T. Halvorsen	24-Oct-1979
!		Test for output spec of only an explicit nodename
!		so that the filename is defaulted correctly.
!		Fix relative volume placement control to be hard (issue an
!		error if the file cannot completely be placed on the volume).
!
!	X00008	T. Halvorsen	25-Jul-1979
!		Add relative volume placement control.
!		Fix message to indicate contiguous-best-try is being tried
!		when there is not enough contigous space rather than issuing
!		an error message.
!
!	X00007	T. Halvorsen	14-Jul-1979
!		Fix problem copying ISAM files after another file (BIO
!		was left on from previous file).
!
!	X00006	JAK0002		J. Krycka	16-Mar-1978	14:00
!		To support copy of files over the network, get ALQ and DEQ
!		values from input XABALL if NET bit is set.
!
!	X00005	JAK0001		J. Krycka	16-Mar-1978	14:00
!		To support copy of relative files over the network, set
!		BRO bit in output FAB if NET bit is set.
!
!	X00004	CHP20339	C. Peters	25-Oct-1978	14:10
!		In COPY$GET_INFILE, zero ESL and RSL fields to avoid
!		reporting wrong file specification on error.
!
!	X00003	CHP19547	C. Peters	7-Oct-1978	14:27
!		Don't make version numbers sticky in an APPEND command.
!
!--

!
! Table of Contents
!
FORWARD ROUTINE
    copy$get_infile,					! Obtains the input file specification
    copy$opn_infile,					! Opens the current input file
    copy$get_outfil,					! Obtains the output file specification
    copy$opn_outfil,					! Opens the current output file
    setup_extend,					! Sets up an output file to be extended.
    setup_outxab	: NOVALUE,			! Sets up XAB fields for an output file.
    apply_out_qual	: NOVALUE;			! Sets output fields depending on file qualifiers.

!
! Include files
!

LIBRARY 'SYS$LIBRARY:STARLET.L32';			! VAX/VMS system definitions
REQUIRE 'SRC$:COPYMSG.REQ';				! Definition of macros to SIGNAL a message

!
! Macros
!
MACRO
    
    ! Check to see if the global or local qualifier flag is set without the 
    ! local negation flag being set.
    !
    qualifier_active( global_qual, local_qual, locally_negated ) =
    	(IF (.global_qual AND NOT .locally_negated) OR .local_qual
    	 THEN true
    	 ELSE false )%
    ;

!
! External variables
!
EXTERNAL
    copy$cli_status : $BBLOCK,
    copy$sem_status : $BBLOCK,

    curr_allocation_value,
    curr_extension_value,
    curr_protection_or,
    curr_protection_and,
    curr_file_max_value,
    curr_volume_value,

    infile_cli_desc	: $BBLOCK[],			! Descriptor for input file name returned by CLI
    in_name_desc	: VECTOR,			! Descriptor of input file specification
    out_name_desc	: VECTOR			! descriptor for output file specification
    ;

REQUIRE
    'SRC$:COPY.REQ'					! Field definitions for  COPY$CLI_STATUS and COPY$SEM_STATUS
    ;

EXTERNAL ROUTINE
    cli$get_value : addressing_mode( general ),
    copy$get_global_qual,				! Retrieves command level qualifiers
    copy$get_local_qual,				! Retrieves local qualifiers
    copy$check_file_for_match,				! See if input file matches command line criteria
    copy$calc_alq,					! Calculates a file extension quantity.
    copy$close_outf,					! Closes an output file
    copy$inopn_err,					! Handles an input $OPEN error
    copy$log_msg,					! Logs a message about COPY's activities
    copy$oclose_err,					! Handles an output file close error.
    copy$outopn_err,					! Handles an output $OPEN error
    copy$find_input_file,				! Finds and parses an input file specification
    copy$semantics;					! Determines semantics of a command

GLOBAL ROUTINE copy$get_infile (input_fab, input_nam, input_xaball) =
							! Obtain input file specification

!++
! Functional description:
!
!	This routine gets an input file specification and all
!	related qualifiers from the Command Language Interpreter. Then
!	the file specification is parsed.
!
!	If a wildcard specification is still being processed, or if
!	no more input specifications are available, this routine just
!	returns successfully.
!
!	A series of flags are set if certain conditions obtain. These
!	conditions describe the current list of files that are candidates
!	for concatenation. The flags are set if the file specification
!	contains input wildcards, an explicit wildcard version number, or an explicit version number.
!
!	Another flag applies only to this specification and says whether it contains any wildcards.
!
! Calling sequence:
!
!	copy$get_infile (input_fab.ra.v, input_nam.ra.v, input_xaball.ra.v)
!
! Input parameters:
!
!	input_fab	- the FAB to use for this input specification
!	input_nam	- the NAM to use for this input specification
!	input_xaball	- the XABALL to use for this input specification
!
! Implicit inputs:
!
!	wildcard_active	- a bit in COPY$CLI_STATUS that says that we are
!			  already processing an input wildcard.
!
! Output parameters:
!
!	none
!
! Implicit outputs:
!
!	The fields of the FAB and the NAM block are filled in according
!	to the CLI call and the $PARSE function call.
!
!	The RSL field of the dummy_nam_blk is filled in by the routine COPY$FIND_INPUT_FILE. This is later
!	used in parsing the name additional input files or output files.
!
!	A bit in COPY$CLI_STATUS may be set:
!
!		multiple_input	- more than one input file specification in the command
!		wildcard_active	- if a wildcard is present
!
!	Some bits in COPY$SEM_STATUS may be set:
!
!		wild_input	- wildcard fields exist
!		wild_inp_ver	- a wildcard version number exists
!		exp_inp_ver	- an explicit version number exists
!
! Routine value:
!
!	OK		- success
!	NO_MORE_FILES	- success, no more input specifications
!	NO_FILE		- failure
!
! Side effects:
!
!	none
!
!--

    BEGIN

    LOCAL
    	rtn_status;					! Retrun status from external calls

    MAP
        input_fab	: REF BLOCK [, BYTE],		! FAB to use with input file
        input_nam	: REF BLOCK [, BYTE],		! NAM to use with input file
        input_xaball	: REF BLOCK [, BYTE];		! XABALL to use with input file



    ! Return if a wildcard file specification is currently being processed or the 
    ! last input file name has been retrieved from the command line.  Otherwise,
    ! set the flag which indicates that more input files have been found.
    !

    IF .wildcard_active					! If a wildcard specification is currently
    THEN						! being processed, then just return to caller.
        RETURN ok;

    !
    ! Reinitialize the RSL and ESL fields of the NAM block so that a parsing
    ! error does not report an error in the previous file processed.
    !

    input_nam [nam$b_esl] = 0;				! Expanded string length of zero.
    input_nam [nam$b_rsl] = 0;				! Resultant string length of zero.


    !
    ! Call LIB$FIND_FILE to parse the input file specification. This resolves 
    ! logical names and determines if there are wildcards present, or explicit 
    ! named fields present.
    !

    IF NOT (rtn_status = copy$find_input_file ( infile_cli_desc ))
    THEN
    	IF .rtn_status NEQ RMS$_NMF
    	THEN
            RETURN .rtn_status;

    !
    ! Initialize the input file FAB.
    !

    $FAB_INIT (						! Setup the input file FAB as follows:
                FAB = .input_fab,			!    FAB address is the input parameter
                FAC = <GET,BRO>,				!    Input file, mixed block and record access
                SHR = GET,				!    Allow others to read the input file
                DNA = 0,				!    No default file specification
                RTV = 0,				!    Use default retrieval window size
                RAT = CR,				!    Carriage control in case unit record input
                FOP = <SQO,NAM>,			!    Sequential I/O only, open by name block
                NAM = .input_nam,			!    NAM block address
                XAB = .input_xaball);			!    XABALL block address.

!
! If there were no more files for the current inout specification, get the next
! one from the command line.
!
    IF .rtn_status EQL RMS$_NMF
    THEN
    	BEGIN

    	IF NOT (rtn_status = CLI$GET_VALUE( $DESCRIPTOR('infile'), infile_cli_desc))
    	THEN
    	    RETURN no_more_files;

	! Get the qualifiers for this input file.
	!
    	COPY$GET_LOCAL_QUAL();
	
	! Check to see if more than one input file has been given.
	!
    	IF .rtn_status NEQ SS$_NORMAL
    	THEN
    	    multiple_input = TRUE;

	!
	! Reinitialize the RSL and ESL fields of the NAM block so that a parsing
	! error does not report an error in the previous file processed.
	!

	input_nam [nam$b_esl] = 0;				! Expanded string length of zero.
	input_nam [nam$b_rsl] = 0;				! Resultant string length of zero.


	!
	! Call LIB$FIND_FILE to parse the input file specification. This resolves 
	! logical names and determines if there are wildcards present, or explicit 
	! named fields present.
	!

	IF NOT (rtn_status = copy$find_input_file ( infile_cli_desc ))
	THEN
	    RETURN .rtn_status;
    	END;

!
! Now test the type of expanded name string that we have. Does it contain wildcards? Were
! certain fields explicitly named?
!

    IF .input_nam [nam$v_wildcard]			! If there were any wildcards,
    THEN
        BEGIN
        wildcard_active = TRUE;				!    set WILDCARD_ACTIVE. This says current file
							!    specification contains wildcards.
        wild_input = TRUE;				!    Also set WILD_INPUT. This says that the current
							!    input list contains wildcard specs somewhere.
    	first_wild_infile = TRUE;			! Indicate this is the first wild input file
        END
    ELSE						! If no input wildcards in this spec, turn off
        wildcard_active = FALSE;			!    the WILDCARD_ACTIVE flag.

    IF .input_nam [nam$v_wild_ver]			! If an explicit wildcard version number
    THEN						!    was specified,
        wild_inp_ver = TRUE				!    set the WILD_INP_VER flag.
    ELSE						! Otherwise,
        BEGIN
        IF .input_nam [nam$v_exp_ver]			!    see if an explicit version number was specified.
        THEN						!    If it is, set the EXP_INP_VER flag, meaning
            exp_inp_ver = TRUE;				!    that there is an explicit input version number.
        END;

!
! Return with success.
!

    RETURN ok;
    END;

GLOBAL ROUTINE copy$opn_infile (input_fab) =		! Open the current input file

!++
! Functional description:
!
!	This routine opens the current input file. If the input file
!	specification contains a wildcard field, an RMS $SEARCH for the
!	next wildcard match occurs before the actual file open.
!
!	Any input parameter qualifiers are applied to the file's RMS blocks before
!	the open is performed. For now, the only valid qualifier is /READ_CHECK.
!
!	If the OPEN fails, an error is reported to SYS$ERROR. When input wildcards are present,
!	two types of failure are permitted:
!
!		RMS$_NMF	- no more files match given wildcard
!		open failure	- allowed when a file matching a wildcard spec cannot be
!				  opened, as long as that file would have been copied without concatenation.
!
! Calling sequence:
!
!	copy$opn_infile (input_fab.ra.v)
!
! Input parameters:
!
!	input_fab	- the FAB associated with the input file
!
! Implicit inputs:
!
!	COPY$CLI_STATUS bits are checked:
!
!		iread_check_bit	- This bit is set if the /READ_CHECK qualifier was specified for this file.
!		wildcard_active	- This specification contains wildcards.
!				  Find the next file with a $SEARCH function call.
!
!	input file NAM block is read to obtain the length of the resultant name string
!	input file XABFHC to check the HSZ for VFC files.
!
!	COPY$SEM_STATUS bits are checked:
!
!		multiple_output	- Multiple files are being produced. This is checked to allow for
!				  open failure on a wildcard specified file.
!
! Output parameters:
!
!	none
!
! Implicit outputs:
!
!	in_name_desc	- the length field of the input name descriptor is written from the RSL
!			  field in the NAM block
!
!	The FAB$V_RCK bit in the input FAB is set if /READ_CHECK was specified.
!
!	COPY$CLI_STATUS bit settings may be altered:
!
!		wildcard_active	- turned off if no more files that match wildcard are found.
!		infile_open	- set if the file is opened successfully
!
! Routine value:
!
!	OK		- input file open
!	NO_MORE_FILES	- no further wildcard match found
!	NO_WILD_OPEN	- open failure on wildcard match file
!	NO_FILE		- input file not found
!
! Side effects:
!
!	The input file is opened.
!	If an RMS SEARCH function fails, then an error is reported on SYS$ERROR.
!
!--

    BEGIN

    MAP
        input_fab	: REF BLOCK [, BYTE];		! input FAB block

    BIND
        input_xaball	=				! input file XABALL block
                .input_fab [fab$l_xab]		: BLOCK [, BYTE],
        input_xabdat	=				! input file XABDAT block
                .input_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabfhc	=				! input file XABFHC block
                .input_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        input_nam	=				! input NAM block address
                        .input_fab [fab$l_nam] : BLOCK [, BYTE];

    LOCAL
        status;						! RMS status code variable

!
! If a wildcard specification is active, call RMS to search for the next wildcard match.
!

    IF .wildcard_active					! If an input wildcard field is present,
    THEN
    	IF NOT .first_wild_infile
	THEN
	    BEGIN
	    status = COPY$FIND_INPUT_FILE( infile_cli_desc );

	    IF .status EQL rms$_nmf			! If no more wildcard matches exist,
	    THEN
		BEGIN
		wildcard_active = FALSE;		!    turn off the WILDCARD_ACTIVE flag,
		RETURN no_more_files;			!    and return with success status of NO_MORE_FILES.
		END;

	    IF NOT .status				! If RMS returned some other error code,
	    THEN
		BEGIN
		copy$inopn_err (.input_fab);		!    then call the RMS error action routine.
		wildcard_active = FALSE;		!    Turn off the wildcard flag so that we don't look
		RETURN no_file;				!    for the file again. Return to caller with NO_FILE
		END;					!    error code.
	    END						! End of special wildcard search processing.
	ELSE
	    first_wild_infile = FALSE;

!
! If the user specified the input read checking qualifier, turn on the appropriate bit in the FAB.
!

    IF qualifier_active( read_chk_qual, loc_read_chk_qual, neg_read_chk_qual)
    THEN
        input_fab [fab$v_rck] = TRUE			!    then turn on the FAB read check indicator.
    ELSE
        input_fab [fab$v_rck] = FALSE;			!    Otherwise, turn it off.

!
! Open the input file.  First, zero the LRL field in the file header XAB.  This
! insures that it will have the appropriate value if the input device is record
! oriented (i.e. SYS$INPUT).
!

    input_xabfhc[ XAB$W_LRL ] = 0;
    IF $RMS_OPEN (					! Open the input file with RMS.
                    FAB = .input_fab,			!    Specify the input parameter for the FAB,
                    ERR = copy$inopn_err)		!    and an error action routine.
    THEN						! If the OPEN is successful,
        BEGIN
        infile_open = TRUE;				!    indicate that the file is open
        in_name_desc [0] = .input_nam [nam$b_rsl];	!    and set the length of the input file name descriptor.

	! If record format is VFC and the HSZ is 0, then set the HSZ to 2.
	! If this isn't done, the incompatible attributes check will 
	! incorrectly fail.
	!
	IF .input_fab [FAB$B_RFM] EQL FAB$C_VFC
		AND
	   .input_xabfhc [XAB$B_HSZ] EQL 0
	THEN
	    input_xabfhc [XAB$B_HSZ] = 2;
        RETURN ok;					! Return to caller with success code.
        END						! End of successful OPEN processing

    ELSE
        BEGIN

!
! If multiple output files are being produced, and this is a file that matches a wildcard specification,
! allow the open to fail. This means that one file that matches the wildcard specification is not copied
! to a new output file.
!

        IF .wildcard_active AND				
            (.multiple_output OR NOT .explicit_concat_qual )
        THEN
            RETURN no_wild_open		
        ELSE
            RETURN no_file;		
        END;

    END;

GLOBAL ROUTINE copy$get_outfil (output_fab, output_nam, output_xabfhc) =
							! Obtain the output file specification

!++
! Functional description:
!
!	This routine obtains the output file specification and all
!	related qualifiers from the Command Language Interpreter. Then
!	the file specification is parsed without any help from related input file name
!	blocks. This initial parse determines whether the file specification had null file
!	name, type, and version number fields.
!
!	If no output file name, type, or version number is given, a flag
!	is set in COPY$SEM_STATUS.
!
! Calling sequence:
!
!	copy$get_outfil (output_fab.ra.v, output_nam.ra.v, output_xabfhc.ra.v)
!
! Input parameters:
!
!	output_fab	- the FAB to use for this output specification
!	output_nam	- the NAM to use for this output specification
!	output_xabfhc	- the XABFHC to use for this output specification
!
! Implicit inputs:
!
!	The RLF field of the output NAM block contains the address of the input file NAM block.
!
! Output parameters:
!
!	none
!
! Implicit outputs:
!
!	The fields of the FAB and the NAM block are filled in according
!	to the CLI call, FAB initialization, and the $PARSE function call.
!
!	A bit may be set in COPY$SEM_STATUS:
!
!		no_output_spec	- no output name, type, or version number specified.
!
! Routine value:
!
!	OK		- success
!	NO_FILE		- the $PARSE function call returned an error code
!
! Side effects:
!
!	An error is reported if the $PARSE function returns an error status code and
!	COPY$OUTOPN_ERR is called.
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! FAB to use with output file
        output_nam	: REF BLOCK [, BYTE],		! NAM to use with output file
        output_xabfhc	: REF BLOCK [, BYTE];		! XABFHC to use with output file

    LOCAL
    	cli_desc : $BBLOCK[ DSC$C_S_BLN ],		! Descriptor for qualifier values
        temp_rlf;					! Holds the output RLF field



    ! Initialize descriptor.  Retrieve the output file specification.
    !
    CH$FILL( 0, DSC$C_S_BLN, cli_desc );
    cli_desc[ DSC$B_CLASS ] = DSC$K_CLASS_D;

    CLI$GET_VALUE( $DESCRIPTOR('OUTFILE'), cli_desc);

    ! Save the file name in the output name descriptor; in case the name 
    ! doesn't parse.  The name given on the command line will be used 
    ! in the error message returned to the user.
    !
    out_name_desc[0] = .cli_desc[DSC$W_LENGTH];
    CH$MOVE(.cli_desc[DSC$W_LENGTH], .cli_desc[DSC$A_POINTER], .out_name_desc[1]);

    ! Get the qualifiers for the output file.
    !
    COPY$GET_GLOBAL_QUAL();

!
! Initialize the output file FAB.
!

    $FAB_INIT (						! Setup the output file FAB as follows:
                FAB = .output_fab,			!    FAB address is the output parameter
                FAC = <PUT,TRN>,			!    Output file
                SHR = NIL,				!    No file sharing
                FNA = .cli_desc [DSC$A_POINTER],	!    File name address from CLI
                FNS = .cli_desc [DSC$W_LENGTH], 	!    File name size from CLI also
                RTV = 0,				!    Use the system default retrieval window size
                FOP = <SQO,OFP,NAM>,			!    Sequential operations only, output file parse,
                NAM = .output_nam,			!    NAM block address
                XAB = .output_xabfhc);			!    XABFHC block address
							!        name block open

!
! Zero the expanded string length so that the COPY error routine, copy$outopn_err, can
! decide if an expanded name string was created by RMS.
!

    output_nam [nam$b_esl] = 0;				! Zero the output expanded string length.

!
! Temporarily remove the RLF field of the output NAM block so that the
! output file specification can be tested for null name, type, and
! version number fields.
!

    temp_rlf = .output_nam [nam$l_rlf];			! Save the RLF field because it may be needed later.
    output_nam [nam$l_rlf] = 0;				! Set the RLF field to null.

!
! Parse the output file specification.
!

    IF NOT $RMS_PARSE (					! Call the RMS function that parses file specifications,
                        FAB = .output_fab,		!    specifying the output FAB parameter,
                        ERR = copy$outopn_err)		!    and an error routine.
    THEN						! If the PARSE is not successful,
        RETURN no_file;					!    then return an error code to the caller.

!
! Test for an absence of the file name, type, and version number fields
! (or the presence of a network quoted string).
!

    IF (NOT .output_nam [nam$v_wild_name]) AND		! If no output wildcards are present,
        (NOT .output_nam [nam$v_wild_type]) AND	
        (NOT .output_nam [nam$v_wild_ver]) AND	
	(NOT .output_nam [nam$v_quoted]) AND		!    and no quoted string
        (NOT .output_nam [nam$v_exp_name]) AND		!    and no output name,
        (NOT .output_nam [nam$v_exp_type]) AND		!    and no output type,
        (NOT .output_nam [nam$v_exp_ver]) AND		!    and no output version number,
        (.output_nam [nam$v_exp_dir] OR			!    and an explicit directory
        .output_nam [nam$v_exp_dev] OR			!    or device name
	.output_nam [nam$v_node])			!    or node name is given,
    THEN
        no_output_spec = TRUE;				!    then set NO_OUTPUT_SPEC bit.


    ! If the file name, file type or version fields are ALL either wild or no specified and
    ! the output file spec does not contain a quoted string, then set the flag which indicates
    ! that the output file spec was completely wild. 
    !
    IF  (.output_nam [nam$v_wild_name] OR NOT .output_nam [nam$v_exp_name])
	    AND
        (.output_nam [nam$v_wild_type] OR NOT .output_nam [nam$v_exp_type])
	    AND
        (.output_nam [nam$v_exp_ver] OR NOT .output_nam [nam$v_wild_ver])
	    AND
	NOT .output_nam [nam$v_quoted]
    THEN
    	no_expl_out_fields = TRUE;
!
! Reload the RLF field. Another PARSE will be performed later in the routine
! COPY$OPN_OUTFIL and may take fields from the input resultant file string.
!

    output_nam [nam$l_rlf] = .temp_rlf;

!
! Return with a success code.
!

    RETURN ok;						! Return successfully.

    END;

GLOBAL ROUTINE copy$opn_outfil (output_fab, output_rab, input_fab, out_file_count) =
							! Opens the current output file

!++
! Functional description:
!
!	This routine opens the current output file. If it is already open due
!	to input file concatenation, the output file RAB is simply disconnected from
!	the FAB to permit switching from block mode I/O to record mode I/O.
!
!	Many of the fields in the input FAB and XAB blocks are copied into the corresponding
!	output FAB and XAB blocks. Also, bits and values are set in the output XAB and FAB blocks
!	because of output file qualifiers specified on the command.
!
!	If the output file already exists, and is being overwritten, it is opened
!	for output. If the output file does not exist, it is allocated and then opened.
!
! Calling sequence:
!
!	copy$opn_outfil (output_fab.ra.v, output_rab.ra.v, input_fab.ra.v, out_file_count.wl.r)
!
! Input parameters:
!
!	output_fab	- the address of the FAB associated with the output file
!	output_rab	- the address of the RAB to be used with the output file
!	input_fab	- the address of the FAB associated with the input file
!
! Implicit inputs:
!
!	copy$cli_status	- the OUTFILE_OPEN bit indicates whether an output file is already open.
!			- bits indicate the settings of the output file qualifiers
!
!	Fields from the input NAM and XAB block are used in the output NAM and XAB blocks.
!
! Output parameters:
!
!	out_file_count	- a counter that is incremented if a new file is opened.
!
! Implicit outputs:
!
!	copy$cli_status	- OUTFILE_OPEN is set once the file is opened.
!			- EXTEND_OUTFILE is set if the output file is being extended.
!
!	Fields are written in the output_fab and its associated NAM and XAB blocks.
!
!	out_name_desc	- a descriptor for the output file. Its length field is written.
!
!	When the output file name is parsed, various bits are set in
!	COPY$SEM_STATUS. These include:
!
!		wild_output	- output spec includes explicit wildcards
!		wild_out_ver	- explicit wildcard version number
!
! Routine value
!
!	OK		- output file successfully created or readied for more output
!	NO_FILE		- output file could not be opened, created, or readied for output
!
! Side effects:
!
!	The routine SETUP_EXTEND is called if the output file is open. The value of this call
!		is returned to the caller.
!	The routine SETUP_OUTXAB is called to write most of the output XAB block fields.
!	Messages are output if a file was created during an APPEND command, if versions were
!		slipped under higher existing versions, or if files were replaced or overlaid.
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! FAB to use with output file
        output_rab	: REF BLOCK [, BYTE],		! RAB to use with output file
        input_fab	: REF BLOCK [, BYTE],		! FAB of the current input file
        out_file_count	: REF VECTOR;			! pointer to number of output files written

    BIND
        output_nam	=				! output NAM block address
                .output_fab [fab$l_nam] 	: BLOCK [, BYTE],
        output_xabfhc	=				! output XAB file header characteristics block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! output XAB date block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabdat	=				! output XAB date block
                .output_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabrdt	=				! output XAB date block
                .output_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabpro	=				! output XAB date block
                .output_xabrdt [xab$l_nxt]	: BLOCK [, BYTE];

    LOCAL
        status;						! Status variable for calling semantic routine.

!
! If the output file is already open (due to input file concatenation), call a routine,
! SETUP_EXTEND, to prepare the file to contain more data.
!

    IF .outfile_open					! If the output file is already open,
    THEN
        RETURN setup_extend (				!    call a routine to set the file up
                             .output_rab);		!    to be extended.

!
! Copy a set of FAB attributes from the input to the output FAB.
!

    output_fab [fab$b_org] = .input_fab [fab$b_org];	! The fields copied are file organization,
    output_fab [fab$b_rat] = .input_fab [fab$b_rat];	!    record attributes
    output_fab [fab$w_mrs] = .input_fab [fab$w_mrs];	!    maximum record size
    output_fab [fab$l_mrn] = .input_fab [fab$l_mrn];	!    maximum record number
    output_fab [fab$b_rfm] = .input_fab [fab$b_rfm];	!    record format
    output_fab [fab$b_fsz] = .input_fab [fab$b_fsz];	!    fixed control area size
    output_fab [fab$b_bks] = .input_fab [fab$b_bks];	!    bucket size
    output_fab [fab$w_gbc] = .input_fab [fab$w_gbc];	!    global buffer count

!
! If the input file has read or write checking options, copy them to the output file.
!

    output_fab [fab$l_fop] = .output_fab [fab$l_fop] OR	! OR together the current FOP output field
        (.input_fab [fab$l_fop] AND (fab$m_rck OR fab$m_wck));
							!    and the read and write check bits of the
							!    FOP input field.

!
! Decide on block or record I/O.
!

    IF .input_fab [fab$b_org] EQL fab$c_seq		! If the input file is a sequential file,
    THEN
        output_fab [fab$v_bro] = TRUE			!    then indicate mixed block and record I/O.
    ELSE
	BEGIN
        output_fab [fab$v_bio] = true;			! Otherwise, indicate only block I/O.
	output_fab [fab$v_bro] = false;			! and turn off block/record I/O
	END;

!
! Copy input blocksize for tapes. Otherwise let RMS set the output blocksize.
!

    IF .input_fab [$FAB_DEV (sqd)]			! If input device is a tape,
    THEN
        output_fab [fab$w_bls] = .input_fab [fab$w_bls]	!    then copy the blocksize to the output FAB.
    ELSE
        output_fab [fab$w_bls] = 0;			! Otherwise, let RMS choose blocksize.

!
! Test the expanded name string for the output file. Does it contain wildcards? If so,
! is there an explicit wildcard version number?
!

    IF .output_nam [nam$v_wildcard]			! If there were any wildcards,
    THEN
        wild_output = TRUE;				!    set flag saying that the file specification
							!    contained some wildcard fields.

    IF .output_nam [nam$v_wild_ver]			! If the version number is a wildcard,
    THEN
       wild_out_ver = TRUE				!    output version number, remember it.
    ELSE
        IF .output_nam [nam$v_exp_ver]			! Otherwise, see if an explicit version number was specified.
        THEN
            exp_out_ver = TRUE;				!    If so, set the EXP_OUT_VER flag.

!
! Reparse the output string with a wildcard version number, if this is not
! an APPEND operation and one of the following cases is true:
!	- no output file name, type or version number was given 
!	  (e.g. COPY x.x [dir])
!	- wild or explicit version numbers were given for the input file, but
!	  the version field for the output file was not specified
!	  (e.g. COPY x.x;* a.a)
!	- the output spec is wild (e.g. COPY x.x *, or COPY x.x *.*)

    IF NOT .append_command
		AND
    	(.no_output_spec
		OR
	((.wild_inp_ver OR .exp_inp_ver) 
	AND NOT .output_nam [nam$v_wild_ver] 
	AND NOT .output_nam [nam$v_exp_ver])
        	OR
        (NOT .output_nam [nam$v_exp_ver] 
	AND (.output_nam [nam$v_wild_type] OR NOT .output_nam [nam$v_exp_type]) 
	AND .output_nam [nam$v_wild_name]))
    THEN
        BEGIN						! Then provide a default name string
        output_fab [fab$l_dna] = UPLIT (';*');		!    of an explicit output wildcard
        output_fab [fab$b_dns] = 2;			!    version number,
        END;


    ! Now $PARSE (this may be a reparse) the output file specification.
    !
    IF NOT $RMS_PARSE ( FAB = .output_fab, ERR = copy$outopn_err)
    THEN
            RETURN no_file;				! On failure, return with an error code.


    !
    ! No director wildcards allowed to remain at this time
    !
    BEGIN
    BIND
	lastchar = .output_nam[nam$l_dir] + .output_nam[nam$b_dir] - 2 : byte;
    IF .lastchar EQL %C'*'  OR
	.lastchar EQl %C'.'
    THEN
	BEGIN
	LOCAL
	   outputstr : vector[2];
	outputstr[0] = .output_nam [nam$b_esl];
	outputstr[1] = .output_nam [nam$l_esa];
	PUT_MESSAGE( MSG$_SYNTAX,
		    1,
		    outputstr,
		    0 );
	RETURN no_file;
	END;	
    END;

    !
    ! See if the output file fits the criteria given on the command line.
    !
    IF NOT (status = copy$check_file_for_match())
    THEN
    	RETURN .status;

!
! Call the routine SETUP_OUTXAB to copy output XAB fields from the corresponding input XAB fields.
!

    setup_outxab (					! Write output XAB fields by calling
                    .output_fab,			!    a routine that selects the necessary fields from
                    .input_fab);			!    the input FAB and writes them into the output FAB.

!
! Call the routine APPLY_OUT_QUAL to write RMS fields according to output parameter qualifiers.
!

    apply_out_qual (					! Process output file qualifiers
                    .output_fab);

!
! Call the routine COPY$SEMANTICS to determine the semantic effects of
! this particular combination of input and output file specifications and qualifiers.
!

    IF NOT copy$semantics (				! Decide what semantic behavior is required.
                                copy$sem_status,	!    Pass the status variable copy$sem_status,
                                .input_fab,		!    the input FAB block address,
                                .output_fab)		!    and the output FAB block address.
    THEN						! If the input/output spec combination makes no sense,
        RETURN no_file;					!    then return with error status code.

!
! Perform special XAB setup if a concatenated file is being created.
!

    IF (.append_command	 				! If appending to existing file,
	OR .concat_follows				!    or concatenating
    	OR NOT .no_expl_out_fields			!    or if explicit field in output spec 
        OR NOT .input_fab [$fab_dev (fod)])		!    or the input device is not file structured,
    THEN
        output_xaball [xab$l_nxt] = .output_xabrdt [xab$l_nxt] ! Do not provide any date information
    ELSE
    	BEGIN
    	output_xaball [xab$l_nxt] = output_xabdat;	! Otherwise, include the output date/time XAB block
    	output_xabdat [xab$l_nxt] = output_xabrdt;	!     and the revision date/time XAB block;
    	END;    	

!
! Create (or simply open) the output file.
!

    extend_outfile = FALSE;				! Assume that the output file is not being extended.

!
! If a file needn't be created, just open an existing file.
!

    IF .append_command AND				! If this is an APPEND command and
        NOT .new_version_qual   			!    and output file creation was not requested,
    THEN
    	BEGIN
            IF NOT (status = $RMS_OPEN ( FAB = .output_fab, ERR = copy$outopn_err))
    	    THEN RETURN .status;
    	END
    ELSE
        BEGIN
        status = $RMS_CREATE (FAB = .output_fab);	! Else, create (or open if it exists) file

!
! If the file could not be created as a contiguous file because the disk was too full,
! then try to create it contiguous best try.
!

        IF .status EQL rms$_ful
            AND .output_xaball [xab$v_ctg]
            AND NOT qualifier_active( contig_qual, loc_contig_qual, neg_contig_qual )
        THEN
            BEGIN
            output_xaball [xab$v_ctg] = FALSE;		!    then turn off the contiguous indicator,
            output_xaball [xab$v_cbt] = TRUE;		!    turn on the contiguous best try indicator,
            status = $RMS_CREATE (			!    and retry the create.
                                    FAB = .output_fab,	! Specify the address of the FAB block
                                    ERR = copy$outopn_err);
	    IF .status					! If contig-best-try ok,
	    THEN
		put_message (msg$_cbt);			! then issue message
            END						!    and an error action routine.
	ELSE
	IF NOT .status					! Else, if error,
	THEN
	    copy$outopn_err (.output_fab);		! issue error message

!
! Change the RMS return status to "created" if indeed the file was created.
!

        IF NOT .output_fab [fab$v_cif] AND		! Since RMS returns RMS$_NORMAL whether or not the
            .status EQL rms$_normal			!    file was created, for internal reporting, change
        THEN						!    the status code to RMS$_CREATED if appropriate.
            status = rms$_created;			!    (I.e., if the file was created.)

! If the file was indeed created, issue a $DISPLAY to obtain information
! about the newly created file.

        IF NOT .status					! If the open or create failed,
        THEN
            RETURN no_file;				!    then return an error status code.

	IF NOT $RMS_DISPLAY (FAB = .output_fab)
	THEN
	    copy$outopn_err (.output_fab);
!
! If the output file was copied to a 10,20 or RT node and it was forced to a
! stream format file, then (if the /LOG qualifier was specified) warn the user
! of the conversion.
!
	IF .status EQL rms$_cre_stm AND .LOG_MSG_QUAL
	THEN
	   BEGIN			
	   out_name_desc [0] = .output_nam [nam$b_rsl];	! Store the length of the filespec
	   put_message (msg$_createdstm,1,		! Issue the message
			out_name_desc);
	   status = rms$_created;			! Change the status as above
	   END;
        END;

    outfile_open = TRUE;				! Otherwise, set a flag saying that an output file is open,
    out_name_desc [0] = .output_nam [nam$b_rsl];	!    and store the length of the file specification.

!
! Clean up the output open procedure by reporting to the user if necessary and
! updating more fields.
!

    SELECTONE .status OF				! Select additional processing based on the

        SET						!    RMS completion code from the OPEN or CREATE.

        [rms$_created]:					! Output file was created.
            BEGIN
            out_file_count [0] =			!    Update count of files created.
                .out_file_count [0] + 1;

            IF .append_command				!    If this is an APPEND command,
            THEN
                copy$log_msg (				!    send the following message to the user:
                                msg$_created);		!        "<file-name> created" because creation is unusual.

            IF .output_nam [nam$v_highver] AND		!    If a higher version of this file exists,
                NOT .quiet_slip				!    and warnings about versions are not suppressed,
            THEN
                put_message (				!    send the following message to the user:
                                msg$_highver, 1,	!        "higher version of <file-name> exists"
                                out_name_desc);		!    because this may cause version confusion.

            END;


        [rms$_supersede]:				! Output file caused deletion of file of same name.
            BEGIN
            out_file_count [0] =			!    Update count of files created.
                .out_file_count [0] + 1;

            copy$log_msg (				!    Send the following message to the user:
                            msg$_replaced);		!        "<file-name> replaced" because
							!        supersession is unusual.

            END;


        [rms$_normal]:					! Output file existed previously and was opened.
            BEGIN
            IF .append_command				!    If this is an APPEND command,
            THEN
                BEGIN
                extend_outfile = TRUE;			!    set a flag saying that the file is being extended.

                output_xaball [xab$l_alq] =		!    Calculate the necessary extension quantity
                    copy$calc_alq ();			!    with a call to COPY$CALC_ALQ.

                IF .output_xaball [xab$l_alq] NEQ 0	!    If the extension quantity is not null,
                THEN
                    IF NOT $RMS_EXTEND (		!    then try to extend the file.
                                        FAB = .output_fab,
                                        ERR = copy$outopn_err)
                    THEN				!    If the extend fails,
                        RETURN no_file;			!    then return an error status code.

                END

            ELSE					!    If this is a COPY command,
                BEGIN
                copy$log_msg (				!    send the following message to the user:
                                msg$_overlay);		!        "<file-name> being overwritten"

! ******
!	Omitted here is the revision of the output file's attributes. Ward had this
!	commented out.
! ******

                END;

            END;

        TES;						! End of SELECT expression.

!
! Return to the caller with a success status code.
!

    RETURN ok;						! Return with a success code.
    END;

ROUTINE setup_extend (output_rab) =			! Setup a file to be extended.

!++
! Functional description:
!
!	This routine takes an open file and prepares it to be extended.
!
!	First, a DISCONNECT is performed. This permits switching from block mode I/O
!	to record mode I/O, if desired. Then update the output file allocation information,
!	set a bit in COPY$CLI_STATUS saying that the file is being extended, calculate
!	the file extension quantity, and extend the file.
!
! Calling sequence:
!
!	setup_extend (output_rab.ra.v)
!
! Input parameters
!
!	output_rab	- the RAB connected to the output FAB
!
! Implicit inputs
!
!	The FAB and XAB blocks associated with the specified output RAB block.
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The allocation information in the FAB is updated.
!	The EXTEND_OUTFILE bit in COPY$CLI_STATUS is set.
!	The ALQ field in the output XAB block is set to an appropriate extension quantity.
!
! Routine value
!
!	OK		- success
!	NO_FILE		- failure
!
! Side effects
!
!	If the file cannot be extended, the file is closed.
!
!--

    BEGIN

    MAP
        output_rab	: REF BLOCK [, BYTE];		! output FAB of the open output file

    BIND
        output_fab	=				! associated output FAB block
                .output_rab [rab$l_fab]		: BLOCK [, BYTE],
        output_xabfhc	=				! associated output XAB block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				!    second XAB in XAB chain
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

    LOCAL
        status;						! Holds RMS status values


    ! See if the input file fits the criteria given on the command line.
    !
    IF NOT (status = copy$check_file_for_match())
    THEN
    	RETURN .status;


    ! Disconnect the RAB from the FAB. On error, close the file and return 
    ! with error status code.
    !
    IF NOT $RMS_DISCONNECT (				! Disconnect the output file RAB from its FAB.
                            RAB = .output_rab,		!    Specify the RAB block address
                            ERR = copy$oclose_err)	!    and an error routine.
    THEN
        BEGIN						! If the DISCONNECT fails,
        copy$close_outf (				!    close the output file,
                            output_fab);
        RETURN no_file;					!    and return with an error code.
        END;

!
! Shortening the XAB chain to include only the FHC (file header characteristics) XAB,
! call the RMS function $DISPLAY to update the output file allocation information
! as recorded in the XABFHC.
!

    output_xabfhc [xab$l_nxt] = 0;			! Leave only the FHC XAB on the XAB chain.

    status = $RMS_DISPLAY (				! Call DISPLAY to update the XAB information
                            FAB = output_fab,		!    about the file's allocation.
                            ERR = copy$outopn_err);	!    Specify an error action routine.

    output_xabfhc [xab$l_nxt] = output_xaball;		! Restore the XAB chain.

!
! See if the $DISPLAY function succeeded. If not, close the output file and return
! an error status code.
!

    IF NOT .status					! If the $DISPLAY function failed,
    THEN
        BEGIN
        copy$close_outf (				!    then close the output file,
                            output_fab);
        RETURN no_file;					!    and return an error status code.
        END;

!
! Set the bit in COPY$CLI_STATUS that indicates that the file is to be extended.
!

    extend_outfile = TRUE;				! Set EXTEND_OUTFILE bit.

!
! Calculate the file extension quantity and extend the file with an RMS $EXTEND function call.
! The routine COPY$CALC_ALQ does the calculation. It returns a "zero" in the following cases:
!
!	The output file is on a magtape or a nonfile-structured device.
!	The output file is already long enough to hold the size of the file to be appended.
!

    output_xaball [xab$l_alq] = copy$calc_alq ();	! Setup the output file extension quantity in the XAB.

    IF .output_xaball [xab$l_alq] EQL 0			! If the input file is of zero length,
    THEN
        RETURN ok;					!    then return with success code.

    IF $RMS_EXTEND (					! If the output file can be extended successfully,
                    FAB = output_fab,
                    ERR = copy$outopn_err)		!    (specify an error routine)
    THEN
        RETURN ok					!    then return with success code.
    ELSE
        RETURN no_file;					! Otherwise, return with error code.

    END;

ROUTINE setup_outxab (output_fab, input_fab) : NOVALUE =
							! Setup output XAB fields from input XAB fields

!++
! Functional description:
!
!	This routine copies input XAB fields into corresponding output XAB fields.
!
! Calling sequence:
!
!	setup_outxab (output_fab.ra.v, input_fab.ra.v)
!
! Input parameters:
!
!	output_fab	- FAB block associated with the output file
!	input_fab	- FAB block associated with the input file
!
! Implicit inputs:
!
!	output_xaball	- XABALL block for output file
!	output_xabdat	- XABDAT block for output file
!	output_xabfhc	- XABFHC block for output file
!	output_xabpro	- XABPRO block for output file
!	output_xabrdt	- XABRDT block for output file
!
!	input_xaball	- XABALL block for input file
!	input_xabdat	- XABDAT block for input file
!	input_xabfhc	- XABFHC block for input file
!	input_xabpro	- XABPRO block for input file
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The relevant fields in the output XABs are written.
!
! Routine value
!
!	none
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! output file FAB block
        input_fab	: REF BLOCK [, BYTE];		! input file FAB block

    BIND
        output_nam	=				! output NAM block address
                .output_fab [fab$l_nam] 	: BLOCK [, BYTE],
        output_xabfhc	=				! output XAB file header characteristics block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! output XAB date block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabdat	=				! output XAB date block
                .output_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabrdt	=				! output XAB date block
                .output_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabpro	=				! output XAB date block
                .output_xabrdt [xab$l_nxt]	: BLOCK [, BYTE],

        input_xaball	=				! input file XABALL block
                .input_fab [fab$l_xab]		: BLOCK [, BYTE],
        input_xabdat	=				! input file XABDAT block
                .input_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabfhc	=				! input file XABFHC block
                .input_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabpro	=				! input file XABPRO block
                .input_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

!
! Write the output allocation XAB.
!

    output_xaball [xab$b_aop] =
                        .input_xaball [xab$b_aop];	! Write the allocation options,
    output_xaball [xab$b_aln] =
                        .input_xaball [xab$b_aln];	!    and the alignment type.

    output_xaball [xab$l_alq] = copy$calc_alq ();	! Calculate and write in the allocation quantity.

    output_xaball [xab$w_deq] =
                        .input_xabfhc [xab$w_dxq];	! Write the default extension quantity.
    output_xaball [xab$b_bkz] =				! Write the default bucket size
                        .input_fab [fab$b_bks];		!    from the input FAB bucket size.
    							!    This insures the file is created with
    							!    correct bucksize.  Area 0 not may have 
    							!    the largest bucket size.

    output_xaball [xab$w_vol] = 0;			! Zero the related volume number,
    output_xaball [xab$l_loc] = 0;			!    the allocation location,
    output_xaball [xab$b_aid] = 0;			!    the area id number,
    output_xaball [xab$w_rfi0] = 0;			!    the related file number
    output_xaball [xab$w_rfi2] = 0;			!    the related file sequence number
    output_xaball [xab$w_rfi4] = 0;			!    and the related file revision number.

    IF .input_fab [$fab_dev(net)] AND			! If this is a network operation
       .output_xaball [xab$l_alq] EQL 0			!    and the calculated ALQ = 0,
    THEN output_xaball [xab$l_alq] =			!    then get ALQ from the FHC XAB
			.input_xabfhc [xab$l_hbk];	!

!
! Write the output Date/Time XAB.
!

    output_xabdat [xab$w_rvn] =	 			! Increment the revision number
    			.input_xabdat [xab$w_rvn ] + 1;
    output_xabdat [xab$l_rdt0] = 0;			! Clear the revision date
    output_xabdat [xab$l_rdt4] = 0;
    output_xabdat [xab$l_cdt0] =			! Copy the creation date
                        .input_xabdat [xab$l_cdt0];
    output_xabdat [xab$l_cdt4] =			!    and the creation time
                        .input_xabdat [xab$l_cdt4];
!
! These values are not copied from the input, but defaulted instead,
! so the user will get new backup and expiration dates.
!

    ! If the output device is tape, then propogate the expiration date.  
    ! Otherwise, clear it.

    IF .output_fab[ $FAB_DEV(sqd) ] 
    THEN
    	BEGIN
        output_xabdat [xab$l_edt0] = .input_xabdat [xab$l_edt0];
        output_xabdat [xab$l_edt4] = .input_xabdat [xab$l_edt4];
        END
    ELSE
    	BEGIN
        output_xabdat [xab$l_edt0] = 0;
        output_xabdat [xab$l_edt4] = 0;
        END;

    output_xabdat [xab$l_bdt0] = 0;			!    the backup date
    output_xabdat [xab$l_bdt4] = 0;			!    and the backup time

!
! Write the output File Header Characteristics XAB block.
!

    output_xabfhc [xab$b_rfo] =				! The XABFHC includes the
                        .input_xabfhc [xab$b_rfo];	!    record format and file organization,
    output_xabfhc [xab$b_atr] =				!    the record attributes,
                        .input_xabfhc [xab$b_atr];
    output_xabfhc [xab$w_lrl] =				!    the length of the longest record,
                        .input_xabfhc [xab$w_lrl];
    output_xabfhc [xab$b_bkz] =				!    the bucket size,
                        .input_xabfhc [xab$b_bkz];
    output_xabfhc [xab$b_hsz] =				!    the VFC header size,
                        .input_xabfhc [xab$b_hsz];
    output_xabfhc [xab$w_mrz] =				!    the maximum record length,
                        .input_xabfhc [xab$w_mrz];
    output_xabfhc [xab$w_dxq] =				!    and the default extension quantity.
                        .input_xabfhc [xab$w_dxq];

    output_xabfhc [xab$l_sbn] = 0;			! Zero the starting virtual block number.

!
! Write the output Protection XAB block. Most of this XAB can only be setup
! after the output file has been opened or created. Therefore, it is not done here.
!

    output_xabpro [xab$l_uic] = 0;			! Clear the file owner field.

!
! Write the output Revision Date/Time XAB block.
!

    output_xabrdt [xab$w_rvn] =				! Increment revision number
    			.input_xabdat [xab$w_rvn ] + 1;
    output_xabrdt [xab$l_rdt0] = 0;			! Do not propogate the the input revision date,
    output_xabrdt [xab$l_rdt4] = 0;

! ******
!	Temporarily, I omit the special saving of XABDAT and XABFHC fields
!	of a file that may be overwritten. This must go back in.
! ******

    END;

ROUTINE apply_out_qual (output_fab) : NOVALUE =		! Applies output parameter qualifiers to FAB and XAB

!++
! Functional description
!
!	This routine looks for the presence of qualifiers on the output file specification,
!	and sets RMS fields according to the semantics of each qualifier.
!
! Calling sequence:
!
!	apply_out_qual (output_fab.ra.v)
!
! Input parameters:
!
!	output_fab	- the FAB block related to the output file specification
!
! Implicit inputs:
!
!	output_xaball	- The XABALL block associated with the output FAB
!
!	The following bits in COPY$CLI_STATUS:
!
!		alignment_bit
!		allocation_bit
!		contiguous_bit
!		extension_bit
!		file_max_bit
!		overlay_bit
!		oread_check_bit
!		replace_bit
!		truncate_bit
!		write_check_bit
!		volume_bit
!
!	Some values associated with qualifiers specified for the output file specification:
!
!		align_type
!		align_option
!		align_location
!		alloc_value
!		extension_value
!		file_max_value
!		volume_value
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	Some fields in the output XABALL block are written:
!
!		ALN	- alignment type
!		AOP	- alignment option
!		LOC	- alignment location
!		ALQ	- allocation quantity
!		CTG	- contiguous file
!		CBT	- contiguous best try file
!		DEQ	- file extension quantity
!		VOL	- relative volume number
!
!	Some fields in the output FAB are written:
!
!		MRN	- maximum record number
!		CIF	- create if nonexistent file
!		RCK	- read check
!		TEF	- truncate files at EOF mark
!		SUP	- supersede
!		WCK	- write check
!
! Routine value
!
!	novalue
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE];		! Output file FAB block

    BIND
        output_nam	=				! output NAM block address
                .output_fab [fab$l_nam] 	: BLOCK [, BYTE],
        output_xabfhc	=				! output XAB file header characteristics block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! output XAB date block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabdat	=				! output XAB date block
                .output_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabrdt	=				! output XAB date block
                .output_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabpro	=				! output XAB date block
                .output_xabrdt [xab$l_nxt]	: BLOCK [, BYTE];

!
! Apply the effects of the output file qualifiers to the appropriate XAB blocks.
!

    ! /ALLOCATION = n
    !
    IF qualifier_active( alloc_qual, loc_alloc_qual, neg_alloc_qual )
    THEN
        output_xaball [xab$l_alq] = .curr_allocation_value;

    IF qualifier_active( contig_qual, loc_contig_qual, neg_contig_qual )
    THEN
        BEGIN
        output_xaball [xab$v_ctg] = TRUE;
        output_xaball [xab$v_cbt] = FALSE;
        END
    ELSE				
        BEGIN
        IF .contig_negated OR .neg_contig_qual
        THEN				
            BEGIN
            output_xaball [xab$v_ctg] = FALSE;	
            output_xaball [xab$v_cbt] = FALSE;	
            END;
        END;

    IF qualifier_active( extend_qual, loc_extend_qual, neg_extend_qual )
    THEN
        output_xaball [xab$w_deq] = .curr_extension_value;

    IF qualifier_active( file_max_qual, loc_file_max_qual, neg_file_max_qual )
    THEN
        output_fab [fab$l_mrn] = .curr_file_max_value;

    IF qualifier_active( overlay_qual, loc_overlay_qual, neg_overlay_qual ) OR
        .new_version_qual
    THEN
        output_fab [fab$v_cif] = TRUE;

    IF qualifier_active( replace_qual, loc_replace_qual, neg_replace_qual )
    THEN
        output_fab [fab$v_sup] = TRUE;

    IF qualifier_active( truncate_qual, loc_truncate_qual, neg_truncate_qual )
    THEN
        output_fab [fab$v_tef] = TRUE;	

    IF qualifier_active( volume_qual, loc_volume_qual, neg_volume_qual )
    THEN
	BEGIN
	output_xaball [xab$w_vol] = .curr_volume_value;
	output_xaball [xab$b_aln] = xab$c_lbn;
	output_xaball [xab$v_hrd] = 1;
	END;

    IF qualifier_active( write_chk_qual, loc_write_chk_qual, neg_write_chk_qual )
    THEN
        output_fab [fab$v_wck] = TRUE
    ELSE
        BEGIN
        IF .write_chk_negated
        THEN
            output_fab [fab$v_wck] = FALSE;
        END;

!
! Return to caller.
!

    END;						! Return without a value.

END
ELUDOM
