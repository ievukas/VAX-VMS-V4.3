MODULE COMMAND	(%TITLE	'Command parser'
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!	This module contains the routines that perform command parsing and
!	analysis.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 26-Aug-1980
!
! MODIFIED BY:
!
!	V03-015	LY0520		Larry Yetto		 5-AUG-1984 14:15
!		QAR # 1212 .  Search lists with concealed devices do not
!		work.  In order to fix this perform the SLPARSE parses with
!		the NOCONCEAL flag set in the NAM.  Once this is done
!		we will end up with ".][" etc. strings in the file
!		spec.  BACKUP does not know how to deal with these strings
!		so we will always strip out the ".][" from the file file
!		name string.  This will result in BACKUP not being able to
!		get below 8 level deep directories (ie. concealed name hides 8)
!		but at least some cases will work.
!
!	V03-014	LY0514		Larry Yetto		23-JUL-1984 15:37
!		Correct incremental restores so that they do not use
!		the current default directory to determine the placement
!		of the restored files.
!
!	V03-013	LY0486		Larry Yetto		27-APR-1984 10:55
!		Base Level QAR # 217  -  Fix accvio if no output
!		file spec
!
!	V03-012	LY0471		Larry Yetto		 9-APR-1984 08:21
!		Modify the parsing algorithm for input file lists so
!		that it will work properly with search lists.
!
!	V03-011	LMP0140		L. Mark Pilant,		23-Aug-1983  8:20
!		Add support for alphanumeric UICs.
!
!	V03-010	JEP0003		J. Eric Pollack,	23-Apr-1983  10:53
!		Add support for encrypted savesets.
!
!	V03-009	ACG0313		Andrew C. Goldstein,	12-Feb-1983  16:05
!		Add routine subtitles
!
!	V03-008	ACG0314		Andrew C. Goldstein,	10-Feb-1983  22:28
!		Make /NOREWIND and /NOINITIALIZE default for save sets
!
!	V03-007	ACG0309		Andrew C. Goldstein,	19-Jan-1983  11:19
!		Fix test for interactive to use SYS$COMMAND properly
!		Also change tape block sizes to integral 512 byte units
!
!	V03-006	MLJ0095		Martin L. Jack,	26-Aug-1982  15:41
!		Use CLI$END_PARSE only in standalone version.
!
!	V03-005	MLJ48501	Martin L. Jack,	17-Aug-1982  15:30
!		Correct problem with wildcard version stickiness.
!
!	V03-004	MLJ47951	Martin L. Jack,	27-Jul-1982  11:45
!		Correct problem that caused the length of the /JOURNAL value to
!		be taken as the length of the /LABEL values.
!
!	V03-003	LMP0032		L. Mark Pilant,		21-Jun-1982  11:83
!		Add support for wildcard save set names on the RESTORE and
!		LIST operations.
!
!	V03-002	PCG0001		Peter George	18-Jun-1982  13:30
!		Check new CLI$PRESENT statuses for local qualifiers.
!
!	V03-001	MLJ0084		Martin L. Jack,	27-Mar-1982  17:00
!		Allow a save set to be written to a mailbox (including NL:).
!
!	V02-015	MLJ0081		Martin L. Jack,	26-Feb-1982  14:35
!		Correct setting of COM_INTERACTIVE for standalone and
!		STARTUP.COM environments.
!
!	V02-014	MLJ0073		Martin L. Jack,	19-Jan-1982  18:19
!		Implement /PROTECTION qualifier for save set protection.
!		Extend /LABEL qualifier to accept a list.
!
!	V02-013	MLJ0062		Martin L. Jack,	7-Dec-1981  13:57
!		Implement /INCREMENTAL.  Allow input volume of a /PHYSICAL
!		operation to be mounted foreign or to be mounted Files-11 if
!		the process has LOG_IO privilege.
!
!	V02-012	MLJ0054		Martin L. Jack,	15-Oct-1981  17:08
!		Allow save sets to be network files.  Implement /VOLUME
!		qualifier.  Implement /DELETE qualifier.  Integrate GET_VM
!		and FREE_VM jacket routines.  Delete JPI_STS, add COM_INTERACT
!		flag.
!
!	V02-011	MLJ0052		Martin L. Jack,	1-Oct-1981  13:16
!		Implement /INTERCHANGE qualifier.
!
!	V02-010	MLJ0049		Martin L. Jack,	28-Sep-1981  22:06
!		Correct test for /IMAGE in standalone environment.
!
!	V02-009	MLJ0043		Martin L. Jack,	8-Sep-1981  16:56
!		Account for RMS logical device name change.  Install $GETSYI.
!		Correct /SELECT and /EXCLUDE operation on [000000].
!
!	V02-008	MLJ0036		Martin L. Jack,	29-Aug-1981  16:00
!		Additional error detection.
!
!	V02-007	MLJ0025		Martin L. Jack,	8-May-1981  10:55
!		Reorganize qualifier database.  Remove /SEARCH qualifier.
!		Use PL/I varying strings rather than dynamic strings.
!
!	V02-006	MLJ0022		Martin L. Jack,	21-Apr-1981  13:53
!		Convert directory wildcarding to use RMS.
!
!	V02-005	MLJ0021		Martin L. Jack,	20-Apr-1981  21:50
!		Implement /TRUNCATE qualifier.
!
!	V02-004	MLJ0015		Martin L. Jack,	6-Apr-1981  23:22
!		Explicitly check for SS$_NOTRAN in translation of SYS$NODE.
!		Remove unnecessary code to clear QUAL area.
!
!	V02-003	MLJ0010		Martin L. Jack,	25-Mar-1981  16:20
!		Reorganize global storage.  Rename /OWNER to /OWNER_UIC.
!		Remove unnecessary parts of qualifier database.  Add capability
!		for listing concurrently with another operation.  Add checking
!		for properly mounted volumes.  Replace /SEQUENTIAL by /SAVE_SET
!		specified on a foreign volume.  Reparse to get save set name in
!		all elements of a list.  Changes for standalone operation.
!
!	V02-002	MLJ0008		Martin L. Jack,	10-Mar-1981  11:44
!		Rename /FILE to /SAVE_SET
!
!	V02-001	MLJ0005		Martin L. Jack,	26-Feb-1981  17:08
!		Allow null input save set filename
!
!**

REQUIRE 'SRC$:COMMON';
LIBRARY 'SYS$LIBRARY:LIB';
LIBRARY 'SYS$LIBRARY:TPAMAC';


FORWARD ROUTINE
	CALL_TPARSE,			! Execute call to LIB$TPARSE
	PRESERVE_STRING:NOVALUE,	! preserve string value
	GET_FC,				! Get a file context area
	COPY_FC:	NOVALUE,	! Copy one FC to a new one
	INIT_FC:	NOVALUE,	! Init an existing FC incl related name
	PARSE_EXC_SEL:	NOVALUE,	! Parse /EXCLUDE and /SELECT
	EXPAND_SEARCH_LIST,		! Expand a search list
	CHECK_SAV:	NOVALUE,	! Check save set input/output spec
	CHECK_F11:	NOVALUE,	! Check files-11 input/output spec
	CHECK_COMMON:	NOVALUE,	! Check common input/output spec
	BUILD_QUAL_DESC:NOVALUE, 	! Build qualifier block descriptors
	CHECK:		NOVALUE,	! Check input and output specifications
	COMMAND:	NOVALUE;	! Parse BACKUP command


EXTERNAL ROUTINE
	CLI$END_PARSE:	WEAK ADDRESSING_MODE(GENERAL),
					! Declare end of parsing for STACLINT
	CLI$GET_VALUE:	ADDRESSING_MODE(GENERAL),
					! Get a parameter or qualifier value
	CLI$PRESENT:	ADDRESSING_MODE(GENERAL),
					! Determine if entity is present
	LIB$CVT_DTB:	ADDRESSING_MODE(GENERAL),
					! Convert decimal string to binary
	LIB$CVT_TIME:	ADDRESSING_MODE(GENERAL),
					! Convert absolute time to binary
	LIB$TPARSE:	ADDRESSING_MODE(GENERAL),
					! Table-driven parser
	SYS$SETDFPROT:	ADDRESSING_MODE(GENERAL),
					! Read/set default file protection
	CRYPTO_INIT:	NOVALUE WEAK,	! Initialize for saveset encryption
	FILE_ERROR:	NOVALUE,	! Signal file-related error
	GET_VM,				! Allocate virtual memory
	GET_ZERO_VM,			! Allocate and clear virtual memory
	FREE_VM:	NOVALUE ;	! Deallocate virtual memory


EXTERNAL LITERAL
	BACKUP$_ENCNOTSUP,
    	BACKUP$_ENCQUAIGN,
	BACKUP$_INVQUAVAL,
	BACKUP$_INVDEVTYP,
	BACKUP$_PARSE,
	BACKUP$_INCDEVLIS,
	BACKUP$_ONEF11OUT,
	BACKUP$_CMPOUTF11,
	BACKUP$_SAVSETNAM,
	BACKUP$_ONEIMGDEV,
	BACKUP$_ONEF11DEV,
	BACKUP$_ONEPHYDEV,
	BACKUP$_PHYFILSPE,
	BACKUP$_IMGFILSPE,
	BACKUP$_INCFILSPE,
	BACKUP$_LISINPSAV,
	BACKUP$_MOUNTF11,
	BACKUP$_MOUNTFOR,
	BACKUP$_CONFQUAL,
	CLI$_PRESENT,		! Explicit global /QUAL
	CLI$_NEGATED,		! Explicit global /NOQUAL
	CLI$_ABSENT,		! Implicit global /NOQUAL
	CLI$_LOCPRES,		! Explicit local /QUAL
	CLI$_LOCNEG;		! Explicit local /NOQUAL


G$DEFINE();			! Define global area


FORWARD

	! TPARSE tables, which are defined at the end of this module.
	!
	UIC_STATES:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	UIC_KEYS:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	OWN_STATES:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	OWN_KEYS:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	IGN_STATES:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	IGN_KEYS:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	BAK_STATES:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	BAK_KEYS:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	PRO_STATES:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE),
	PRO_KEYS:	VECTOR[0] ADDRESSING_MODE(LONG_RELATIVE);


BIND

	! TPARSE parse-output variables.  To save space, these are defined
	! to overlay OUTPUT_ATTBUF.
	!
	CONVERTED_UIC=	OUTPUT_ATTBUF,				! Converted UIC
	TPA_FLAGS=	OUTPUT_ATTBUF+8:	BLOCK[1],	! Various flags
	TPA_PROTECTION=	OUTPUT_ATTBUF:		VECTOR[,WORD],	! Protection
	DEVCLASS=	OUTPUT_ATTBUF;				! For $GETDVI


MACRO

	! Definitions of TPA_FLAGS.
	!
	TPA_WGROUP=	0,0,1,0 %,	! Wild group number
	TPA_WMEMBER=	0,1,1,0 %,	! Wild member number
	TPA_DEFAULT=	0,2,1,0 %,	! DEFAULT specified
	TPA_ORIGINAL=	0,3,1,0 %,	! ORIGINAL specified
	TPA_PARENT=	0,4,1,0 %,	! PARENT specified
	TPA_UIC=	0,5,1,0 %,	! UIC specified
	TPA_NOBACKUP=	0,6,1,0 %,	! NOBACKUP specified
	TPA_INTERLOCK=	0,7,1,0 %;	! INTERLOCK specified


LITERAL
	TPA_M_WGROUP=	$FIELDMASK(TPA_WGROUP),
	TPA_M_WMEMBER=	$FIELDMASK(TPA_WMEMBER),
	TPA_M_DEFAULT=	$FIELDMASK(TPA_DEFAULT),
	TPA_M_ORIGINAL=	$FIELDMASK(TPA_ORIGINAL),
	TPA_M_PARENT=	$FIELDMASK(TPA_PARENT),
	TPA_M_UIC=	$FIELDMASK(TPA_UIC),
	TPA_M_NOBACKUP=	$FIELDMASK(TPA_NOBACKUP),
	TPA_M_INTERLOCK=$FIELDMASK(TPA_INTERLOCK);


MACRO
	VAR_LENGTH=	0,0,16,0 %,	! Length of varying string
	VAR_BODY=	2,0,0,0 %;	! Body of varying string

OWN
	CHK_FLAGS:	BBLOCK[4];	! Flags for CHECK routines
MACRO
	CHK_FLAGS_COUNT=	0,0,8,0 %,	! Count of items in list
	CHK_FLAGS_F11=		1,0,1,0 %,	! True if Files-11 seen
	CHK_FLAGS_SAV=		1,1,1,0 %,	! True if save set seen
	CHK_FLAGS_SAVE_SET=	1,2,1,0 %,	! True if /SAVE_SET
	CHK_FLAGS_SRCH_LIST=	1,3,1,0 %;	! True if search decoding is needed



%SBTTL 'CALL_TPARSE - call LIB$TPARSE'
ROUTINE CALL_TPARSE(SRC,STATES,KEYS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes a call to LIB$TPARSE.
!
! INPUT PARAMETERS:
!	SRC		- Pointer to the string to be parsed (PL/I varying).
!	STATES		- State table parameter for TPARSE.
!	KEYS		- Keyword table parameter for TPARSE.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	As returned by LIB$TPARSE.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SRC:		REF BBLOCK;		! Pointer to varying string
LOCAL
	TPA_PARAM:	BBLOCK[TPA$K_LENGTH0];	! TPARSE parameter block


CH$FILL(0, TPA$K_LENGTH0, TPA_PARAM);
TPA_PARAM[TPA$L_COUNT] = TPA$K_COUNT0;
TPA_PARAM[TPA$L_OPTIONS] = TPA$M_ABBREV;
TPA_PARAM[TPA$L_STRINGCNT] = .SRC[VAR_LENGTH];
TPA_PARAM[TPA$L_STRINGPTR] = SRC[VAR_BODY];
LIB$TPARSE(TPA_PARAM, .STATES, .KEYS)
END;

%SBTTL 'PRESERVE_STRING - save string buffer'
ROUTINE PRESERVE_STRING(SRC,DST): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine saves the contents of the string buffer in dynamically
!	allocated memory.
!
! INPUT PARAMETERS:
!	SRC		- Pointer to input string (PL/I varying).
!	DST		- Pointer to descriptor that is initialized to
!			  describe the copy.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Dynamic memory is allocated.
!
!--

BEGIN
MAP
	SRC:		REF BBLOCK,	! Pointer to PL/I varying string
	DST:		REF BBLOCK;	! Pointer to descriptor


! Initialize output descriptor.
!
DST[DSC$W_LENGTH] = .SRC[VAR_LENGTH];
DST[DSC$B_DTYPE] = DSC$K_DTYPE_T;
DST[DSC$B_CLASS] = DSC$K_CLASS_S;


IF .SRC[VAR_LENGTH] NEQ 0
THEN
    BEGIN

    ! Allocate memory to hold string.
    !
    DST[DSC$A_POINTER] = GET_VM(.SRC[VAR_LENGTH]);


    ! Copy string to allocated memory.
    !
    CH$MOVE(.SRC[VAR_LENGTH], SRC[VAR_BODY], .DST[DSC$A_POINTER]);
    END;
END;

%SBTTL 'GET_FC - initialize file context area'
ROUTINE GET_FC(SRC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine gets a file context area, initializing it.
!
! INPUT PARAMETERS:
!	SRC		- Pointer to filename string (PL/I varying).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Address of the allocated memory.
!
! SIDE EFFECTS:
!	LIB$GET_VM errors may be signalled.
!
!--

BEGIN
MAP
	SRC:		REF BBLOCK;	! Pointer to PL/I varying string
LOCAL
	DESC:		BBLOCK[8],	! Descriptor for preserved string
	AREA:		REF BBLOCK;	! Pointer to allocated area


PRESERVE_STRING(.SRC, DESC);		! Get dynamic copy of string
AREA = GET_ZERO_VM(FC_S_AREA);
$FAB_INIT(
    FAB=AREA[FC_FAB],
    FNA=.DESC[DSC$A_POINTER],
    FNS=.DESC[DSC$W_LENGTH],
    NAM=AREA[FC_NAM]);
$RAB_INIT(
    RAB=AREA[FC_RAB],
    FAB=AREA[FC_FAB]);
$NAM_INIT(
    NAM=AREA[FC_NAM],
    RLF=AREA[FC_RLF],
    ESA=AREA[FC_ESA],
    ESS=NAM$C_MAXRSS,
    RSA=AREA[FC_RSA],
    RSS=NAM$C_MAXRSS);
$NAM_INIT(
    NAM=AREA[FC_RLF]);
.AREA
END;


%SBTTL 'COPY_FC - copy file context area'
ROUTINE COPY_FC ( FC : REF BBLOCK,
                  NEW_FC : REF BBLOCK, FILE_LEN, FILE_ADDR ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates a file context area and copies the 
!	file context area passed as a parameter into it
!
! INPUT PARAMETERS:
!	FC		- File context block to make a copy of
!	NEW_FC		- File context block to copy to
!	FILE_LEN	- length of file name string
!	FILE_ADDR	- address of file name string
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
! SIDE EFFECTS:
!	LIB$GET_VM errors may be signalled.
!
!--

BEGIN

LITERAL
    LEN1 = %CHARCOUNT ('.]['),
    LEN2 = %CHARCOUNT ('.><'),
    LEN3 = %CHARCOUNT ('.>['),
    LEN4 = %CHARCOUNT ('.]<');

BIND
    STR1 = UPLIT BYTE ('.]['),
    STR2 = UPLIT BYTE ('.><'),
    STR3 = UPLIT BYTE ('.>['),
    STR4 = UPLIT BYTE ('.]<') ;

LOCAL
    STR1_PTR		: REF VECTOR [,BYTE] ,
    STR2_PTR		: REF VECTOR [,BYTE] ,
    STR3_PTR		: REF VECTOR [,BYTE] ,
    STR4_PTR		: REF VECTOR [,BYTE] ,
    NEW_FILE_LEN	: LONG ,
    WORK_FILE_NAME	: REF VECTOR [,BYTE] ,
    FILE_NAME		: REF BBLOCK ,		! Pointer to FNS buffer
    FAB			: REF BBLOCK ,
    NAM			: REF BBLOCK ,
    RAB			: REF BBLOCK ,
    CONTINUE		: BYTE ,
    STR_FOUND		: BYTE ;


FAB = FC [ FC_FAB ] ;

!
! Allocate memory for the file name string and copy the string.
! ****************************************************************************
! ****************************************************************************
! In the process of coppyng it strip out all ".][" , ".]<", ".>[" ,and ".><"
! strings.  This puts a restriction on BACKUP since we will no longer be able
! to deal with a concraled device which hides 8 directorie levels but at the
! present time there is no time for a more elegant solution.  This problem
! was reported in QAR #1212 from the FT2 data base.  Search lists with 
! concealed devices do not work.
! ****************************************************************************
! ****************************************************************************
!

WORK_FILE_NAME = GET_VM ( .FILE_LEN ) ;
CH$MOVE ( .FILE_LEN, .FILE_ADDR, .WORK_FILE_NAME ) ;
NEW_FILE_LEN = .FILE_LEN ;

CONTINUE = 1 ;
STR_FOUND = 0 ;
WHILE .CONTINUE DO
    BEGIN
    STR1_PTR = CH$FIND_SUB ( .NEW_FILE_LEN, .WORK_FILE_NAME, LEN1, STR1 );
    STR2_PTR = CH$FIND_SUB ( .NEW_FILE_LEN, .WORK_FILE_NAME, LEN2, STR2 );
    STR3_PTR = CH$FIND_SUB ( .NEW_FILE_LEN, .WORK_FILE_NAME, LEN3, STR3 );
    STR4_PTR = CH$FIND_SUB ( .NEW_FILE_LEN, .WORK_FILE_NAME, LEN4, STR4 );
    
    IF NOT CH$FAIL (.STR1_PTR)
    THEN
	BEGIN
	STR_FOUND = 1 ;
	STR1_PTR = .STR1_PTR + 1 ;	!  Skip past "."
	NEW_FILE_LEN = .NEW_FILE_LEN - LEN1 + 1 ;
    	CH$MOVE ( (.WORK_FILE_NAME + .NEW_FILE_LEN - .STR1_PTR),
	          .STR1_PTR + LEN1 - 1,
	          .STR1_PTR ) ;
	END
    ELSE IF NOT CH$FAIL (.STR2_PTR)
    THEN
	BEGIN
	STR_FOUND = 1 ;
	STR2_PTR = .STR2_PTR + 1 ;	!  Skip past "."
	NEW_FILE_LEN = .NEW_FILE_LEN - LEN2 + 1 ;
    	CH$MOVE ( (.WORK_FILE_NAME + .NEW_FILE_LEN - .STR2_PTR),
	          .STR2_PTR + LEN2 - 1,
	          .STR2_PTR ) ;
	END
    ELSE IF NOT CH$FAIL ( .STR3_PTR )
    THEN
	BEGIN
	STR_FOUND = 1 ;
	STR3_PTR = .STR3_PTR + 1 ;	!  Skip past "."
	NEW_FILE_LEN = .NEW_FILE_LEN - LEN3 + 1;
    	CH$MOVE ( (.WORK_FILE_NAME + .NEW_FILE_LEN - .STR3_PTR),
	          .STR3_PTR + LEN3 - 1,
	          .STR3_PTR ) ;
	STR2_PTR = CH$FIND_CH ( .WORK_FILE_NAME + .NEW_FILE_LEN - .STR3_PTR,
	                        .STR3_PTR,
	                        %C']') ;
	IF NOT CH$FAIL (.STR2_PTR)
	THEN
	    STR2_PTR[0] = %C'>' ;
	END
    ELSE IF NOT CH$FAIL ( .STR4_PTR )
    THEN
	BEGIN
	STR_FOUND = 1 ;
	STR4_PTR = .STR4_PTR + 1 ;	!  Skip past "."
	NEW_FILE_LEN = .NEW_FILE_LEN - LEN4 + 1 ;
    	CH$MOVE ( (.WORK_FILE_NAME + .NEW_FILE_LEN - .STR4_PTR),
	          .STR4_PTR + LEN4 - 1 ,
	          .STR4_PTR ) ;
	STR2_PTR = CH$FIND_CH ( .WORK_FILE_NAME + .NEW_FILE_LEN - .STR4_PTR,
	                        .STR4_PTR,
	                        %C'>') ;
	IF NOT CH$FAIL (.STR2_PTR)
	THEN
	    STR2_PTR[0] = %C']' ;
	END
    ELSE CONTINUE = 0 ;
    
    END ;

IF .STR_FOUND
THEN
    BEGIN
    FILE_NAME = GET_VM ( .NEW_FILE_LEN ) ;
    CH$MOVE ( .NEW_FILE_LEN, .WORK_FILE_NAME, .FILE_NAME ) ;
    FREE_VM ( .FILE_LEN, .WORK_FILE_NAME ) ;
    END
ELSE
    FILE_NAME = .WORK_FILE_NAME ;

CH$MOVE ( FC_S_AREA, .FC, .NEW_FC ) ;

FAB = NEW_FC [ FC_FAB ] ;
NAM = NEW_FC [ FC_NAM ] ;
RAB = NEW_FC [ FC_RAB ] ;

FAB[FAB$B_FNS] = .NEW_FILE_LEN ;
FAB[FAB$L_FNA] = .FILE_NAME ;
FAB[FAB$L_NAM] = .NAM ;

RAB[RAB$L_FAB] = .FAB ;

NAM[NAM$L_RLF]  = NEW_FC [ FC_RLF ] ;
NAM[NAM$L_ESA]  = NEW_FC [ FC_ESA ] ;
NAM[NAM$B_ESS]  = NAM$C_MAXRSS ;
NAM[NAM$L_RSA]  = NEW_FC [ FC_RSA ] ;
NAM[NAM$L_NODE] = .NAM[NAM$L_ESA] ;
NAM[NAM$L_DEV]  = .NAM[NAM$L_NODE]  + .NAM[NAM$B_NODE] ;
NAM[NAM$L_DIR]  = .NAM[NAM$L_DEV]  + .NAM[NAM$B_DEV] ;
NAM[NAM$L_NAME] = .NAM[NAM$L_DIR]  + .NAM[NAM$B_DIR] ;
NAM[NAM$L_TYPE] = .NAM[NAM$L_NAME] + .NAM[NAM$B_NAME] ;
NAM[NAM$L_VER]  = .NAM[NAM$L_TYPE] + .NAM[NAM$B_TYPE] ;

NAM[NAM$B_RSS] = NAM$C_MAXRSS ;
NAM[NAM$V_SLPARSE] = 0 ;
NAM[NAM$V_NOCONCEAL] = 0 ;
NAM[NAM$V_SVCTX] = 0 ;
NAM[NAM$L_WCC] = 0 ;

RETURN ;

END;


%SBTTL 'INIT_FC - init file context area'
ROUTINE INIT_FC ( FC : REF BBLOCK , FILE_LEN, FILE_ADDR ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is used to reinitialize an already existing FC
!	for use parsing another file name string.  The name from the
!	previous file parse is propagated in the related name block
!	so that the name parsing will be good and sticky.
!
! INPUT PARAMETERS:
!	FC		- File context block from last parse
!	FILE_LEN	- Length of file name string
!	FILE_ADDR	- Address of file name string
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	
!	FC will be reinitialized and there will be a new related nam
!	block hanging off the FC's NAM block.
!
! ROUTINE VALUE:
!
! SIDE EFFECTS:
!	LIB$GET_VM errors may be signalled.
!
!--

BEGIN

LOCAL
    DESC	: BBLOCK [8] ,
    NEW_RNAM	: REF BBLOCK ,		! Pointer to allocated area
    RLF_NAME	: REF BBLOCK ,		! Pointer to FNS buffer
    FILE_NAME	: REF BBLOCK ,		! Pointer to FNA buffer
    RLF_LEN	: BYTE ,		! File name length holder
    FAB		: REF BBLOCK ,
    NAM		: REF BBLOCK ;


FAB = FC [ FC_FAB ] ;
NAM = FC [ FC_NAM ] ;

!
! Get memory for the new FNS
!
FILE_NAME = GET_VM ( .FILE_LEN ) ;
CH$MOVE ( .FILE_LEN, .FILE_ADDR, .FILE_NAME ) ;


!
! Allocate memory for the new related NAM block, init it
! and link it into the chain.
!
NEW_RNAM = GET_VM (NAM$C_BLN) ;

RLF_LEN = .FAB[FAB$B_FNS] ;
RLF_NAME = GET_VM ( .RLF_LEN ) ;
CH$MOVE ( .RLF_LEN, .FAB[FAB$L_FNA], .RLF_NAME ) ;

$NAM_INIT (
    NAM = .NEW_RNAM,
    RLF = .NAM[NAM$L_RLF] ,
    RSS = .RLF_LEN ,
    RSA = .RLF_NAME
    ) ;
NEW_RNAM[NAM$B_RSL] = .RLF_LEN ;

NAM[NAM$L_RLF] = .NEW_RNAM ;

!
! Now give up the memory that the old FNA used and get a new
! hunk of the correct length.
!
FREE_VM ( .FAB[FAB$B_FNS], .FAB[FAB$L_FNA] ) ;

!
! Now init the FAB
!
$FAB_INIT(
    FAB = .FAB ,
    FNA = .FILE_NAME,
    FNS = .FILE_LEN,
    NAM = .NAM );
            

RETURN ;

END;


%SBTTL 'PARSE_EXC_SEL - parse EXCLUDE or SELECT qualifier'
ROUTINE PARSE_EXC_SEL(SRC,QUAL_DESC,ESL_DESC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses and checks the value of an EXCLUDE or SELECT
!	qualifier.
!
! INPUT PARAMETERS:
!	SRC		- Pointer to the string to be parsed (PL/I varying).
!	QUAL_DESC	- Descriptor for the qualifier name.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	ESL_DESC	- Rewritten with the expanded string resulting
!			  from the $PARSE operation.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SRC:		REF BBLOCK,	! Pointer to PL/I varying string
	ESL_DESC:	REF BBLOCK;	! Pointer to descriptor
LOCAL
	FAB:		BBLOCK[FAB$C_BLN],	! Local FAB
	NAM:		BBLOCK[NAM$C_BLN],	! Local NAM block
	ESA:		BBLOCK[NAM$C_MAXRSS];	! Local expanded string


! Initialize the local RMS structures we use to do this $PARSE.
!
$FAB_INIT(FAB=FAB,
    DNA=UPLIT BYTE('[000000...]*.*;*'),
    DNS=%CHARCOUNT('[000000...]*.*;*'),
    FNA=SRC[VAR_BODY],
    FNS=.SRC[VAR_LENGTH],
    NAM=NAM);
$NAM_INIT(NAM=NAM,
    ESA=ESA,
    ESS=NAM$C_MAXRSS);


! Execute the $PARSE.
!
$PARSE(FAB=FAB);


! If an error we are not willing to accept occurs, signal it.
!
IF
    .NAM[NAM$B_ESL] EQL 0 OR
    (.NAM[NAM$L_FNB] AND
	(NAM$M_EXP_DEV OR
	 NAM$M_NODE OR
	 NAM$M_QUOTED)) NEQ 0
THEN
    SIGNAL(BACKUP$_INVQUAVAL, 3, .SRC[VAR_LENGTH], SRC[VAR_BODY], .QUAL_DESC);


! Initialize output descriptor.
!
ESL_DESC[DSC$W_LENGTH] = .NAM[NAM$B_ESL];
ESL_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
ESL_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;


! Allocate memory to hold string.
!
ESL_DESC[DSC$A_POINTER] = GET_VM(.NAM[NAM$B_ESL]);


! Copy the expanded string to ESL_DESC.
!
CH$MOVE(
    .NAM[NAM$B_ESL],
    ESA,
    .ESL_DESC[DSC$A_POINTER]);


! Do another $PARSE on the null string.  This will delete the internal RMS
! context, if any.
!
FAB[FAB$B_FNS] = 0;
FAB[FAB$B_DNS] = 0;
$PARSE(FAB=FAB);
END;


%SBTTL 'EXPAND_SEARCH_LIST '
ROUTINE EXPAND_SEARCH_LIST ( FC  : REF BBLOCK, 
                             PTR : REF BBLOCK, LAST_PTR : REF BBLOCK ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is used to expand a search list into individual
!	directory names.  The block pointed to by PTR will be removed
!	from the linked list and replaced by n blocks, one each for
!	each value of the search list.
!
! INPUT PARAMETERS:
!	FC		- address of file context block used for $PARSE
!	PTR		- address of input qualifier context block
!	LAST_PTR	- address of last block (previous block in list)
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	If a search list was found then the forward pointer will be modified
!	to point to the new elements and the old .PTR will be deallocated.
!
! ROUTINE VALUE:
!	If a search list was found the address of the new input qualifier
!	block else .PTR
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
    FAB		: REF BBLOCK ,
    NAM		: REF BBLOCK ,
    WORK_FC	: REF BBLOCK ,
    NEW_FAB	: REF BBLOCK ,
    NEW_NAM	: REF BBLOCK ,
    LAST	: REF BBLOCK ,
    NEW_LIST	: REF BBLOCK ,
    NEW_ITEM	: REF BBLOCK ,
    OPEN_COUNT	: LONG ,
    WCCSAV	: LONG ,
    STATUS	: LONG ;

LAST = 0 ;
WORK_FC = .FC ;
FAB = WORK_FC [FC_FAB] ;
NAM = WORK_FC [FC_NAM] ;
OPEN_COUNT = .CHK_FLAGS[CHK_FLAGS_COUNT] ;

!
! Parse the string and if it is not a search list then return
!
NAM[NAM$V_SLPARSE] = 1 ;
NAM[NAM$V_NOCONCEAL] = 1 ;
WCCSAV = .NAM[NAM$L_WCC] ;
NAM[NAM$L_WCC] = 0 ;
STATUS = $PARSE ( FAB = .FAB ) ;
IF NOT ( .STATUS AND
         .NAM[NAM$V_SEARCH_LIST] )
THEN
    BEGIN
    !
    ! Clean up the work FC
    !
    NAM[NAM$V_SVCTX] = 0 ;
    NAM[NAM$V_SLPARSE] = 0 ;
    NAM[NAM$V_NOCONCEAL] = 0 ;
    NAM[NAM$L_WCC] = .WCCSAV;
    RETURN 0 ;
    END ;

!
! We have a search list so loop through all values
!
WHILE .STATUS DO
    BEGIN

    !
    ! Allocate a new block and insert it in
    ! the new list
    !
    NEW_ITEM = GET_ZERO_VM ( QUAL_S_INPU ) ;
    IF .LAST EQL 0
	THEN NEW_LIST = .NEW_ITEM
	ELSE 
	    BEGIN
	    LAST [QUAL_NEXT] = .NEW_ITEM ;
	    CHK_FLAGS [CHK_FLAGS_COUNT] = .CHK_FLAGS [CHK_FLAGS_COUNT] + 1 ;
	    END ;
    LAST = .NEW_ITEM ;

    !
    ! Copy over the data
    !
    NEW_ITEM[QUAL_PARA_FC] = GET_VM ( FC_S_AREA ) ;
    COPY_FC ( .WORK_FC, .NEW_ITEM[QUAL_PARA_FC],
              .NAM[NAM$B_ESL], .NAM[NAM$L_ESA] );

    !
    ! Reparse the copy
    !
    NEW_FAB = BBLOCK [.NEW_ITEM[QUAL_PARA_FC], FC_FAB ] ;
    NEW_NAM = BBLOCK [.NEW_ITEM[QUAL_PARA_FC], FC_NAM ] ;

    IF NOT $PARSE(FAB=.NEW_FAB)
    THEN
	FILE_ERROR(BACKUP$_PARSE, .NEW_FAB, .NEW_FAB[FAB$L_STS], .NEW_FAB[FAB$L_STV]);

    !
    ! Check the validity of the resultant spec.
    !
    CHECK_F11 ( .NEW_NAM, FALSE ) ;
    CHECK_COMMON ( .NEW_FAB, FALSE ) ;

    !
    ! Set up the string descriptors in the new list element
    !
    BUILD_QUAL_DESC ( .NEW_ITEM, .NEW_NAM ) ;

    !
    ! Get the next element of the search list
    !
    STATUS = $PARSE ( FAB = .FAB ) ;

    END ;

!
! Insert the new list where the old element came from
!
NEW_ITEM [QUAL_NEXT] = .PTR [QUAL_NEXT] ;
IF .OPEN_COUNT EQL 1
    THEN .LAST_PTR = .NEW_LIST
    ELSE LAST_PTR [QUAL_NEXT] = .NEW_LIST ;

!
! Clean up the work FC
!
NAM[NAM$V_SVCTX] = 0 ;
NAM[NAM$V_SLPARSE] = 0 ;
NAM[NAM$V_NOCONCEAL] = 0 ;
NAM[NAM$L_WCC] = .WCCSAV ;

!
! Now clean up the old item
!
FAB = BBLOCK [.PTR[QUAL_PARA_FC], FC_FAB ] ;
FREE_VM ( .FAB[FAB$B_FNS], .FAB[FAB$L_FNA] ) ;
FREE_VM ( FC_S_AREA, .PTR[QUAL_PARA_FC] ) ;
FREE_VM ( QUAL_S_INPU, .PTR ) ;

RETURN .NEW_ITEM ;

END ;



%SBTTL 'CHECK_SAV - check save set input and output lists'
ROUTINE CHECK_SAV( NAM : REF BBLOCK, OUTPUT_SIDE ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine validitys the save set input and output lists.
!
! INPUT PARAMETERS:
!	NAM		- address of NAM
!	OUTPUT_SIDE	- True if output, false if input.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Messages may be signalled if errors are detected.
!
!--

BEGIN

IF .OUTPUT_SIDE
THEN (IF .NAM[NAM$V_WILDCARD] THEN SIGNAL(BACKUP$_SAVSETNAM);)
ELSE
    BEGIN
    INPUT_FLAGS[INPUT_REWOUND] = FALSE;
    IF .NAM[NAM$V_WILDCARD]
    THEN INPUT_FLAGS[INPUT_WILDSAVE] = TRUE
    ELSE INPUT_FLAGS[INPUT_WILDSAVE] = FALSE;
    END;

IF
    BEGIN
    IF
	(.NAM[NAM$L_FNB] AND
	    (NAM$M_NODE OR NAM$M_QUOTED OR
	    NAM$M_EXP_DIR OR NAM$M_EXP_NAME OR
	    NAM$M_EXP_TYPE OR NAM$M_EXP_VER)) NEQ 0
    THEN
	.CHK_FLAGS[CHK_FLAGS_COUNT] NEQ 1		! non-null must be first
    ELSE
	.CHK_FLAGS[CHK_FLAGS_COUNT] EQL 1 AND .OUTPUT_SIDE
					! null must not be first output
    END
THEN
    SIGNAL(BACKUP$_SAVSETNAM); ! save set name must be in first spec


IF .CHK_FLAGS[CHK_FLAGS_F11]
    THEN SIGNAL(BACKUP$_INCDEVLIS); ! inconsistent devices in list


IF .OUTPUT_SIDE
THEN
    BEGIN
    IF .QUAL[QUAL_ISAV]
	THEN SIGNAL(BACKUP$_ONEF11DEV); ! one F11 device
    IF .QUAL[QUAL_COMP]
	THEN SIGNAL(BACKUP$_CMPOUTF11); ! /COMPARE requires F11 output
    END;

RETURN ;

END ;


%SBTTL 'CHECK_F11 - check F11 format'
ROUTINE CHECK_F11( NAM : REF BBLOCK, OUTPUT_SIDE ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine validity checks files 11 input and output lists 
!
! INPUT PARAMETERS:
!	NAM		- address of NAM
!	OUTPUT_SIDE	- True if output, false if input.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Messages may be signalled if errors are detected.
!
!--

BEGIN

IF .QUAL[QUAL_PHYS]
THEN
    BEGIN
    CHK_FLAGS [ CHK_FLAGS_SRCH_LIST ] = 0 ;	! No search lists for physical
    IF .CHK_FLAGS[CHK_FLAGS_COUNT] GTR 1
	THEN SIGNAL(BACKUP$_ONEPHYDEV); ! one /PHYSICAL device
    IF (.NAM[NAM$L_FNB] AND
	(NAM$M_EXP_DIR OR NAM$M_EXP_NAME OR
	 NAM$M_EXP_TYPE OR NAM$M_EXP_VER)) NEQ 0
	THEN SIGNAL(BACKUP$_PHYFILSPE); ! bad /PHYSICAL spec
    END
ELSE IF .QUAL[QUAL_IMAG] OR .COM_FLAGS[COM_STANDALONE]
THEN
    BEGIN
    IF NOT .COM_FLAGS[COM_STANDALONE]
    THEN
	CHK_FLAGS [ CHK_FLAGS_SRCH_LIST ] = 0 ;	! No search lists for image
    IF .CHK_FLAGS[CHK_FLAGS_COUNT] GTR 1 AND NOT .OUTPUT_SIDE AND NOT .COM_FLAGS[COM_STANDALONE]
	THEN SIGNAL(BACKUP$_ONEIMGDEV); ! one /IMAGE device
    IF (.NAM[NAM$L_FNB] AND
	(NAM$M_EXP_DIR OR NAM$M_EXP_NAME OR
	 NAM$M_EXP_TYPE OR NAM$M_EXP_VER)) NEQ 0
	THEN SIGNAL(BACKUP$_IMGFILSPE); ! bad /IMAGE spec
    END
ELSE IF .QUAL[QUAL_INCR]
THEN
    BEGIN
    IF (.NAM[NAM$L_FNB] AND
	(NAM$M_EXP_DIR OR NAM$M_EXP_NAME OR
	 NAM$M_EXP_TYPE OR NAM$M_EXP_VER)) NEQ 0
	THEN SIGNAL(BACKUP$_INCFILSPE); ! bad /INCREMENTAL spec
    END;


IF .CHK_FLAGS[CHK_FLAGS_SAV]
    THEN SIGNAL(BACKUP$_INCDEVLIS); ! inconsistent devices in list


IF .OUTPUT_SIDE
THEN
    BEGIN
    IF
	.CHK_FLAGS[CHK_FLAGS_COUNT] GTR 1 AND
	NOT .QUAL[QUAL_IMAG] AND
	NOT .COM_FLAGS[COM_STANDALONE]
    THEN
	SIGNAL(BACKUP$_ONEF11OUT); ! too many outputs
    END
ELSE
    BEGIN
    IF .QUAL[QUAL_LIST] AND .QUAL[QUAL_OUTP_LIST] EQL 0
	THEN SIGNAL(BACKUP$_LISINPSAV); ! LIST input must be saveset
    END;

RETURN ;

END ;


%SBTTL 'CHECK_COMMON - perform common check'
ROUTINE CHECK_COMMON( FAB : REF BBLOCK, OUTPUT_SIDE ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine performs the common checks for input and output lists.
!
! INPUT PARAMETERS:
!	FAB		- address of FAB
!	OUTPUT_SIDE	- True if output, false if input.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Messages may be signalled if errors are detected.
!
!--

BEGIN

IF NOT .COM_FLAGS[COM_STANDALONE]
THEN
    IF  (
	.BBLOCK[FAB[FAB$L_DEV], DEV$V_SQD]
    OR
	NOT .CHK_FLAGS[CHK_FLAGS_SAVE_SET] AND
	(.QUAL[QUAL_PHYS] OR
	 .QUAL[QUAL_IMAG] AND .OUTPUT_SIDE AND NOT .QUAL[QUAL_COMP])
	)
    THEN
	BEGIN
	!
	! Tape save set, physical volume, or image output.
	! Must be mounted foreign.
	!
	IF
	    NOT .BBLOCK[FAB[FAB$L_DEV], DEV$V_FOR] AND
	    NOT (.QUAL[QUAL_PHYS] AND NOT .OUTPUT_SIDE AND
		.JPI_CURPRIV[PRV$V_LOG_IO])
	THEN
	    FILE_ERROR(BACKUP$_MOUNTFOR, .FAB);
	END
    ELSE IF NOT .CHK_FLAGS[CHK_FLAGS_SAVE_SET]
    THEN
	BEGIN
	!
	! Files.
	! Must be mounted Files-11.
	!
	IF .BBLOCK[FAB[FAB$L_DEV], DEV$V_FOR]
	THEN
	    FILE_ERROR(BACKUP$_MOUNTF11, .FAB);
	END;

RETURN ;

END ;


%SBTTL 'BUILD_QUAL_DESC - Build qualifier block descriptors'
ROUTINE BUILD_QUAL_DESC( PTR : REF BBLOCK, NAM : REF BBLOCK ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine fills in the descriptors in the qualifier block
!
! INPUT PARAMETERS:
!	PTR		- Address of block
!	NAM		- Address of NAM block
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!
!--

BEGIN

! Set up expanded-string descriptors.
!
BBLOCK[PTR[QUAL_EXP_DESC], DSC$W_LENGTH] = .NAM[NAM$B_ESL];
BBLOCK[PTR[QUAL_EXP_DESC], DSC$A_POINTER] = .NAM[NAM$L_ESA];
BBLOCK[PTR[QUAL_DEV_DESC], DSC$W_LENGTH] = .NAM[NAM$B_DEV];
BBLOCK[PTR[QUAL_DEV_DESC], DSC$A_POINTER] = .NAM[NAM$L_DEV];
BBLOCK[PTR[QUAL_DVI_DESC], DSC$W_LENGTH] = .(NAM[NAM$T_DVI])<0,8>;
BBLOCK[PTR[QUAL_DVI_DESC], DSC$A_POINTER] = NAM[NAM$T_DVI] + 1;

RETURN ;

END ;


%SBTTL 'CHECK - check input and output lists'
ROUTINE CHECK ( ROOT : REF BBLOCK, OUTPUT_SIDE ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine validity-checks the input and output lists.
!
! INPUT PARAMETERS:
!	ROOT		- Address of root of the input or output list.
!	OUTPUT_SIDE	- True if output, false if input.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Messages may be signalled if errors are detected.
!
!--

BEGIN

LITERAL
    ALL_WILD_LEN =	%CHARCOUNT('*.*;*'), 
    WILD_VERS_LEN =	%CHARCOUNT(';*'); 

BIND
    ALL_WILD =		UPLIT BYTE('*.*;*'), 
    WILD_VERS =		UPLIT BYTE(';*');

LOCAL
    FAB			: REF BBLOCK,
    NAM			: REF BBLOCK,
    FC			: REF BBLOCK,
    WORK_FAB		: REF BBLOCK,
    WORK_NAM		: REF BBLOCK,
    WORK_FC		: REF BBLOCK,
    PTR			: REF BBLOCK,	! Cursor for list
    LAST_PTR		: REF BBLOCK;	! Previous Cursor for list

LAST_PTR = .ROOT;
PTR = ..ROOT;
CHK_FLAGS = 0;

!
! If no files then return
!
IF .PTR EQL 0
THEN
    BEGIN
    QUAL[QUAL_OF11] = .CHK_FLAGS[CHK_FLAGS_F11];
    QUAL[QUAL_OSAV] = .CHK_FLAGS[CHK_FLAGS_SAV];
    RETURN ;
    END ;

!
! Allocate an FC block to do the work with and initialize
! it to match the first FC in the list
!
FC = .PTR[QUAL_PARA_FC] ;
FAB = FC[FC_FAB] ;
NAM = FC[FC_NAM] ;
WORK_FC = GET_VM ( FC_S_AREA ) ;
COPY_FC ( .FC, .WORK_FC, .FAB[FAB$B_FNS], .FAB[FAB$L_FNA] ) ;
WORK_FAB = WORK_FC[FC_FAB] ;
WORK_NAM = WORK_FC[FC_NAM] ;
WORK_NAM[NAM$L_RLF] = 0 ;


! Parse search lists for input
!
IF NOT .OUTPUT_SIDE
THEN
    CHK_FLAGS[CHK_FLAGS_SRCH_LIST] = 1 ;

WHILE .PTR NEQ 0 DO
    BEGIN

    IF .CHK_FLAGS[CHK_FLAGS_COUNT] NEQ 0
    THEN
	BEGIN
	!
	! This is not the first time through
	! so reinit the FC
	!
	FC = .PTR[QUAL_PARA_FC] ;
	FAB = FC[FC_FAB] ;
	NAM = FC[FC_NAM] ;
	INIT_FC ( .WORK_FC, .FAB[FAB$B_FNS], .FAB[FAB$L_FNA] ) ;
	END ;

    CHK_FLAGS[CHK_FLAGS_COUNT] = .CHK_FLAGS[CHK_FLAGS_COUNT] + 1;

    IF .OUTPUT_SIDE
	THEN CHK_FLAGS[CHK_FLAGS_SAVE_SET] = .QUAL[QUAL_O_SAVE]
	ELSE CHK_FLAGS[CHK_FLAGS_SAVE_SET] = .QUAL[QUAL_I_SAVE];

    IF NOT $PARSE(FAB=.WORK_FAB)
    THEN
	IF .WORK_FAB[FAB$L_STS] EQL RMS$_DNF
	THEN
	    WORK_FAB[FAB$L_DEV] = DEV$M_FOD OR DEV$M_MNT
	ELSE
	    FILE_ERROR(BACKUP$_PARSE, .WORK_FAB,
	               .WORK_FAB[FAB$L_STS], .WORK_FAB[FAB$L_STV]);


    IF
	NOT .BBLOCK[WORK_FAB[FAB$L_DEV], DEV$V_FOD] AND
	NOT ((.BBLOCK[WORK_FAB[FAB$L_DEV], DEV$V_NET] OR
	    .BBLOCK[WORK_FAB[FAB$L_DEV], DEV$V_MBX]) AND .CHK_FLAGS[CHK_FLAGS_SAVE_SET])
    THEN
	FILE_ERROR(BACKUP$_INVDEVTYP, .WORK_FAB);


    IF
	.BBLOCK[WORK_FAB[FAB$L_DEV], DEV$V_SQD] OR
	.CHK_FLAGS[CHK_FLAGS_SAVE_SET]
    THEN
	BEGIN
	CHK_FLAGS[CHK_FLAGS_SAV] = TRUE;
	IF .BBLOCK[WORK_FAB[FAB$L_DEV], DEV$V_FOR]
	THEN
	    BEGIN
	    IF .CHK_FLAGS[CHK_FLAGS_COUNT] EQL 1
	    THEN
		BEGIN
		WORK_FAB[FAB$B_DNS] = %CHARCOUNT('[000000]');
		WORK_FAB[FAB$L_DNA] = UPLIT BYTE('[000000]');
		$PARSE(FAB=.WORK_FAB);
		END;
	    END
	ELSE
	    QUAL[QUAL_SS_FILE] = TRUE;

	CHECK_SAV ( .WORK_NAM, .OUTPUT_SIDE ) ;
	CHECK_COMMON ( .WORK_FAB, .OUTPUT_SIDE ) ;

	!
	! Now copy the parsed FC to the list
	!
	COPY_FC ( .WORK_FC, .FC, .WORK_NAM[NAM$B_ESL], .WORK_NAM[NAM$L_ESA] ) ;
    
	! Set up expanded-string descriptors.
	!
	BUILD_QUAL_DESC ( .PTR, .NAM ) ;

	END
    ELSE
	BEGIN
	LOCAL
	    NEW_PTR 	: LONG ,
	    WILD_RLF	: REF BBLOCK ,
	    RNAM	: REF BBLOCK ;

	NEW_PTR = 0 ;

	CHK_FLAGS[CHK_FLAGS_F11] = TRUE;

	IF .CHK_FLAGS[CHK_FLAGS_COUNT] EQL 1
	THEN
	    BEGIN
	    !
	    ! The first related file name must be *.*;* 
	    ! and the default name string must be *.*;* for
	    ! the first round and then the default must be changed
	    ! to ;* for each successive round so that 
	    ! stickyness works properly and unless an explicit
	    ! version is requested all versions will be saved.
	    !
	    WILD_RLF = GET_VM ( ALL_WILD_LEN ) ;
	    CH$MOVE ( ALL_WILD_LEN, ALL_WILD, .WILD_RLF );
	    RNAM = GET_VM (NAM$C_BLN) ;
	    $NAM_INIT (
		NAM = .RNAM,
		RLF = .WORK_NAM[NAM$L_RLF],
		RSS = ALL_WILD_LEN ,
		RSA = .WILD_RLF
		) ;
	    RNAM[NAM$B_RSL] = ALL_WILD_LEN ;
	    WORK_NAM[NAM$L_RLF] = .RNAM ;
	    WORK_FAB[FAB$B_DNS] = ALL_WILD_LEN ;
	    WORK_FAB[FAB$L_DNA] = ALL_WILD;
	    END
	ELSE
	    BEGIN
	    WORK_FAB[FAB$B_DNS] = WILD_VERS_LEN ;
	    WORK_FAB[FAB$L_DNA] = WILD_VERS;
	    END ;

	CHECK_F11 ( .WORK_NAM, .OUTPUT_SIDE ) ;

	IF .CHK_FLAGS [CHK_FLAGS_SRCH_LIST]
	THEN
	    ! Expand the search list.  If zero is returned then no search
	    ! list was present.  If this is a search list then it will
	    ! be expanded and the block pointed to by PTR will be replaced
	    ! by a list, one for each expansion.  The routine value will
	    ! also be the address of the last element in the list.
	    !
	    NEW_PTR = EXPAND_SEARCH_LIST ( .WORK_FC, .PTR, .LAST_PTR ) ;

	IF .NEW_PTR NEQ 0
	THEN PTR = .NEW_PTR
	ELSE
	    BEGIN
    
	    LOCAL
		STATUS : LONG ;

	    STATUS = $PARSE(FAB=.WORK_FAB) ;
    
	    CHECK_COMMON ( .WORK_FAB, .OUTPUT_SIDE ) ;
    
	    !
	    ! Now copy the parsed FC to the list
	    !
	    IF NOT .STATUS
	    THEN
		BEGIN
		IF .WORK_FAB[FAB$L_STS] EQL RMS$_DNF
		THEN
		    BEGIN
		    WORK_NAM[NAM$V_SYNCHK] = 1 ;	! Parse with no IO
		    STATUS = $PARSE(FAB=.WORK_FAB) ;
		    WORK_NAM[NAM$V_SYNCHK] = 0 ;
		    END ;
		IF NOT .STATUS
		THEN
		    FILE_ERROR(BACKUP$_PARSE, .WORK_FAB,
		               .WORK_FAB[FAB$L_STS], .WORK_FAB[FAB$L_STV]);
		END ;

	    IF (.QUAL[QUAL_INCR] AND .OUTPUT_SIDE) 
	    THEN
		COPY_FC ( .WORK_FC, .FC, 
			  .WORK_FAB[FAB$B_FNS], .WORK_FAB[FAB$L_FNA] )
	    ELSE
		COPY_FC ( .WORK_FC, .FC, 
			  .WORK_NAM[NAM$B_ESL], .WORK_NAM[NAM$L_ESA] ) ;
	
	    ! Set up expanded-string descriptors.
	    !
	    BUILD_QUAL_DESC ( .PTR, .NAM ) ;

	    END ;
	END;


    ! Get next list element
    !
    LAST_PTR = .PTR ;
    PTR = .PTR[QUAL_NEXT];
    END;


IF .OUTPUT_SIDE
THEN
    BEGIN
    QUAL[QUAL_OF11] = .CHK_FLAGS[CHK_FLAGS_F11];
    QUAL[QUAL_OSAV] = .CHK_FLAGS[CHK_FLAGS_SAV];
    END
ELSE
    BEGIN
    QUAL[QUAL_IF11] = .CHK_FLAGS[CHK_FLAGS_F11];
    QUAL[QUAL_ISAV] = .CHK_FLAGS[CHK_FLAGS_SAV];
    END;

!
! Clean up our work space.
! First deallocate all of the RNAM's
!
NAM = .WORK_NAM[NAM$L_RLF] ;
WHILE .NAM NEQ 0 DO
    BEGIN
    PTR = .NAM[NAM$L_RLF] ;
    IF .NAM[NAM$L_RSA] NEQ 0
    THEN
	FREE_VM ( .NAM[NAM$B_RSS], .NAM[NAM$L_RSA] ) ;
    FREE_VM ( NAM$C_BLN, .NAM ) ;
    NAM = .PTR ;
    END ;

!
! now the FC
!
IF .WORK_FAB[FAB$L_FNA] NEQ 0
THEN
    FREE_VM ( .WORK_FAB[FAB$B_FNS], .WORK_FAB[FAB$L_FNA] ) ;
FREE_VM ( FC_S_AREA, .WORK_FC ) ;

END;


%SBTTL 'COMMAND - main command parser'
GLOBAL ROUTINE COMMAND: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the command parser.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MACRO

	! Generate static string descriptors.
	!
	SD[A]=
	    BIND %NAME('SD_', A) = $DESCRIPTOR(A) %;


	! Generate the static descriptors.
	!
	SD(
	    '$LINE',
	    'ANALYZE',
	    'BACKUP',
	    'BEFORE',
	    'BLOCK_SIZE',
	    'BRIEF',
	    'BUFFER_COUNT',
	    'COMMENT',
	    'COMPARE',
	    'CONFIRM',
	    'CRC',
	    'CREATED',
	    'DELETE',
	    'DENSITY',
	    'ENCRYPT',
	    'EXCLUDE',
	    'EXPIRED',
	    'FAST',
	    'FULL',
	    'GROUP_SIZE',
	    'IGNORE',
	    'IMAGE',
	    'INCREMENTAL',
	    'INITIALIZE',
	    'INPUTS',
	    'INTERCHANGE',
	    'JOURNAL',
	    'LABEL',
	    'LIST',
	    'LOG',
	    'MODIFIED',
	    'NEW_VERSION',
	    'OUTPUTS',
	    'OVERLAY',
	    'OWNER_UIC',
	    'PHYSICAL',
	    'PROTECTION',
	    'RECORD',
	    'REPLACE',
	    'REWIND',
	    'SAVE_SET',
	    'SELECT',
	    'SINCE',
	    'TRUNCATE',
	    'VERIFY',
	    'VOLUME');

MACRO
	SD_ENCRYPT_NAME = $DESCRIPTOR('ENCRYPT.NAME') %,
	SD_ENCRYPT_ALGO = $DESCRIPTOR('ENCRYPT.ALGORITHM') %,
	SD_ENCRYPT_VALU = $DESCRIPTOR('ENCRYPT.VALUE') %;

LITERAL
	MAX_STRING=	1024;		! Maximum string value
LOCAL
	BUFFER:		VOLATILE BBLOCK[MAX_STRING+2],
					! Buffer for string value
	STATUS,				! Status variable
	INIT_STATUS,			! CLI status for INITIALIZE qualifier
	VALUE,				! Buffer for converted numerics
	DESC:		BBLOCK[8],	! Local descriptor
	DESC2:		BBLOCK[8],	! Second local descriptor
	LAST:		REF BBLOCK;	! Pointer to last value block


! Execute services to get information needed by the utility.
!
IF
    BEGIN
    IF .COM_FLAGS[COM_STANDALONE]
    THEN TRUE
    ELSE IF $GETDVI(
	DEVNAM=$DESCRIPTOR('SYS$COMMAND'),
	ITMLST=
	    UPLIT(
		WORD(4, DVI$_DEVCLASS), DEVCLASS, 0,
		0))
    THEN
	BEGIN
	$WAITFR(EFN=0);
	.DEVCLASS EQL DC$_TERM
	OR .DEVCLASS EQL DC$_MAILBOX
	END
    ELSE
	FALSE
    END
THEN
    COM_FLAGS[COM_INTERACT] = TRUE;


$GETJPI(ITMLST=
    UPLIT(
	WORD(4, JPI$_UIC), JPI_UIC, 0,
	WORD(12, JPI$_USERNAME), JPI_USERNAME, 0,
	WORD(8, JPI$_CURPRIV), JPI_CURPRIV, 0,
	0));
$GETSYI(ITMLST=
    UPLIT(
	WORD(4, SYI$_VERSION), SYI_VERSION, 0,
	WORD(4, SYI$_SID), SYI_SID, 0,
	0));
$GETTIM(TIMADR=JPI_DATE);
DESC[DSC$W_LENGTH] = MAX_STRING;
DESC[DSC$B_DTYPE] = 0;
DESC[DSC$B_CLASS] = 0;
DESC[DSC$A_POINTER] = BUFFER[VAR_BODY];
STATUS = $TRNLOG(
    LOGNAM=$DESCRIPTOR('SYS$NODE'),
    RSLLEN=BUFFER[VAR_LENGTH],
    RSLBUF=DESC);
IF .STATUS AND .STATUS NEQ SS$_NOTRAN
    THEN PRESERVE_STRING(BUFFER, JPI_NODE_DESC);


! Initialize descriptor to describe the string buffer as a PL/I varying string.
! Initialize second descriptor to describe the body portion -- the length will
! be filled in as necessary.
!
DESC[DSC$W_MAXSTRLEN] = MAX_STRING;
DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
DESC[DSC$B_CLASS] = DSC$K_CLASS_VS;
DESC[DSC$A_POINTER] = BUFFER;
DESC2[DSC$W_LENGTH] = 0;
DESC2[DSC$B_DTYPE] = DSC$K_DTYPE_T;
DESC2[DSC$B_CLASS] = DSC$K_CLASS_S;
DESC2[DSC$A_POINTER] = BUFFER[VAR_BODY];


! Get the command.
!
CLI$GET_VALUE(SD_$LINE, DESC);
PRESERVE_STRING(BUFFER, QUAL[QUAL_CMD_DESC]);


! Get the /ANALYZE qualifier.
!
QUAL[QUAL_ANAL] = CLI$PRESENT(SD_ANALYZE);


! Get the /BACKUP qualifier.
!
QUAL[QUAL_BACK] = CLI$PRESENT(SD_BACKUP);


! Get the /BEFORE qualifier.
!
IF CLI$GET_VALUE(SD_BEFORE, DESC)
THEN
    BEGIN
    QUAL[QUAL_BEFO] = TRUE;
    IF CALL_TPARSE(BUFFER, BAK_STATES, BAK_KEYS)
    THEN
	QUAL[QUAL_BEFO_BACK] = TRUE
    ELSE
	BEGIN
	DESC2[DSC$W_LENGTH] = .BUFFER[VAR_LENGTH];
	IF NOT LIB$CVT_TIME(DESC2, QUAL[QUAL_BEFO_VALUE])
	    THEN SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_BEFORE);
	END;
    END;


! Get the /BLOCK_SIZE qualifier.
!
IF CLI$GET_VALUE(SD_BLOCK_SIZE, DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(.BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], VALUE)
	THEN
	    TRUE
	ELSE
	    .VALUE - 2048 GTRU 65535 - 2048 ! 2048 <= N <= 65535
	END
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_BLOCK_SIZE);
    QUAL[QUAL_BLOC] = TRUE;
    QUAL[QUAL_BLOC_VALUE] = .VALUE;
    END;


! Get the /BRIEF qualifier.
!
CLI$PRESENT(SD_BRIEF);


! Get the /BUFFER_COUNT qualifier.
!
IF CLI$GET_VALUE(SD_BUFFER_COUNT, DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(.BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], VALUE)
	THEN
	    TRUE
	ELSE
	    .VALUE - 2 GTRU 5 - 2 ! 2 <= N <= 5
	END
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_BUFFER_COUNT);
    QUAL[QUAL_BUFF] = TRUE;
    QUAL[QUAL_BUFF_VALUE] = .VALUE;
    END;


! Get the /COMMENT qualifier.
!
QUAL[QUAL_COMM] = CLI$GET_VALUE(SD_COMMENT, DESC);
PRESERVE_STRING(BUFFER, QUAL[QUAL_COMM_DESC]);


! Get the /COMPARE qualifier.
!
QUAL[QUAL_COMP] = CLI$PRESENT(SD_COMPARE);


! Get the /CONFIRM qualifier.
!
QUAL[QUAL_CONF] = CLI$PRESENT(SD_CONFIRM);


! Get the /CRC qualifier.
!
QUAL[QUAL_CRC] = CLI$PRESENT(SD_CRC);


! Get the /CREATED qualifier.
!
QUAL[QUAL_CREA] = CLI$PRESENT(SD_CREATED);


! Get the /DELETE qualifier.
!
QUAL[QUAL_DELE] = CLI$PRESENT(SD_DELETE);


! Get the /DENSITY qualifier.
!
IF CLI$GET_VALUE(SD_DENSITY, DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(.BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], VALUE)
	THEN
	    TRUE
	ELSE
	    SELECTONE .VALUE OF
		SET
		[ 800]: (QUAL[QUAL_DENS_VALUE] = MT$K_NRZI_800; FALSE);
		[1600]: (QUAL[QUAL_DENS_VALUE] = MT$K_PE_1600;  FALSE);
		[6250]: (QUAL[QUAL_DENS_VALUE] = MT$K_GCR_6250; FALSE);
		[OTHERWISE]: TRUE;
		TES
	END
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_DENSITY);
    QUAL[QUAL_DENS] = TRUE;
    END;


! Get the /ENCRYPT qualifier.
!
QUAL[QUAL_SS_ENCRYP] = CLI$PRESENT(SD_ENCRYPT);
IF .QUAL[QUAL_SS_ENCRYP]
THEN
BEGIN
    IF CRYPTO_INIT EQLA 0
    THEN
	SIGNAL(BACKUP$_ENCNOTSUP, 3, .BUFFER[VAR_LENGTH], 
    		BUFFER[VAR_BODY], SD_ENCRYPT);
    !
    ! Obtain the key name if present
    !
    IF CLI$GET_VALUE(SD_ENCRYPT_NAME,DESC)
    THEN
	PRESERVE_STRING(BUFFER,QUAL[QUAL_CRYP_USERKEY]);
    !
    ! Obtain the algorithm name.
    !
    IF CLI$GET_VALUE(SD_ENCRYPT_ALGO, DESC)
    THEN
	PRESERVE_STRING(BUFFER,QUAL[QUAL_CRYP_USERALG])
    ELSE
	!
	! Cram the default algorithm name string
	!
	BEGIN
	BBLOCK [ QUAL[QUAL_CRYP_USERALG ] ,DSC$B_DTYPE] = DSC$K_DTYPE_T ;
	BBLOCK [ QUAL[QUAL_CRYP_USERALG ] ,DSC$B_CLASS] = DSC$K_CLASS_S ;
	BBLOCK [ QUAL[QUAL_CRYP_USERALG ] ,DSC$W_LENGTH] = 6 ;
	BBLOCK [ QUAL[QUAL_CRYP_USERALG ] ,DSC$A_POINTER] = GET_VM(6) ;
	CH$MOVE(6,PLIT('DESCBC'),
		.BBLOCK[ QUAL[QUAL_CRYP_USERALG], DSC$A_POINTER ])
	END;
    !
    ! Obtain one or more key values if present
    !
    WHILE CLI$GET_VALUE(SD_ENCRYPT_VALU, DESC) DO
	BEGIN
	LOCAL
	    VALU: REF BBLOCK;
	VALU = GET_ZERO_VM(QUAL_S_ENCV) ;
	PRESERVE_STRING(BUFFER,VALU[QUAL_ENVA_DESC]) ;
	VALU[QUAL_ENVA_LINK] = .QUAL[QUAL_CRYP_VLIST] ;
	QUAL[QUAL_CRYP_VLIST] = .VALU ;
	END;
END;
! Get the /EXCLUDE qualifier.
!
LAST = 0;
WHILE CLI$GET_VALUE(SD_EXCLUDE, DESC) DO
    BEGIN
    LOCAL
	EXCL:	REF BBLOCK;

    QUAL[QUAL_EXCL] = TRUE;
    EXCL = GET_ZERO_VM(QUAL_S_EXCL);
    IF .LAST EQL 0
	THEN QUAL[QUAL_EXCL_LIST] = .EXCL
	ELSE LAST[QUAL_NEXT] = .EXCL;
    LAST = .EXCL;
    PARSE_EXC_SEL(BUFFER, SD_EXCLUDE, EXCL[QUAL_EXCL_DESC]);
    END;


! Get the /EXPIRED qualifier.
!
QUAL[QUAL_EXPI] = CLI$PRESENT(SD_EXPIRED);


! Get the /FAST qualifier.
!
QUAL[QUAL_FAST] = CLI$PRESENT(SD_FAST);


! Get the /FULL qualifier.
!
QUAL[QUAL_FULL] = CLI$PRESENT(SD_FULL);


! Get the /GROUP_SIZE qualifier.
!
IF CLI$GET_VALUE(SD_GROUP_SIZE, DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(.BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], VALUE)
	THEN
	    TRUE
	ELSE
	    .VALUE GTRU 100
	END
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_GROUP_SIZE);
    QUAL[QUAL_GROU] = TRUE;
    QUAL[QUAL_GROU_VALUE] = .VALUE;
    END;


! Get the /IGNORE qualifier.
!
WHILE CLI$GET_VALUE(SD_IGNORE, DESC) DO
    BEGIN
    TPA_FLAGS = 0;
    IF NOT CALL_TPARSE(BUFFER, IGN_STATES, IGN_KEYS)
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_IGNORE);
    IF .TPA_FLAGS[TPA_NOBACKUP] THEN QUAL[QUAL_IGNO_NOBA] = TRUE;
    IF .TPA_FLAGS[TPA_INTERLOCK] THEN QUAL[QUAL_IGNO_INTE] = TRUE;
    END;


! Get the /IMAGE qualifier.
!
QUAL[QUAL_IMAG] = CLI$PRESENT(SD_IMAGE);


! Get the /INCREMENTAL qualifier.
!
QUAL[QUAL_INCR] = CLI$PRESENT(SD_INCREMENTAL);


! Get the /INITIALIZE qualifier. It defaults to TRUE if the output
! is not a save set.
!
INIT_STATUS = CLI$PRESENT(SD_INITIALIZE);
QUAL[QUAL_INIT] = .INIT_STATUS;



! Get the /INTERCHANGE qualifier.
!
QUAL[QUAL_INTE] = CLI$PRESENT(SD_INTERCHANGE);


! Get the /JOURNAL qualifier.
!
IF CLI$PRESENT(SD_JOURNAL)
THEN
    BEGIN
    QUAL[QUAL_JOUR] = TRUE;
    CLI$GET_VALUE(SD_JOURNAL, DESC);
    QUAL[QUAL_JOUR_FC] = GET_FC(BUFFER);
    END;


! Get the /LABEL qualifier.
!
LAST = 0;
WHILE CLI$GET_VALUE(SD_LABEL, DESC) DO
    BEGIN
    LOCAL
	LABE:	REF BBLOCK;

    IF .BUFFER[VAR_LENGTH] GTRU 12
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_LABEL);
    QUAL[QUAL_LABE] = TRUE;
    LABE = GET_ZERO_VM(QUAL_S_LABE);
    IF .LAST EQL 0
	THEN QUAL[QUAL_LABE_LIST] = .LABE
	ELSE LAST[QUAL_NEXT] = .LABE;
    LAST = .LABE;
    CH$COPY(
	.BUFFER[VAR_LENGTH], BUFFER[VAR_BODY],
	%C' ',
	12, LABE[QUAL_LABE_VALUE]);
    END;


! Get the /LIST qualifier.
!
IF CLI$PRESENT(SD_LIST)
THEN
    BEGIN
    QUAL[QUAL_LIST] = TRUE;
    CLI$GET_VALUE(SD_LIST, DESC);
    QUAL[QUAL_LIST_FC] = GET_FC(BUFFER);
    END;


! Get the /LOG qualifier.
!
QUAL[QUAL_LOG] = CLI$PRESENT(SD_LOG);


! Get the /MODIFIED qualifier.
!
QUAL[QUAL_MODI] = CLI$PRESENT(SD_MODIFIED);


! Get the /NEW_VERSION qualifier.
!
QUAL[QUAL_NEWV] = CLI$PRESENT(SD_NEW_VERSION);


! Get the /OVERLAY qualifier.
!
QUAL[QUAL_OVER] = CLI$PRESENT(SD_OVERLAY);


! Get the /PHYSICAL qualifier.
!
QUAL[QUAL_PHYS] = CLI$PRESENT(SD_PHYSICAL);


! Get the /RECORD qualifier.
!
QUAL[QUAL_RECO] = CLI$PRESENT(SD_RECORD);


! Get the /REPLACE qualifier.
!
QUAL[QUAL_REPL] = CLI$PRESENT(SD_REPLACE);


! Get the /REWIND qualifier.
!
QUAL[QUAL_REWI] = CLI$PRESENT(SD_REWIND);


! Get the /SELECT qualifier.
!
LAST = 0;
WHILE CLI$GET_VALUE(SD_SELECT, DESC) DO
    BEGIN
    LOCAL
	SELE:	REF BBLOCK;

    QUAL[QUAL_SELE] = TRUE;
    SELE = GET_ZERO_VM(QUAL_S_SELE);
    IF .LAST EQL 0
	THEN QUAL[QUAL_SELE_LIST] = .SELE
	ELSE LAST[QUAL_NEXT] = .SELE;
    LAST = .SELE;
    PARSE_EXC_SEL(BUFFER, SD_SELECT, SELE[QUAL_SELE_DESC]);
    END;


! Get the /SINCE qualifier.
!
IF CLI$GET_VALUE(SD_SINCE, DESC)
THEN
    BEGIN
    QUAL[QUAL_SINC] = TRUE;
    IF CALL_TPARSE(BUFFER, BAK_STATES, BAK_KEYS)
    THEN
	QUAL[QUAL_SINC_BACK] = TRUE
    ELSE
	BEGIN
	DESC2[DSC$W_LENGTH] = .BUFFER[VAR_LENGTH];
	IF NOT LIB$CVT_TIME(DESC2, QUAL[QUAL_SINC_VALUE])
	    THEN SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_SINCE);
	END;
    END;


! Get the /TRUNCATE qualifier.
!
QUAL[QUAL_TRUN] = CLI$PRESENT(SD_TRUNCATE);


! Get the /VERIFY qualifier.
!
QUAL[QUAL_VERI] = CLI$PRESENT(SD_VERIFY);


! Get the /VOLUME qualifier.
!
IF CLI$GET_VALUE(SD_VOLUME, DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(.BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], VALUE)
	THEN
	    TRUE
	ELSE
	    .VALUE - 1 GTRU 255 - 1 ! 1 <= N <= 255
	END
    THEN
	SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_VOLUME);
    QUAL[QUAL_VOLU] = TRUE;
    QUAL[QUAL_VOLU_VALUE] = .VALUE;
    END;


! Get the input parameter, and its local qualifiers.
!
LAST = 0;
WHILE CLI$GET_VALUE(SD_INPUTS, DESC) DO
    BEGIN
    LOCAL
	INPU:	REF BBLOCK;


    INPU = GET_ZERO_VM(QUAL_S_INPU);
    IF .LAST EQL 0
	THEN QUAL[QUAL_INPU_LIST] = .INPU
	ELSE LAST[QUAL_NEXT] = .INPU;
    LAST = .INPU;


    INPU[QUAL_PARA_FC] = GET_FC(BUFFER);


    ! Get the /OWNER_UIC qualifier.
    !
    IF CLI$PRESENT(SD_OWNER_UIC)
    THEN
	BEGIN
	QUAL[QUAL_I_OWNE] = TRUE;
	IF NOT CLI$GET_VALUE(SD_OWNER_UIC, DESC)
	THEN
	    BEGIN
	    QUAL[QUAL_I_OWN_VALU] = .JPI_UIC;
	    QUAL[QUAL_I_OWN_WGRP] = FALSE;
	    QUAL[QUAL_I_OWN_WMEM] = FALSE;
	    END
	ELSE
	    BEGIN
	    TPA_FLAGS = 0;
	    IF NOT CALL_TPARSE(BUFFER, UIC_STATES, UIC_KEYS)
	    THEN
	        SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_OWNER_UIC);
	    IF .CONVERTED_UIC<16,16> EQL UIC$K_WILD_GROUP
	    THEN
		BEGIN
		TPA_FLAGS[TPA_WGROUP] = TRUE;
		CONVERTED_UIC<16,16> = 0;
		END;
	    IF .CONVERTED_UIC<0,16> EQL UIC$K_WILD_MEMBER
	    THEN
		BEGIN
		TPA_FLAGS[TPA_WMEMBER] = TRUE;
		CONVERTED_UIC<0,16> = 0;
		END;
	    QUAL[QUAL_I_OWN_VALU] = .CONVERTED_UIC;
	    QUAL[QUAL_I_OWN_WGRP] = .TPA_FLAGS[TPA_WGROUP];
	    QUAL[QUAL_I_OWN_WMEM] = .TPA_FLAGS[TPA_WMEMBER];
	    END;
	END;


    ! Get the /SAVE_SET qualifier.  The rightmost explicit specification
    ! applies.
    !
    STATUS = CLI$PRESENT(SD_SAVE_SET);
    IF .STATUS EQL CLI$_LOCPRES OR .STATUS EQL CLI$_LOCNEG
	THEN QUAL[QUAL_I_SAVE] = .STATUS;
    END;


! Get the output parameter, and its local qualifiers.
!
LAST = 0;
WHILE CLI$GET_VALUE(SD_OUTPUTS, DESC) DO
    BEGIN
    LOCAL
	OUTP:	REF BBLOCK;


    OUTP = GET_ZERO_VM(QUAL_S_OUTP);
    IF .LAST EQL 0
	THEN QUAL[QUAL_OUTP_LIST] = .OUTP
	ELSE LAST[QUAL_NEXT] = .OUTP;
    LAST = .OUTP;


    OUTP[QUAL_PARA_FC] = GET_FC(BUFFER);


    ! Get the /OWNER_UIC qualifier.
    !
    IF CLI$PRESENT(SD_OWNER_UIC)
    THEN
	BEGIN
	IF NOT CLI$GET_VALUE(SD_OWNER_UIC, DESC)
	THEN
	    BEGIN
	    QUAL[QUAL_O_OWN_VALU] = 0;
	    QUAL[QUAL_O_OWN_DEFA] = FALSE;
	    QUAL[QUAL_O_OWN_ORIG] = TRUE;
	    QUAL[QUAL_O_OWN_PARE] = FALSE;
	    QUAL[QUAL_O_OWN_UIC] = FALSE;
	    END
	ELSE
	    BEGIN
	    TPA_FLAGS = 0;
	    IF
		BEGIN
		IF NOT CALL_TPARSE(BUFFER, OWN_STATES, OWN_KEYS)
		THEN
		    TRUE
		ELSE
		    .CONVERTED_UIC<16,16> EQL UIC$K_WILD_GROUP OR
		    .CONVERTED_UIC<0,16> EQL UIC$K_WILD_MEMBER
		END
	    THEN
		SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_OWNER_UIC);
	    QUAL[QUAL_O_OWN_VALU] = .CONVERTED_UIC;
	    QUAL[QUAL_O_OWN_DEFA] = .TPA_FLAGS[TPA_DEFAULT];
	    QUAL[QUAL_O_OWN_ORIG] = .TPA_FLAGS[TPA_ORIGINAL];
	    QUAL[QUAL_O_OWN_PARE] = .TPA_FLAGS[TPA_PARENT];
	    QUAL[QUAL_O_OWN_UIC] = .TPA_FLAGS[TPA_UIC];
	    END;
	END;


    ! Get the /PROTECTION qualifier.
    !
    IF CLI$PRESENT(SD_PROTECTION)
    THEN
	BEGIN
	LOCAL
	    DEFAULT_PROT;

	QUAL[QUAL_PROT] = TRUE;
	TPA_PROTECTION = 0;
	WHILE CLI$GET_VALUE(SD_PROTECTION, DESC) DO
	    BEGIN
	    IF NOT CALL_TPARSE(BUFFER, PRO_STATES, PRO_KEYS)
	    THEN
		SIGNAL(BACKUP$_INVQUAVAL, 3, .BUFFER[VAR_LENGTH], BUFFER[VAR_BODY], SD_PROTECTION);
	    END;


	DEFAULT_PROT = %X'FF00';	! S:RWED,O:RWED,G,W
	IF NOT .COM_FLAGS[COM_STANDALONE] THEN SYS$SETDFPROT(0, DEFAULT_PROT);
	QUAL[QUAL_PROT_VALUE] =
	    (.DEFAULT_PROT AND NOT .TPA_PROTECTION[1]) OR
	    (.TPA_PROTECTION[1] AND NOT .TPA_PROTECTION[0]);
	END;


    ! Get the /SAVE_SET qualifier.  The rightmost explicit specification
    ! applies.
    !
    STATUS = CLI$PRESENT(SD_SAVE_SET);
    IF .STATUS EQL CLI$_LOCPRES OR .STATUS EQL CLI$_LOCNEG
	THEN QUAL[QUAL_O_SAVE] = .STATUS;
    END;


! Indicate completion of parsing.
!
IF .COM_FLAGS[COM_STANDALONE] THEN CLI$END_PARSE();


! Check the input and output lists.
!
IF .QUAL[QUAL_INPU_LIST] EQL 0 AND NOT .QUAL[QUAL_JOUR]
    THEN SIGNAL(BACKUP$_LISINPSAV);
CHECK( QUAL[QUAL_INPU_LIST], FALSE );
CHECK( QUAL[QUAL_OUTP_LIST], TRUE );


! Get a verification file context area if required.
!
IF .QUAL[QUAL_VERI] AND (.QUAL[QUAL_OSAV] OR .QUAL[QUAL_ISAV])
    THEN VERIFY_FAB = GET_FC(UPLIT WORD(0));


! Postprocess the command qualifiers.
!
IF NOT .QUAL[QUAL_OSAV]
AND .INIT_STATUS EQL CLI$_ABSENT
THEN QUAL[QUAL_INIT] = TRUE;

IF .COM_FLAGS[COM_STANDALONE]
THEN
    BEGIN
    QUAL[QUAL_IMAG] = TRUE;
    QUAL[QUAL_JOUR] = FALSE;
    END;
IF .QUAL[QUAL_PHYS]
THEN
    BEGIN
    QUAL[QUAL_DELE] = FALSE;
    QUAL[QUAL_IMAG] = FALSE;
    QUAL[QUAL_INCR] = FALSE;
    QUAL[QUAL_JOUR] = FALSE;
    QUAL[QUAL_RECO] = FALSE;
    END;
IF .QUAL[QUAL_IMAG]
THEN
    BEGIN
    QUAL[QUAL_FAST] = TRUE;
    QUAL[QUAL_INCR] = FALSE;
	END 
ELSE
    QUAL[QUAL_VOLU] = FALSE;
!
! Don't support encryption of disk image copy

IF .QUAL[QUAL_OF11] AND .QUAL[QUAL_IF11] AND .QUAL[QUAL_SS_ENCRYP] 
THEN
    BEGIN
    QUAL[QUAL_SS_ENCRYP] = FALSE;	! No saveset encryption for image copy
    SIGNAL(BACKUP$_ENCQUAIGN);		! Tell the user what we've done
    END;

IF .QUAL[QUAL_COMP] THEN QUAL[QUAL_VERI] = FALSE;
IF .QUAL[QUAL_OF11] AND .QUAL[QUAL_VOLU] AND NOT .QUAL[QUAL_INIT]
THEN
    SIGNAL(BACKUP$_CONFQUAL);
IF NOT .QUAL[QUAL_BUFF] THEN QUAL[QUAL_BUFF_VALUE] = 3;
IF NOT .QUAL[QUAL_GROU] THEN QUAL[QUAL_GROU_VALUE] = 10;
IF .QUAL[QUAL_OSAV]
THEN
    BEGIN
    LOCAL
	FAB:		REF BBLOCK,	! Pointer to first output FAB
	BLOC_VALUE;			! Temporary to compute actual blocksize

    FAB = .BBLOCK[.QUAL[QUAL_OUTP_LIST], QUAL_PARA_FC];
    BLOC_VALUE = .QUAL[QUAL_BLOC_VALUE];
    IF NOT .QUAL[QUAL_BLOC]
    THEN
	BEGIN
	IF .BBLOCK[FAB[FAB$L_DEV], DEV$V_SQD]
	    THEN BLOC_VALUE = 8192
	    ELSE BLOC_VALUE = 512*63;
	END;
    BLOC_VALUE = .BLOC_VALUE + 511 AND NOT 511;
    IF .QUAL[QUAL_SS_FILE]
    OR NOT .BBLOCK[FAB[FAB$L_DEV], DEV$V_SQD]
    THEN
	BEGIN
	IF .BLOC_VALUE GTRU 63*512 THEN BLOC_VALUE = 63*512;
	END
    ELSE
	BEGIN
	IF .BLOC_VALUE GTRU 127*512 THEN BLOC_VALUE = 127*512;
	END;

    IF
	.QUAL[QUAL_INTE] AND
	.BBLOCK[FAB[FAB$L_DEV], DEV$V_SQD] AND
	.BLOC_VALUE GTRU 8192
    THEN
	BLOC_VALUE = 8192;

    QUAL[QUAL_BLOC_VALUE] = .BLOC_VALUE;
    END;
END;

%SBTTL 'TPARSE tables'
PSECT
	GLOBAL=	_LIB$KEY0$(NOWRITE,SHARE,PIC,EXECUTE,ALIGN(1),
		ADDRESSING_MODE(LONG_RELATIVE)),
	GLOBAL=	_LIB$STATE$(NOWRITE,SHARE,PIC,EXECUTE,ALIGN(0),
		ADDRESSING_MODE(LONG_RELATIVE));
SWITCHES
	ADDRESSING_MODE(NONEXTERNAL=LONG_RELATIVE);


$INIT_STATE(UIC_STATES, UIC_KEYS);
$STATE( ,
    (TPA$_IDENT,,,,CONVERTED_UIC)
    );
$STATE( ,
    (TPA$_EOS, TPA$_EXIT)
    );


$INIT_STATE(OWN_STATES, OWN_KEYS);
$STATE( ,
    ('DEFAULT',OWN_END,,TPA_M_DEFAULT,TPA_FLAGS),
    ('ORIGINAL',OWN_END,,TPA_M_ORIGINAL,TPA_FLAGS),
    ('PARENT',OWN_END,,TPA_M_PARENT,TPA_FLAGS),
    (TPA$_IDENT,OWN_SET_UIC,,,CONVERTED_UIC)
    );
$STATE (OWN_SET_UIC,
    (TPA$_LAMBDA,OWN_END,,TPA_M_UIC,TPA_FLAGS)
    );
$STATE(OWN_END,
    (TPA$_EOS, TPA$_EXIT)
    );


$INIT_STATE(IGN_STATES, IGN_KEYS);
$STATE( ,
    ('NOBACKUP',,,TPA_M_NOBACKUP,TPA_FLAGS),
    ('INTERLOCK',,,TPA_M_INTERLOCK,TPA_FLAGS)
    );
$STATE( ,
    (TPA$_EOS, TPA$_EXIT)
    );


$INIT_STATE(BAK_STATES, BAK_KEYS);
$STATE( ,
    ('BACKUP',TPA$_EXIT)
    );
$STATE( ,
    (TPA$_EOS, TPA$_EXIT)
    );


$INIT_STATE(PRO_STATES, PRO_KEYS);
$STATE(NEXTPRO,
    ('SYSTEM',SYPR,,%X'000F0000',TPA_PROTECTION),
    ('OWNER', OWPR,,%X'00F00000',TPA_PROTECTION),
    ('GROUP', GRPR,,%X'0F000000',TPA_PROTECTION),
    ('WORLD', WOPR,,%X'F0000000',TPA_PROTECTION)
    );
$STATE(SYPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(SYPR0,
    ('R',SYPR0,,%X'0001',TPA_PROTECTION),
    ('W',SYPR0,,%X'0002',TPA_PROTECTION),
    ('E',SYPR0,,%X'0004',TPA_PROTECTION),
    ('D',SYPR0,,%X'0008',TPA_PROTECTION),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(OWPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(OWPR0,
    ('R',OWPR0,,%X'0010',TPA_PROTECTION),
    ('W',OWPR0,,%X'0020',TPA_PROTECTION),
    ('E',OWPR0,,%X'0040',TPA_PROTECTION),
    ('D',OWPR0,,%X'0080',TPA_PROTECTION),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(GRPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(GRPR0,
    ('R',GRPR0,,%X'0100',TPA_PROTECTION),
    ('W',GRPR0,,%X'0200',TPA_PROTECTION),
    ('E',GRPR0,,%X'0400',TPA_PROTECTION),
    ('D',GRPR0,,%X'0800',TPA_PROTECTION),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(WOPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(WOPR0,
    ('R',WOPR0,,%X'1000',TPA_PROTECTION),
    ('W',WOPR0,,%X'2000',TPA_PROTECTION),
    ('E',WOPR0,,%X'4000',TPA_PROTECTION),
    ('D',WOPR0,,%X'8000',TPA_PROTECTION),
    (TPA$_LAMBDA,ENDPRO)
    );
$STATE(ENDPRO,
    (',',NEXTPRO),
    (TPA$_EOS,TPA$_EXIT)
    );


END
ELUDOM
