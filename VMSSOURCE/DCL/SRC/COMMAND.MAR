	.TITLE	COMMAND - PROCESS NEXT COMMAND
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PROCESS NEXT COMMAND 
;
; D. N. CUTLER  22-MAR-77
;
;  MODIFIED BY:
;
;	V03-018	CWH3018		CW Hobbs		28-Jul-1984
;		Fix HWS0093 to avoid loop on a control/y.
;
;	V03-017	HWS0093		Harold Schultz		23-Jul-1984
;		If interactive and at indirect level zero, unconditionally
;		clear the execute-only procedure flag.
;
;	V03-016	HWS0061		Harold Schultz		19-Apr-1984
;		Restore locked keypad state only after PRC_V_CNTRLY
;		is cleared.
;
;	V03-015	HWS0020		Harold Schultz		06-Mar-1984
;		When parsing a command which begins with a verb, ignore
;		leading blanks when expanding a symbol definition.
;
;	V03-014	HWS0008		Harold Schultz		13-Feb-1984
;		Remove obsolete code for setting up prompt block in PRC.
;
;	V03-013	PCG0015		Peter George		06-Feb-1984
;		Fix EOJ so that it works even if LOGOUT is deleted.
;		Fix bug in force exiting a privileged image.
;
;	V03-012	PCG0014		Peter George		12-Jan-1984
;		Fix typo.
;
;	V03-011	PCG0013		Peter George		03-Jan-1984
;		Set FLUSH bit in flush routine.
;
;	V03-010	PCG0012		Peter George		16-Aug-1983
;		Disable indirection when looking ahead for null nodes.
;
;	V03-009	PCG0011		Peter George		20-Jul-1983
;		Support null node names.
;
;	V03-008	PCG0010		Peter George		15-Jun-1983
;		Fix broken branch.
;		Remove extraneous labels.
;		Remove references to PRC_L_TAB_VEC.
;
;	V03-007	PCG0009		Peter George		27-May-1983
;		Have command dispatch table branch to JMP's.
;
;	V03-006	PCG0008		Peter George		30-Apr-1983
;		Move token sorting routine to DESCRVAL.
;		Clear WRK_B_PARMSUM.
;
;	V03-005	PCG0007		Peter George		01-Apr-1983
;		Move GOTO scanning to GOTO module.
;
;	V03-004	PCG0006		Peter George		15-Feb-1983
;		Update to new structure level.
;		Remove SETBIT WRK_V_NOSTAT in EOD.
;		Clear PTR_L_ENTITY and PTR_B_NUMBER when doing DCL$GENDESCR.
;		Sort new larger PTR blocks.
;		Add DCL$LOOKUP_INTERNAL.
;		Init recall and keypad fields in WRK block.
;
;	V03-003	PCG0005		Peter George		16-Nov-1982
;		Use WRK_C_SCRSTKSIZ and WRK prompt string descriptor.
;
;	V03-002	PCG0004		Peter George		28-Oct-1982
;		Use PRC data structure for prompt string.
;
;	V03-002	PCG0003		Peter George		19-Oct-1982
;		Fix batch logout accvio caused by DCL$ABORT.
;		Use DCL$ABORT for DCL$EOJ.
;
;	V03-001	PCG0002		Peter George		30-Sep-1982
;		Move common command parsing code to DCL$PARSE_COMMAND
;		in PARSENT.  Initialize WRK_L_PROMPTRTN, WRK_B_VALLEV,
;		and WRK_B_CMDOPT.
;--

;
; MACRO LIBRARY CALLS
;
 
	$$CLITABDEF			; DEFINE TABLE STRUCTURES
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	SYMDEF				; DEFINE SYMBOL ENTRY OFFSETS
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	$CLIMSGDEF			; DEFINE ERROR/STATUS VALUES
	$DEVDEF				; DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				; DEFINE RAB OFFSETS

	.PSECT	DCL$ZDATA,BYTE,RD,NOWRT

LOGOUT:	.ASCIC	'LOGOUT'

ROUTINES_LEN = 0

	.MACRO	INTIMAGE NAME
$NAM1$ = ^A/%EXTRACT(0,4,NAME)/!^X80
$NAM2$ = ^A/%EXTRACT(4,4,NAME)/
	.LONG	$NAM1$
	.LONG	$NAM2$
ROUTINES_LEN = ROUTINES_LEN + 8
	.ENDM

ROUTINES:
	INTIMAGES			; GENERATE TABLE OF ROUTINE NAMES

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT


	.SBTTL	PROCESS NEXT COMMAND
;+
; DCL$RESTART - PROCESS NEXT COMMAND
;
; THIS ROUTINE IS THE CENTRAL COMMAND PARSE AND DISPATCH ROUTINE FOR THE
; STARLET DCLS COMMAND LANGUAGE INTERPRETER. IT INITIALIZES FOR THE NEXT
; COMMAND, READS AND PARSES THE COMMAND FOR SYNTACTIC CORRECTNESS, AND THEN
; EXECUTES THE APPROPRIATE IMAGE.
;
; INPUTS:
;
;	FP =	ADDRESS OF WRK STRUCTURE
;	R11 =	ADDRESS OF PRC STRUCTURE
;
; OUTPUTS:
;
;	COMMAND IS READ, PARSED, AND AN IMAGE IS ACTIVATED.
;-
	.ENABL	LSB

DCL$RESTART::				;RESTART ENTRY POINT
	MOVAB	WRK_K_LENGTH(FP),SP	;ALLOCATE COMMAND IMPURE AREA
					;  AND RESET STACK POINTER
	MOVL	FP,R10			;SET BASE ADDRESS OF WRK
	MOVAB	W^DCL$HYPHEN-1,-	;SET TO FORCE INPUT ON NEXT GET
		WRK_L_CHARPTR(R10) 
	BRB	1$			;PROCESS COMMAND


	.SBTTL	PROCESS REST OF COMMAND
;+
; DCL$CMDSTART - PROCESS REST OF COMMAND
;
; THIS ROUTINE IS THE CENTRAL COMMAND PARSE AND DISPATCH ROUTINE FOR THE
; STARLET DCLS COMMAND LANGUAGE INTERPRETER. IT INITIALIZES FOR THE COMPLETION
; OF THE CURRENT COMMAND LINE, READS AND PARSES THE COMMAND FOR SYNTACTIC 
; CORRECTNESS, AND THEN EXECUTES THE APPROPRIATE IMAGE.
;
; INPUTS:
;
;	FP =	ADDRESS OF WRK STRUCTURE
;	R11 =	ADDRESS OF PRC STRUCTURE
;	WRK_L_CHARPTR(FP) =	POINTER INTO COMMAND INPUT BUFFER
;	WRK_G_BUFFER(FP) =	COMMAND EXPANSION BUFFER
;	WRK_G_INPBUF(FP) =	COMMAND INPUT BUFFER
;
; OUTPUTS:
;
;	COMMAND IS READ, PARSED, AND AN IMAGE IS ACTIVATED.
;-

DCL$CMDSTART::				;COMMAND PROCESSING ENTRY POINT
;
; ALLOCATE AND INITIALIZE COMMAND SCRATCH WORK AREA
;
	MOVAB	WRK_K_LENGTH(FP),SP		;ALLOCATE COMMAND IMPURE AREA
						;  AND RESET STACK POINTER
	MOVL	FP,R10				;SET BASE ADDRESS OF WRK
1$:	MOVZBW	PRC_B_PROMPTLEN(R11),-		;SET PROMPT LENGTH
		WRK_W_PMPTLEN(R10)		;
	MOVAB	PRC_W_PMPTCTRL(R11),-		;SET PROMPT ADDRESS
		WRK_L_PMPTADDR(R10)		;
	CLRB	PRC_B_CONTINUE(R11)		;SET REGULAR PROMPT
	TSTL	PRC_L_INDEPTH(R11)		;ARE WE AT COMMAND LEVEL 0?
	BNEQ	2$				;NO, CHECK CRTL-Y FLAGS

	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),5$	;SKIP IF BATCH MODE
	CLRB	PRC_B_EXONLYL(R11)		;CLEAR EX-ONLY FLAG
	BRB	5$				;USE '$ ' PROMPT
2$:	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),5$ ;USE '$ ' IF CONTROL/Y LEVEL
	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),5$ ;  (ALSO IF CTRL/Y JUST HIT)
	MOVB	#^A/_/,PRC_B_CONTINUE(R11)	;NO -- PROMPT STRING = '_$'
5$:	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;SET ADDRESS OF EXPANSION BUFFER
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;SET ADDRESS OF RESULT PARSE TABLE
	MOVAB	DCL$INPUT,WRK_L_READRTN(R10)	;SET RECORD INPUT ROUTINE
	MOVAB	DCL$INPUT,WRK_L_PROMPTRTN(R10)	;SET PROMPT ROUTINE
	MOVAB	DCL$SPECIAL,WRK_L_SPECRTN(R10)	;SET SPECIAL PROCESSING ROUTINE
	MOVAB	DCL$CHARERROR,WRK_L_ERRORRTN(R10) ;SET ERROR HANDLER ROUTINE
	MOVAB	DCL$ERRORMSG,WRK_L_SIGNALRTN(R10) ;SET ERROR SIGNALING ROUTINE
	CLRW	WRK_W_FLAGS(R10)		;RESET COMMAND FLAGS
	CLRB	WRK_B_VALLEV(R10)		;RESET VALUE LEVEL
	CLRB	WRK_B_CMDOPT(R10)		;RESET OPTION NUMBER
	CLRL	WRK_L_RSLEND(R10)		;ZERO ADDR OF LAST TOKEN DESC
	CLRL	WRK_L_QUABLK(R10)		;ZERO QUABLK
	CLRL	WRK_L_PROPTR(R10)		;ZERO PROPTR
	CLRL	WRK_L_IMAGE(R10)		;ZERO ADDRESS OF IMAGE NAME
	CLRL	WRK_L_PAROUT(R10)		;ZERO PAROUT
	CLRB	WRK_B_MINPARM(R10)		;ZERO MINPARM
	CLRB	WRK_B_MAXPARM(R10)		;ZERO MAXPARM
	CLRB	WRK_B_PARMCNT(R10)		;ZERO PARMCNT
	CLRB	WRK_B_PARMSUM(R10)		;ZERO PARMSUM
	BICW	#PRC_M_DISABL!-			;RE-ENABLE CONTROL Y/C'S
		PRC_M_IND,PRC_W_FLAGS(R11)	;RE-ENABLE @ PROCESSING
	BICB	#PRC_M_RUNDEF!-			;CLEAR IMAGE RUN DEFAULT FLAG
		PRC_M_FLUSH,PRC_B_FLAGS2(R11)	;RESET FLUSH IN PROGRESS FLAG

;
; RESET INTERACTIVE INPUT CONTROL FIELDS.
;
	CLRB	WRK_B_RECALLCNT(R10)		;ZERO RECALL COMMAND COUNT
	MOVL	PRC_L_RECALLPTR(R11),-		;COPY RECALL PTR
		WRK_L_RECALLPTR(R10)		;

;
; CHECK FOR SPECIAL COMMAND PROCESSING CASES
;	PENDING CONTROL/Y
;	CHAINED COMMAND FROM CALLBACK
;	CHAINED IMAGE FROM CALLBACK
;	PENDING HANGUP
;
; IF CONTROL/Y PENDING, EXECUTE "ON CONTROLY" STATEMENT
;
	BBCC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),11$ ;BRANCH IF NOT CONTROL Y/C
	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED KEYPAD STATE
	CLRB	WRK_G_INPBUF(R10)		;ABORT TWO-PART COMMAND IN PROGRESS
	MOVL	PRC_L_ONCTLY(R11),R1		;GET ADDRESS OF ACTION COMMAND
	BEQL	10$				;BR IF NO ACTION OUTSTANDING
	MOVZBL	(R1)+,R0			;GET THE ADDRESS AND COUNT
	MOVC	R0,(R1),WRK_G_INPBUF(R10) 	;MOVE COMMAND INTO BUFFER
	BRB	15$				;CLEAR GOTO, THEN PROCESS COMMAND
10$:	SETBIT	PRC_V_YLEVEL,PRC_W_FLAGS(R11) 	;SET CONTROL Y/C LEVEL
	BRB	20$

;
; IF CHAINED COMMAND OR CHAINED IMAGE, COPY COMMAND INTO COMMAND BUFFER
; AND DEALLOCATE STORAGE USED BY THE CALLBACK TO HOLD THE COMMAND.
;
11$:	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED KEYPAD STATE
	MOVAQ	PRC_Q_COMMAND(R11),R6		;GET DESCRIPTOR OF COMMAND LINE
	BBSC	#PRC_V_CMD,PRC_B_FLAGS2(R11),13$ ;BRANCH IF USER COMMAND SETUP
	BBCC	#PRC_V_CHAIN,PRC_B_FLAGS2(R11),20$ ;BRANCH IF NOT USER CHAIN
	MOVAQ	PRC_Q_IMAGENAME(R11),R6	;GET DESCRIPTOR OF IMAGE TO INVOKE
	SETBIT	PRC_V_RUNDEF,PRC_B_FLAGS2(R11)	;SET RUN DEFAULT
13$:	MOVC	(R6),@4(R6),WRK_G_INPBUF(R10) 	;SET STRING IN BUFFER
	BSBW	DCL$ALLDEACMD			;GO DEALLOCATE THE SPACE

;
; IF CONTROL IS TO BE TRANSFERED TO AN ON-CONTROLY CONDITION OR A CHAINED
; COMMAND, THEN TERMINATE ANY FORWARD GOTO IN PROGRESS.
;
15$:	MOVAB	WRK_G_INPBUF-1(R10),-		;SET POINTER BEFORE RECORD
		WRK_L_CHARPTR(R10) 
	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),20$;CLEAR GOTO FLAG
	BSBW	DCL$DEALGOTO			;DEALLOCATE GOTO SYMBOL

;
; IF A HANGUP PENDING, THEN ABORT THE PROCESS.
;
20$:	BBC	#PRC_V_HANGUP,PRC_W_FLAGS(R11),22$ ;IF SET, HANGUP PENDING
	BRW	DCL$ABORT			; LOG THE PROCESS OUT

;
; IF A CHAINED IMAGE WAS SPECIFED, THEN PROCESS THE IMAGE IMMEDIATELY AND
; AS A FOREIGN COMMAND.
;
22$:	BBC	#PRC_V_RUNDEF,PRC_B_FLAGS2(R11),30$ ;BRANCH IF NOT CHAIN IMAGE
	BSBW	DCL$MARK			;MARK CURRENT PARSE POSITION
	BRW	FORVERB				;PARSE AS FOREIGN COMMAND

;
; BEGIN PARSING INPUT
;
; IF WE DON'T HAVE A COMMAND LINE YET, THEN FORCE AN INPUT TO HAPPEN. 
; LOOP TO RESTART IF THE INPUT IS NULL.  STRIP OFF THE LEADING '$' 
; IF IT IS PRESENT.
;
30$:	BSBW	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	BEQL	50$			;IF EQL NULL LINE
35$:	CMPB	#^A/$/,R0		;DOLLAR SIGN?
	BNEQ	40$			;IF NEQ NO-PROCESS THE COMMAND
	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;RESET EXPANSION BUFFER POINTER
	BSBW	DCL$MOVCHAR		;PUT DOLLAR SIGN IN BUFFER
	PUSHL	PRC_L_INDCLOCK(R11)	;SAVE CURRENT INDIRECT CHANGE COUNT
	BSBW	DCL$SETNBLK		;POINT AT NEXT NON-BLANK CHARACTER
	BEQL	50$			;BRANCH IF NULL LINE TO DCL$RESTART
	CMPL	PRC_L_INDCLOCK(R11),(SP)+ ;INDIRECT LEVEL CHANGE?
	BNEQ	35$			;IF YES-LOOK FOR LEADING DOLLAR SIGN

;
; GET THE FIRST TOKEN FROM THE COMMAND LINE.  IT SHOULD BE EITHER A VERB, 
; A SYMBOL, OR A LABEL.
;
40$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$GETOKEN		;GET COMMAND VERB, SYMBOL, OR LABEL
	BNEQ	41$			;IF EQL NO TOKEN WAS FOUND
	BRW	NOCOMD			;SIGNAL BAD COMMAND LINE SYNTAX

;
; CHECK FOR COLON TERMINATOR.  IT COULD INDICATE EITHER A LABEL OR A NULL
; NODE.
;
41$:	CLRL	-(SP)			;ASSUME TERMINATOR IS NOT A BLANK
	CMPB	#^A' ',R0		;IS TERMINATOR A BLANK?
	BNEQ	42$			;NO, THEN BRANCH
	INCL	(SP)			;SET BLANK SEEN FLAG
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;TEMPORARILY DISALLOW INDIRECTION
	BSBW	DCL$SETNBLK		   ;PEEK AT NEXT NON-BLANK
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;RESTORE INDIRECTION
42$:	CMPB	#^A':',R0		;LABEL OR STRING EQUATE TERMINATOR?
	BEQL	60$			;BRANCH IF SO
	TSTL	(SP)+			;WAS BLANK SEEN?
	BEQL	43$			;BRANCH IF NO BLANK SEEN
	MOVB	#^A' ',R0		;RESTORE THE BLANK
	BSBW	DCL$BACKUPCHAR		;
43$:	BRW	SYMBOL			;ELSE, VERB OR ASSIGNMENT STATEMENT

;
; IF NULL LINE, THEN GET NEXT COMMAND.
;
50$:	BRW	DCL$RESTART		;GET NEXT COMMAND

;
; LABEL OR STRING ASSIGNMENT
;
; THE FIRST TOKEN WAS TERMINATED BY A ":".  IF IT IS NOT IMMEDIATELY FOLLOWED
; BY A SECOND COLON, I.E., IS A NULL NODE SPEC, IT MUST BE EITHER A
; LABEL OR THE SYMBOL NAME IN A STRING ASSIGNMENT.  WE TEMPORARILY DISALLOW 
; INDIRECTION WHEN PEEKING AT THE NEXT CHARACTER AFTER THE COLON, SO THAT IF 
; AN "@" APPEARS JUST AFTER THE LABEL, WE DON'T GET SHIFTED TO THE NEXT LEVEL 
; BEFORE WE GET A CHANCE TO PUT THE LABEL ENTRY IN THE RIGHT TABLE.
;
60$:	BSBW	DCL$MOVCHAR			;MOVE CHARACTER TO COMMAND BUFFER
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) 	;TEMPORARILY DISALLOW INDIRECTION
	BSBW	DCL$SETCHAR			;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) 	;RESTORE INDIRECTION
	CMPB	#^A/:/,R0			;COLON?
	BEQL	NULLNODE			;IF EQL YES
	TSTL	(SP)+				;RESTORE THE STACK
	CMPB	#^A/=/,R0			;EQUAL SIGN?
	BEQL	80$				;IF EQL YES

;
; LABEL
;
; SAVE THE LABEL IN THE SYMBOL TABLE.  IF THE A LABEL OF THE SAME NAME WAS
; ALREADY FOUND, REPLACE IT WITH THE ONE WE HAVE JUST FOUND.  
;
	BBS	#PRC_V_YLEVEL,-			;IF SET, AT CONTROL Y/C LEVEL
		PRC_W_FLAGS(R11),69$ 		;
	MOVL	PRC_L_INDINPRAB(R11),R0		;DEVICE CHAR SAVED IN CURRENT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R0),65$ 	;IF TRM, ISSUE WARNING MESSAGE
	BBC	#DEV$V_RND,RAB$L_CTX(R0),69$ 	;IF NOT RANDOM DEVICE, IGNORE IT
	DISABLE					;DISABLE CONTROL Y/C AST'S
	BSBW	DCL$ALLOC_LABEL			;ALLOCATE AND INSERT LABEL IN TABLE
	BLBC	R0,130$				;IF LBC ALLOCATION FAILURE
69$:	BRW	DCL$CMDSTART			;START COMMAND OVER
65$:	ERRMSG	NOLBLS				;SIGNAL LABEL NOT ALLOWED HERE
	BRB	69$				;

;
; STRING ASSIGNMENT
;
; WE HAVE DETECTED A ":=" FOLLOWING THE FIRST TOKEN ON THE LINE.
; THEREFORE WE MUST BE PROCESSING A STRING ASSIGNMENT.
;
80$:	BSBW	DCL$EQUATE		;PROCESS STRING EQUATE STATEMENT
	BRB	130$			;
 
;
; NULL NODE SPECIFICATION WAS FOUND.  BACK UP PAST DOUBLE COLONS AND PROCESS
; AS A VERB.
;
NULLNODE:
	BSBW	DCL$BACKUPMOVE		;BACK UP TO END OF VERB NAME
	TSTL	(SP)+			;WAS BLANK SEEN?
	BEQL	SYMBOL			;BRANCH IF NO BLANK SEEN
	MOVB	#^A' ',R0		;RESTORE THE BLANK
	BSBW	DCL$BACKUPCHAR		;

;
; COMMAND VERB, INTEGER ASSIGNMENT, SUBSTRING ASSIGNMENT, OR BITFIELD ASSIGNMENT
;
; THE FIRST TOKEN WAS NOT TERMINATED BY A ":", IT MUST BE EITHER A COMMAND VERB
; OR THE SYMBOL NAME IN AN INTEGER, SUBSTRING, OR BITFIELD ASSIGNMENT.  
;
; PROCESS INTEGER, SUBSTRING, OR BITFIELD ASSIGNMENT 
;
SYMBOL:	CMPB	#^A/[/,R0		;SUBSTRING OF BIT FIELD SUBSTRING ASSIGNMENT?
	BNEQ	120$			;IF NEQ NO
	BSBW	DCL$SUBASSIGN		;PROCESS SUBSTRING OR BIT FIELD ASSIGNMENT
	BRB	130$			;
120$:	CMPB	#^A/=/,R0		;SYMBOL ASSIGNMENT?
	BNEQ	COMMAND			;IF NEQ NO
	BSBW	DCL$EVALUATE		;EVALUATE ARITHMETIC ASSIGNMENT STATEMENT
130$:	BRW	ERROR_EXIT		;

;
; COMMAND VERB
;
; WE HAVE DETERMINED THAT WE ARE PARSING A COMMAND THAT BEGINS WITH A VERB.
; TRANSLATE THE FIRST TOKEN ON THE COMMAND LINE (IF POSSIBLE).
;
COMMAND:PUSHR	#^M<R1,R2>		;SAVE COMMAND VERB PARAMETERS
	BSBW	DCL$SYM_STRING		;SEARCH FOR SYMBOL DEFINITION
	MOVQ	R1,R4			;SAVE VALUE PARAMETERS
	POPR	#^M<R1,R2>		;RESTORE COMMAND VERB PARAMETERS
	TSTL	R4			;SYMBOL DEFINED AND HAVE VALUE?
	BNEQ	135$			;IF NEQ YES
	BRW	PRCVERB			;IF NOT SYMBOL, SEARCH VERB TABLE

;
; THE FIRST TOKEN IS A SYMBOL.  GET ITS VALUE.
;
135$:	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;RESET EXPANSION BUFFER POINTER
	ADDL3	#1,WRK_L_CHARPTR(R10),R6 ;GET CHARACTER POINTER
	CMPB	#^A/ /,(R6)		;ALREADY A BLANK HERE?
	BEQL	140$			;IF EQL YES
	MOVB	#^A/ /,-(R6)		;ELSE INSERT A TRAILING BLANK
140$:	CMPB	#^A/'/,-1(R5)[R4]	;DOES THE SYMBOL END WITH '?
	BNEQ	150$			;IF NEQ NO
	DECL	R4			;ELSE REMOVE THE ' FROM THE SYMBOL
	INCL	R6			; AND REMOVE THE ADDED TRAILING BLANK
150$:	SUBL	R4,R6			;BACK UP OVER SYMBOL'S LENGTH
	SUBL3	#1,R6,WRK_L_CHARPTR(R10) ;STORE NEW CHARACTER POINTER
	MOVC	R4,(R5),(R6)		;MOVE TRANSLATED COMMAND TO INPUT BUFFER
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11)  ;TEMPORARILY DISALLOW INDIRECTION
	BSBW	DCL$SETNBLK		;SKIP OVER LEADING BLANKS
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11)  ;ENABLE INDIRECTION
	TSTB	R0			;COMMAND NOP'D?
	BNEQ	152$			;BR IF NOT
	BRW	DCL$RESTART		;
152$:	CMPB	#^A/@/,R0		;PROCEDURE FILE?
	BNEQ	155$			;IF NEQ NO
	BRW	DCL$CMDSTART		;READ FROM THE COMMAND FILE

;
; IF THE SYMBOL DEFINES A FOREIGN COMMAND, THEN PROCESS IT AS SUCH.
; OTHERWISE, SEARCH THE VERB TABLE FOR THE VERB.
;
155$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	CMPB	#^A/$/,R0		;DOLLAR SIGN?
	BNEQ	CMDVERB			;IF NEQ NO

	.DSABL	LSB

;
; FOREIGN COMMAND
;
; PROCESS THE FILE SPECIFICATION AND THEN PROCESS THE REST OF THE COMMAND
; LINE.
;
FORVERB:				;COME HERE FOR FOREIGN VERBS
	MOVZBL	#PTR_K_PARAMETR,R3	;SET TOKEN CONTEXT OF FILESPEC
	BSBW	DCL$PROCFILE		;PROCESS FILE SPECIFICATION
	BLBC	R0,ERROR		;IF LBC FILE SPECIFICATION ERROR
	SUBL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10) ;UNDO RESULT TOKEN DESCRIPTOR
	MOVQ	R1,-(SP)		;SAVE FILENAME DESCRIPTOR PARAMETERS
	BSBW	PROCFORN		;PROCESS FOREIGN COMMAND
	MOVB	#CLI$K_VERB_FORE,WRK_B_VERBTYP(R10) ;SET FOREIGN COMMAND
	POPR	#^M<R1,R2>		;RESTORE FILENAME DESCRIPTOR PARAMETERS
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3	;SET EXTERNAL IMAGE INDEX
	BRW	EXECEXT			;
 
;
; GET THE TRANSLATED COMMAND VERB
;
CMDVERB:
	BSBW	DCL$GETOKEN		;GET COMMAND VERB TOKEN
	BNEQ	PRCVERB			;PROCEED IF VALID
NOCOMD:	STATUS	NOCOMD			;ERROR IF NULL LINE
ERROR:	BRW	ERROR_EXIT
 
;
; LOOK THE VERB UP IN THE COMMAND TABLES.
;
PRCVERB:
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ;BR IF NOT AT ^Y LEVEL
	BBC	#PSL$V_CURMOD,@PRC_L_SAVAP(R11),10$ ;IF CLR PREVIOUS MODE SUPER
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE "@" FILE RECOGNITION
10$:	MOVL	G^CTL$AG_CLITABLE,R8	;GET ADDRESS OF DATA BASE VECTOR
	BSBW	DCL$SEARCH_VERB		;SEARCH VERB TABLE FOR VERB
	BLBC	R0,ERROR		;BRANCH IF ERROR

;
; IF THE COMMAND IS DEFINED IN THE TABLES AS FOREIGN THEN PERFORM THE SPECIAL 
; COMMAND LINE PROCESSING.
;
; IF IT IS DEFINED AS IMMEDIATE MODE AND THEREFORE, SHOULD BE DISPATCHED 
; IMMEDIATELY, DO IT NOW.  
;
; OTHERWISE, PARSE THE COMMAND PARAMETERS AND QUALIFIERS.
; 
	BBC	#CMD_V_FOREIGN,-		;BRANCH IF NOT FOREIGN
		CMD_W_FLAGS(R8),20$ 		;
	BSBW	PROCFORN			;PROCESS FOREIGN COMMAND
	BRB	BUILD_IMAGE			;PROCESS THE IMAGE NAME

20$:	BBC	#CMD_V_IMMED,CMD_W_FLAGS(R8),30$;BR IF NOT IMMEDIATE
	MOVL	WRK_L_IMAGE(R10),R2		;GET ADDR OF ASCIC ROUTINE NAME
	MOVZBL	(R2)+,R1			;GET COUNT IN R1, ADDRESS IN R2
	BSBW	DCL$LOCATE_INTERNAL		;LOCATE INTERNAL ROUTINE INDEX
	BLBC	R0,ERROR			;BRANCH IF ERROR
	BRB	IMMED				;DISPATCH THE IMMEDIATE COMMAND

30$:	BSBW	DCL$PARSE_COMMAND		;PARSE THE COMMAND QUALS AND PARMS
	CMPL	R0,#CLI$_NOCOMD			;IF CTRL/Z WAS ENTERED,
	BNEQ	40$				;THEN GET A NEW COMMAND
	BRW	DCL$RESTART			;
40$:	BLBC	R0,ERROR			;SIGNAL ANY SYNTAX ERRORS

;
; BUILD THE IMAGE/ROUTINE NAME DESCRIPTOR
;
BUILD_IMAGE:
	MOVL	WRK_L_IMAGE(R10),R2		;GET IMAGE/ROUTINE ASCIC NAME ADDRESS
	MOVZBL	(R2)+,R1			;GET COUNT IN R1, ADDRESS IN R2
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3		;ASSUME EXTERNAL IMAGE 
	BBS	#WRK_V_CLIRTN,-			;BRANCH IF INTERNAL ROUTINE
		WRK_W_FLAGS2(R10),5$		;
	BRB	EXECEXT				;EXECUTE EXTERNAL COMMAND
5$:	BSBW	DCL$LOCATE_INTERNAL		;LOCATE INTERNAL ROUTINE INDEX
	BLBC	R0,ERROR			;BRANCH IF ERROR
 
;
; SORT TOKEN DESCRIPTOR TABLE INTO CMDQUAL,PARM,PARMQUAL ORDER
; FOR INTERNAL CLI ROUTINES TO MAKE GETDVAL PROCESSING EASIER.
;
	PUSHL	R3				;SAVE COMMAND INDEX
	BSBW	DCL$SORT_TOKENS			;SORT DESCRIPTOR TABLE
	POPL	R3				;RESTORE COMMAND INDEX

EXECEXT:
	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND EXECUTION IN PROGRESS
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RESET NEXT TOKEN TO RETRIEVE

;
; INTERNAL COMMAND PARAMETERS:
;
;	R1 = LENGTH OF IMAGE FILENAME (IF ANY).
;	R2 = ADDRESS OF IMAGE FILENAME (IF ANY).
;
;    R8 AND R9 ARE SET UP AFTER THE CONDITIONAL RUNDOWN CALL BELOW
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; IMMEDIATE COMMAND PARAMETERS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
 
IMMED:					;IMMEDIATE COMMAND EXECUTION
	BBC	#PRC_V_PRIV,PRC_B_FLAGS2(R11),10$  ;BR IF UNPRIVILEGED IMAGE

;
; NEED TO RUN DOWN PRIVILEGED IMAGE, BUT ALLOW THE FOLLOWING COMMANDS
;
	CMPB	#IMG_K_CONTINUE & ^X7F,R3	;CONTINUE COMMAND?
	BEQL	10$			;BR IF YES
	CMPB	#IMG_K_SPAWN & ^X7F,R3	;SPAWN COMMAND?
	BEQL	10$			;BR IF YES
	CMPB	#IMG_K_ATTACH & ^X7F,R3	;ATTACH COMMAND?
	BEQL	10$			;BR IF YES
	BBCS	#WRK_V_COMMAND,WRK_W_FLAGS(R10),2$
	BSBW	DCL$FORCEXIT		;RUN DOWN THE PRIVILEGED IMAGE
	BRB	10$			;

2$:	BSBW	DCL$FORCEXIT		;RUN DOWN THE PRIVILEGED IMAGE
	CLRBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10)

;
; SETUP SCRATCH STORAGE FOR USE BY INTERNAL ROUTINES
;
10$:	MOVL	SP,R9			;SET ADDRESS OF SCRATCH STACK
	MOVAB	-WRK_C_SCRSTKSIZ(SP),SP	;ALLOCATE SCRATCH AREA BEFORE STACK
	PUSHAB	(SP)			;BUILD SCRATCH BUFFER DESCRIPTOR
	MOVZWL	#WRK_C_SCRSTKSIZ,-(SP)
	MOVL	SP,R8			;SET ADDRESS OF SCRATCH BUFFER DESCRIPTOR
	BSBB	IMAGECASE		;EXECUTE INTERNAL IMAGE

;
; THE FOLLOWING CODE IS DUPLICATED IN IMAGEXECT FOR EXTERNAL IMAGES
; BECAUSE IT MUST BE DONE BEFORE IMAGE RUNDOWN, NOT AFTERWARDS.
;
ERROR_EXIT:				;ERROR EXIT
	BLBS	R0,10$			;IF LBS SUCCESSFUL COMPLETION
	BSBW	DCL$ERRORMSG		;OUTPUT SYSTEM ERROR MESSAGE
10$:	JSB	DCL$SET_STATUS		;SET COMPLETION STATUS
	BSBW	DCL$FLUSH		;FLUSH COMMAND BUFFER
	BRW	DCL$RESTART		;


	.MACRO	INTIMAGE NAME
	.WORD	XXX$'NAME'-10$
IMG_K_'NAME = $INTIMAGE$
$INTIMAGE$ = $INTIMAGE$ + 1
	.ENDM

IMAGECASE:
	CASEB	R3,#0,#<90$-10$>/2-1
10$:					;BASE ADDRESS OF CASE TABLE
	.LIST	MEB
	INTIMAGES			;GENERATE INTERNAL IMAGE CASE TABLE
	.NLIST	MEB

90$:	MOVZWL	#SS$_ILLSER,R0		;SET SERVICE ERROR
	RSB

	.MACRO	INTIMAGE NAME
XXX$'NAME':	JMP	DCL$'NAME'
IMG_K_'NAME = $INTIMAGE$
$INTIMAGE$ = $INTIMAGE$ + 1
	.ENDM

	.LIST	MEB
	INTIMAGES			;GENERATE INTERNAL IMAGE CASE TABLE
	.NLIST	MEB

	.SBTTL	CALL LOGINOUT TO ABORT THE PROCESS
;----
; DCL$ABORT
;
; CONTROL IS TRANSFERRED HERE TO ABORT THE PROCESS BY CALLING
; THE LOGINOUT IMAGE.  CARE IS TAKEN TO SETUP THE RESULT
; PARSE DESCRIPTORS SO THAT LOGINOUT CAN USE RESULT PARSING
; AS IF LOGOUT WAS GIVEN AS A COMMAND LINE.
;
; INPUTS:
;
;	NONE
;----

DCL$EOJ::
DCL$ABORT::
	MOVAB	WRK_G_RESULT(R10),-	;RESET RESULT ARRAY PTR
		WRK_L_RSLNXT(R10) 	;
	MOVAB	WRK_G_BUFFER(R10),R2	;GET ADDRESS OF EXPANSION BUFFER
	MOVL	R2,WRK_L_EXPANDPTR(R10) ;RESET EXPANSION PTR
	MOVL	#^A'LOGO',(R2)		;STORE VERB INTO BUFFER
	MOVL	#4,R1			;SET LENGTH OF VERB
	MOVAB	LOGOUT,WRK_L_IMAGE(R10)	;SET ROUTINE IN CASE NOT FOUND
	SETBIT	WRK_V_CLIRTN,WRK_W_FLAGS2(R10)
	MOVL	G^CTL$AG_CLITABLE,R8	;GET ADDRESS OF DATA BASE VECTOR
	BSBW	DCL$SEARCH_VERB		;LOCATE COMMAND DEFINITION FOR
					;LOGOUT CLI INTERFACE (IGNORE ERRORS)
	BSBW	DCL$GENEOL		;CREATE AN EOL TOKEN
	BRW	BUILD_IMAGE		;PROCESS LOGOUT COMMAND

	.SBTTL	EOD/DECK COMMANDS
;+
; DCL$EOD/DCL$DECK
;
; THESE COMMANDS ARE PROCESSED BY RMS AND SHOULD NOT BE SEEN BY THE CLI.
; RMS PASSES THEM THROUGH IF THE SYNTAX OR VALUE IS BAD.  ONE CASE IS
; NOT TREATED AS AN ERROR, THAT IS "EOD" ALONE ON A LINE.  THIS COULD
; HAPPEN IF THE STATEMENT WAS ENTERED WITHOUT AN IMAGE RUN.
;-
 
DCL$EOD::				;
	BSBW	DCL$SETNBLK		;LOOK FOR NEXT CHARATER IN LINE
	BNEQ	DCL$DECK		;BR IF NOT A NULL LINE
	STATUS	NORMAL			;SET OK STATUS
	RSB				;
 
DCL$DECK::				;
	STATUS	IVVALU			; ASSUME ERROR WAS INVALID VALUE
	RSB

	.SBTTL	CHECK FOR CONTROL Y/C AST PENDING
;+
; DCL$CHECK_AST - CHECK FOR CONTROL Y/C AST PENDING
;
; THIS ROUTINE IS CALLED TO CHECK FOR A PENDING CONTROL Y/C AST.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF A CONTROL Y/C AST IS PENDING, THEN CONTROL IS TRANSFERED TO THE COMMAND
;	RESTART ENTRY POINT. OTHERWISE CONTROL IS RETURNED TO THE CALLER.
;-
 
	.ENABL	LSB
DCL$CHECK_AST::				;CHECK FOR PENDING CONTROL Y/C AST
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),50$ ;IF CLR, NO CONTROL Y/C REQUEST
10$:	BRW	DCL$RESTART		;

	.SBTTL	ENABLE/DISABLE CONTROL Y/C AST'S
;+
; DCL$DISABLE - DISABLE CONTROL Y/C AST'S
;
; THIS ROUTINE IS CALLED TO DISABLE/ENABLE CONTROL Y/C AST'S.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CONTROL Y/C AST'S ARE DISABLED, THE PREVIOUS ENABLE STATE IS SAVED, AND
;	A CO-ROUTINE CALL IS MADE BACK TO THE CALLER. WHEN CONTROL RETURNS, THE
;	AST STATE IS RESTORED TO ITS VALUE BEFORE THE DISABLE.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL
;-
 
DCL$DISABLE::				;DISABLE CONTROL Y/C AST'S
	PUSHL	(SP)			;COPY RETURN ADDRESS
	MOVZWL	PRC_W_FLAGS(R11),4(SP)	;SAVE PREVIOUS DISABLE STATE
	SETBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	JSB	@(SP)+			;CALL THE CALLER BACK
	BBS	#PRC_V_DISABL,4(SP),40$	;IF SET, AST'S PREVIOUSLY DISABLED
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF SET, AT CONTROL Y/C LEVEL
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	30$			;IF NEQ NO
20$:	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),10$ ;IF SET, CONTROL Y/C REQUEST
30$:	CLRBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;ENABLE CONTROL Y/C AST'S
40$:	POPL	(SP)			;REMOVE PREVIOUS STATE FROM STACK
50$:	RSB				;
	.DSABL	LSB

	.SBTTL	FLUSH COMMAND BUFFER
;+
; DCL$FLUSH - FLUSH COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO READ CHARACTERS FROM THE COMMAND BUFFER UNTIL AN
; END OF LINE IS ENCOUNTERED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	INDIRECT FILE RECOGNITION IS DISABLED AND CHARACTERS ARE READ FROM THE
;	INPUT BUFFER UNTIL AN END OF LINE IS ENCOUNTERED.
;-
 
DCL$FLUSH::				;FLUSH COMMAND BUFFER
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ; IF AT ^Y LEVEL DON'T FLUSH
	MOVL	PRC_L_INDINPRAB(R11),R0	; GET CURRENT INPUT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R0),20$ ; LIKEWISE FOR TERMINALS
	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;SET BUFFER TO RECEIVE ANY CONT. LINES
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
	SETBIT	PRC_V_FLUSH,PRC_B_FLAGS2(R11) ;SET FLUSH IN PROGRESS
10$:	BSBW	DCL$GETCHAR		;GET CHARACTER FROM INPUT BUFFER
	BNEQ	10$			;IF NEQ NOT END OF LINE
	CLRBIT	PRC_V_FLUSH,PRC_B_FLAGS2(R11) ;RESET FLUSH IN PROGRESS FLAG
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE RECOGNITION
20$:	RSB				;

	.SBTTL	PROCESS FOREIGN COMMAND
;---
; PROCFORN - GENERATE RESULT DESCRIPTOR FOR FOREIGN COMMAND LINE
;
; PROCESS FOREIGN COMMAND AND BUILD TOKEN DESCRIPTOR
; FOR THE REST OF THE LINE AFTER THE VERB.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	A TOKEN DESCRIPTOR IS GENERATED FOR THE REST OF THE LINE AND
;	A TOKEN DESCRIPTOR IS GENERATED FOR THE END OF LINE.
;
;---

PROCFORN:				;PROCESS FOREIGN COMMAND
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE INTERPRETATION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	R0,#^A' '		;BLANK?
	BNEQ	5$			;BRANCH IF NO LEADING BLANK
	BSBW	DCL$MOVCHAR		;MOVE BLANK BEFORE MARK
5$:	BSBW	DCL$MARK		;MARK POSITION AFTER FILESPEC & BLANK
10$:	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BNEQ	10$			;UNTIL END OF LINE
	DECL	WRK_L_EXPANDPTR(R10)	;BACKUP OVER EOL CHARACTER
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF REST OF LINE
	MOVQ	R1,R7			;COPY DESCRIPTOR
	CLRL	R4			;CLEAR ITEM NUMBER
	CLRL	R6			;CLEAR FLAGS
	CLRL	R9			;CLEAR ENTITY BLOCK ADDRESS
	MOVZBL	#PTR_K_PARAMETR,R5	;SET ITEM TYPE TO PARAMETER
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE TABLE DESCRIPTOR
	MOVZBL	#PTR_K_ENDLINE,R5	;SET ITEM TYPE TO END OF LINE
	MOVZBL	#1,R7			;SET LENGTH OF ITEM
	MOVL	WRK_L_EXPANDPTR(R10),R8	;SET STARTING ADDRESS OF ITEM
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE INTERPRETATION
	RSB				;


	.SBTTL	GET INTERNAL ROUTINE INDEX
;---
; DCL$LOCATE_INTERNAL - GET INDEX FROM INTERNAL ROUTINE TABLE
;
; THIS ROUTINE SEARCHES THE TABLE OF INTERNAL ROUTINES FOR A SPECIFIED STRING.
; IF FOUND, THE INDEX OF THAT STRING IS RETURNED.
;
; INPUTS:
;
;	R1/R2 = ROUTINE NAME DESCRIPTOR
;
; OUTPUTS:
;
;	R0 = STATUS
;	R3 = INDEX NUMBER
;	R4 IS DESTROYED
;---

DCL$LOCATE_INTERNAL:
	MOVQ	R1,-(SP)		; SAVE R1/R2
	MOVQ	(R2),-(SP)		; GET ROUTINE NAME
	BISB	#^X80,(SP)		; SET HIGH ORDER BIT TO FORCE ROUTINE MATCH
	CMPL	R1,#8			; ROUTINE LENGTH GREATER THAN 8?
	BLEQ	5$			; BRANCH IF NOT
	MOVL	#8,R1			; SET LENGTH EQUAL 8
5$:	MOVL	#ROUTINES_LEN,R4	; SET TABLE LENGTH
	MATCHC	R1,(SP),R4,ROUTINES	; FIND SPECIFIED ROUTINE
	BNEQ	20$			; BRANCH IF NO MATCH
	BICL	#7,R2			; ROUND REMAINING LENGTH UP
	ADDL	#8,R2			;
	SUBL	R2,R4			; CALCULATE RELATIVE POSITION OF MATCH
	ASHL	#-3,R4,R3		; DIVIDE BY 8 TO GET INDEX INTO R3
	MOVL	#1,R0			; SET SUCCESS
10$:	CLRQ	(SP)+			; RESTORE STACK
	MOVQ	(SP)+,R1		; RESTORE R1/R2
	RSB

20$:	MOVL	#CLI$_INVROUT,R0	; SET INVALID ROUTINE STATUS
	BRB	10$			; RETURN

	.END
