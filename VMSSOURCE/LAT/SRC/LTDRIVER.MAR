	.TITLE	LTDRIVER - Local Area Terminal Port Driver
	.IDENT	'V04-000'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

; Do not remove items from this list.  Add X when item is done.
; to be done:
;
; - LATCP should be allowed to specify the Ethernet device.
; - fix slot stop and circuit stop  code for correct message format
;	including reason code and text.
; - transmit two slots/message from host transmit loop.
; - allocate and be able to send additional buffers based about the servers
;	value of XTRABFRs (in START message).
; - send credits in DATA_B slots.
;


;
;****************************************************************************
;*									    *
;*  Copyright (c) 1982, 1984                                                *
;*  by digital equipment corporation, maynard, mass.			    *
;* 									    *
;*  this software is furnished under a license and may be used and  copied  *
;*  only  in  accordance  with  the  terms  of  such  license and with the  *
;*  inclusion of the above copyright notice.  this software or  any  other  *
;*  copies  thereof may not be provided or otherwise made available to any  *
;*  other person.  no title to and ownership of  the  software  is  hereby  *
;*  transferred.							    *
;* 									    *
;*  the information in this software is subject to change  without  notice  *
;*  and  should  not  be  construed  as  a commitment by digital equipment  *
;*  corporation.							    *
;* 									    *
;*  digital assumes no responsibility for the use or  reliability  of  its  *
;*  software on equipment which is not supplied by digital.		    *
;*									    *
;****************************************************************************
;
;++
; Facility:
;
;	VAX/VMS Terminal Driver
;
; Abstract:
;
;	Local Area Terminal Port Driver
;
;	This is an alternate port driver for use with the VMS terminal
;	driver.  It forms the host end of the Local Area Terminal (LAT)
;	protocol and communicates with a LAT concentrator to provide
;	terminal communications on a local area network.
;
;	This driver performs IO using a datalink driver via the FFI
;	mechanism.  Its connection with the datalink driver is controlled
;	by a program called LATCP.
;
;
;
; Authors:
;
;	Bruce Mann
;	Darrell Duffy
;	Joe Marchesani
;	Rich Bailey
;
; Revision history:
;
;	V03-036	RNG0036		Rod Gamache		23-Aug-1984
;		Fix LT$XOFF to recognize when data input stream has been
;		interrupted or whether the call was an asychronous event.
;		Fix problem with XON dropping a character (if AP=2).
;		Fix problem with output slot processing, that incorrectly
;		moved data up in the UCB output buffer area.
;
;	V03-035	RNG0035		Rod Gamache		7-Aug-1984
;		Fix service rating reaching zero.
;
;	V03-034	RNG0034		Rod Gamache		3-Aug-1984
;		Make sure LT UCBs can be deleted by insuring that the
;		Logical UCB pointer is pointing at the LT UCB and that
;		the REFC has gone to zero.
;
;	V03-033	RNG0033		Rod Gamache		2-Aug-1984
;		Set service rating to zero if IJOBLIM is reached, else
;		don't let service rating reach zero.
;		Clear the hangup bit in the ALLOCATE UCB code rather than
;		unit init.
;		Fix code to correctly format a reject slot.
;
;	V03-032	RNG0032		Rod Gamache		31-Jul-1984
;		Change DISCONNECT routine to not use DELETEUCB bit to
;		force $DASSGN code to delete UCBs, since if there are logical
;		UCBs (ie VTs), then the LT UCBs will never get deallocated.
;		Put back code to set HANGUP bit, in DISCONNECT routine.
;
;	V03-031	RNG0031		Rod Gamache		30-Jul-1984
;		Fix previous fix where all uses of CLASS/PORT iterface were
;		not fixed.
;
;	V03-030	RNG0030		Rod Gamache		25-Jul-1984
;		Fix incorrect useage of CLASS/PORT driver interface for the
;		DDCMP CLASS DRIVER. Fix credit check on sending DATA_B slot.
;
;	V03-029	LMP0275		L. Mark Pilant,		24-Jul-1984  15:49
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-028	RNG0028		Rod Gamache		21-May-1984
;		Remove call to SIDELINEUCB which caused LT units to remain
;		"hung". Also fix test of service rating. Change the way
;		LT units are deleted.
;		Change use of history buffer.
;		Remove bug_check generated when UCB state is "halted" on
;		call to LT$DISCONNECT (this happens when user doesn't log
;		in and unit is disconnected).
;		Disable UCB deletion if server is doing a BIND request.
;		Change XOFF and XON routines to save R0, and change number
;		of characters checked for input buffering from 4 to 1.
;
;	V03-027	RNG0027		Rod Gamache		10-May-1984
;		Change LAT Multicast Address from AB-00-03-00-00-00 to
;		09-00-2B-00-00-0F, as per LAT Architecture ECO.
;
;	V03-026	RNG0026		Rod Gamache		18-Apr-1984
;		Make better estimate of service rating on a 782 processor.
;		Always call EXE$DEANONPAGED rather than COM$DRVDEALMEM.
;		Fixup server name length when needed before copying into CSB.
;
;	V03-025	LMP0234		L. Mark Pilant,		17-Apr-1984  14:04
;		Copy the ORB from the template rather than zeroing the new
;		one.
;
;	V03-024	RNG0024		Rod Gamache		9-Apr-1984
;		Add SERVER name to CSB. Count active users on CSB.
;
;	V03-023	LMP0221		L. Mark Pilant,		27-Mar-1984  14:49
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.  Also, allocate and link the ORB into the
;		UCB at creation.  Deallocate it at deletion.
;
;	V04-022	RNG0022		Rod Gamache		22-Mar-1984
;		Modify algorithm that computes the service rating.
;		Use XOFF, XON calls to buffer typeahead data.
;
;	V04-021	RNG0021		Rod Gamache		19-Mar-1984
;		Fix call to CLASS driver's SETUP_UCB routine to not
;		get called for UNIT #0.
;
;	V04-019	RNG0019		Rod Gamache		27-Dec-1983
;		General cleanup for V4 release.
;
;--

	.SBTTL	Global Definitions

	.ENABLE SUPPRESSION

;
;	Global definitions
;

	$LATDEF				; LAT communication area defs
	$ACBDEF				; Ast control block
	$ADPDEF				; Define adapter
	$CRBDEF				; Define crb
	$CXBDEF				; Complex buffer
	$DDBDEF				; Define ddb
	$DEVDEF				; Define device characteristics
	$DPTDEF				; Define dpt
	$DYNDEF				; Dynamic memory block codes
	$FFIDEF				; Fast Interface block
	$FKBDEF				; Fork block definitions
	$IPLDEF				; IPL levels
	$MTXDEF				; Mutex offsets
	$ORBDEF				; Object's Rights Block offsets
	$PCBDEF				; Process control block
	$PHDDEF				; Process header block
	$PRDEF				; Processor register definitions
	$RSNDEF				; Resouce wait codes
	$TQEDEF				; Timer queue elements
	$UCBDEF				; Define ucb
	$VECDEF				; Define vector for crb

	$TTYDEF				; Define terminal driver symbols
	$TTDEF				; Define terminal types
	$TT2DEF				; Define extended characteristics
	$TTYMACS			; Define terminal driver macros
	$TTYDEFS			; Define terminal driver symbols


	.SBTTL	Local Definitions
;
; 	Macros
;
	.MACRO	ALIGN_LONG
	.iif ne <.&3>,	.BLKB  <4-<.&3>> ; align to longword boundary, if needed
	.ENDM	ALIGN_LONG

;
;	Conditional assembly parameters
;

	LT_HISTORY	= 1		; keep history of received/transitted ni frames
;;&&	LT_CRED_CHECK	= 1		; validate credit total for UCBs
;;&&	LT_XMT_CHECK	= 1		; validate transmit frame slots dynamically

;
;	Constants defined for the VMS LAT host implementation
;
	TTY_C_BELL	= 7		; Control_G (^G) ... bell character
	LAT$C_VMS	= 3		; VAX/VMS product type code
	LAT$C_VMS_VER	= 4		; Part of VAX/VMS V4.0
	LAT$C_IPL	= 8		; Fork IPL to synchronize this driver
	LAT$C_PROGRESS	= 20		; Must make progress every 20 msgs
	LAT$C_XMT_BUFFERS = 2		; Number of transmit buffers
	LAT$C_MAX_RCRED	= 1		; Maximum number of credits extended
	LAT$C_UCB_BUFSIZ = 80		; Size of UCB buffering
	LAT$C_UCB_SLOTSIZ = 4		; Size of formatted slot buffer in UCB
	LAT$C_UCB_TIMOUT = 2		; Allow 2 seconds before deleting  UCB's
	LAT$C_MAX_CSBS	= 32		; Maximum number of circuits handled
	LAT$C_MAX_SLOTS	= 64		; Maximum slots in a message, this also
					;  implies max connections per circuit
	LAT$C_HI_VER	= 5		; Highest supported LAT protocol version
	LAT$C_LO_VER	= 5		; Lowest supported LAT protocol version
	LAT$C_CUR_VER	= 5		; Current LAT protocol version
	LAT$C_CUR_ECO	= 0		; Current LAT protocol ECO version
	LAT$C_MAX_MSGSIZ = 1500 	; Maximum Data Link message size
	LAT$C_MAX_SLOTSIZ = 255		; Maximum Slot size
	LAT$C_LOC_LEN	= 64		; Maximum length of LOCation field
	LAT$C_GRP_LEN	= 32		; Maximum number of group codes
	LAT$C_SVC_LEN	= 8		; Maximum number of service classes
	LAT$C_MAX_SERVICES = 6		; Maximum number of services
	LAT$C_MULTIADD1	= ^X0009	; LAT Multicast address
	LAT$C_MULTIADD2	= ^X002B	;	...
	LAT$C_MULTIADD3	= ^X0F00	;	...
	LAT$C_HOST_TIMER = 2		; Host circuit timeout value (in SECs)
	LAT$C_MULTI_TIMER = 10		; Multicast message timer
	LAT$C_CIR_TIMER	= 80		; Host preferred circuit timer (in MS)
	LAT$C_SHUTDELAY = 5*1000*1000	; Delay time = 1/2 second
	LAT$C_KEEP_CSB  = 10		; Keep last 10 CSBs

;
;	Port driver ucb extension to class driver structures
;

	$DEFINI	UCB	GLOBAL
	. = UCB$C_TT_LENGTH
	ALIGN_LONG			; align to longword boundary
$DEF	UCB$L_LT_CSB	.BLKL	1	; CSB address
$DEF	UCB$L_LT_DEADLINK .BLKL	1	; Link for dead ucbs
$DEF	UCB$L_LT_INPBUF .BLKL	1	; Pointer to LAT type ahead buffer
$DEF	UCB$B_LT_REMID	.BLKB	1	; Remote slot index number
$DEF	UCB$B_LT_LOCID	.BLKB	1	; Local slot index number
$DEF	UCB$B_LT_DATAW	.BLKB	1	; Data waiting flags
 $VIELD	UCB,0,<-
	<LT_DATA,1,M>-			;* Output data waiting
	<LT_FLOW,1,M>-			;* Send current flow control values
	<LT_ABORT,1,M>-			;* Send abort request
	>

$DEF	UCB$B_LT_LATSTS	.BLKB	1	; Status for local terminal connection
 $VIELD	UCB,0,<-
	<LT_HANGUP,1,M>-		;* We are hanging up the slot
	<LT_DEAD,1,M>-			;* We have linked the UCB on deadlist
	<LT_OVFLOW,1,M>-		;* We had an overflow on input (XOFF)
	<LT_BOUND,1,M>-			;* Terminal is bound, don't delete UCB
	<LT_INPUT,1,M>-			;* Input stream in progress
	>

$DEF	UCB$B_LT_STATE	.BLKB	1	; Slot state
 $EQU	UCB$C_LT_STATE_START	1	;* State is starting
 $EQU	UCB$C_LT_STATE_RUN	2	;* State is running
 $EQU	UCB$C_LT_STATE_STOP	3	;* State is stopping (send stop slot)
 $EQU	UCB$C_LT_STATE_KILL	4	;* Kill UCB immediately

$DEF	UCB$B_LT_REASON	.BLKB	1	; Reason for stopping slot
$DEF	UCB$B_LT_TCRED	.BLKB	1	; Available credits for this slot
$DEF	UCB$B_LT_XCRED	.BLKB	1	; Credits extended to concentrator
$DEF	UCB$B_LT_RCRED	.BLKB	1	; Credits to be returned to concentrator
$DEF	UCB$B_LT_SLOTSZ	.BLKB	1	; Slot size (negotiated)
$DEF	UCB$B_LT_MAXC	.BLKB	1	; Size of UCB buffering
$DEF	UCB$B_LT_CURC	.BLKB	1	; Current character count
$DEF	UCB$B_LT_CBUF	.BLKB LAT$C_UCB_BUFSIZ ; Startio data buffer
$DEF	UCB$B_LT_EBUF			; Startio data buffer end
$DEF	UCB$C_LT_LENGTH			; Length of block
	$DEFEND	UCB


;+
;	Circuit state block
;
;  For each concentrator, one virtual circuit is maintained.
;  Protocol state is maintained in circuit state blocks.
;  The CSB addresses are stored in a vector starting
;  at CSB_TABLE.
;-

	$DEFINI	CSB	GLOBAL
			.BLKL	1
			.BLKL	1
$DEF	CSB_W_SIZE	.BLKW	1	; Size of this block in bytes
$DEF	CSB_B_TYPE	.BLKB	1	; Type of block
$DEF	CSB_B_STATE	.BLKB	1	; Virtual circuit state:
 $EQU	CSB_C_STATE_HALT	0	;* Circuit halted state
 $EQU	CSB_C_STATE_START	1	;* Circuit starting state
 $EQU	CSB_C_STATE_RUN		2	;* Circuit running state
;
;	Counter area - must follow standard block header!
;
	ASSUME	GHB$T_CSBCTR EQ .
$DEF	CSB_Z_LCB	.BLKB	LCB_C_LENGTH ; Circuit block counter area
;
;	Server name area - must immediately follow counter area
;
$DEF	CSB_B_SERVER	.BLKB	1	; Length of server name
$DEF	CSB_T_SERVER	.BLKB	GHB$K_NAMELEN ; Server name field
$DEF	CSB_B_REFC	.BLKB	1	; Number of UCBs attached to this CSB
;
;	Destination Ethernet address - must immediately follow server name area
;
$DEF	CSB_Z_DST	.BLKW	3	; Concentrator physical address

$DEF	CSB_Q_XBUFQ	.BLKQ	1	; Current transmit buffer queue
$DEF	CSB_Q_XWAITQ	.BLKQ	1	; Transmit buffers waiting queue
$DEF	CSB_L_XCXB	.BLKL	LAT$C_XMT_BUFFERS ; Transmit CXBs in progress
$DEF	CSB_L_STOPREASON .BLKL	1	; Address of the stop reason block
$DEF	CSB_W_TIMEOUT	.BLKW	1	; Timeout cell for CSB
$DEF	CSB_W_XMTTMO	.BLKW	1	; Timeout count for retransmit
$DEF	CSB_W_PROGRESS	.BLKW	1	; Progress counter
$DEF	CSB_W_PROGSEQ	.BLKW	1	; Transmit error control for progress
$DEF	CSB_B_XMTBSY	.BLKB	1	; Transmit busy and count of waiters
$DEF	CSB_B_XMTCNT	.BLKB	1	; Count of buffers to transmit
$DEF	CSB_B_XCXB_INX	.BLKB	1	; XCXB index
$DEF	CSB_B_SPARE	.BLKB	1	; SPARE

; Start of circuit header as it appears in transmitted messages

$DEF	CSB_T_CIRCHDR			; Lat circuit header
$DEF	CSB_B_FLAG	.BLKB	1	; Message flags byte
$DEF	CSB_B_NUM_SLOTS	.BLKB	1	; Number of slots
$DEF	CSB_W_REMID			; Remote virtual circuit id
$DEF	CSB_B_REMIDN	.BLKB	1	; Remote virtual circuit id number
$DEF	CSB_B_REMIDS	.BLKB	1	; Remote virtual circuit id sequence
$DEF	CSB_W_LOCID			; Local virtual circuit id
$DEF	CSB_B_LOCIDN	.BLKB	1 	; Local virtual circuit id number
$DEF	CSB_B_LOCIDS	.BLKB	1 	; Local virtual circuit id sequence
$DEF	CSB_W_XSEQ			; Transmiter error control
$DEF	CSB_B_XSEQ	.BLKB	1	; Sequence number being transmitted
$DEF	CSB_B_XACK	.BLKB	1	; Highest sequence number received
 $EQU	CSB_S_CIRCHDR	<.-CSB_T_CIRCHDR> ; Size of header

; End of circuit header

$DEF	CSB_W_RSEQ			; Sequence number to receive
$DEF	CSB_B_RSEQ	.BLKB	1	; Sequence number to receive
$DEF	CSB_B_RACK	.BLKB	1	; Highest sequence number acknowledged
$DEF	CSB_W_TIMRESET	.BLKW	1	; Timeout reset value
$DEF	CSB_B_INX	.BLKB	1	; CSB table index
$DEF	CSB_B_MAX_SLOTS	.BLKB	1	; Maximum number of slots (negotiated)
$DEF	CSB_W_MAX_MSGSIZ .BLKW	1	; Maximum message size (negotiated)
$DEF	CSB_C_FIXLENGTH			; Length of fixed block
;
;	UCB list area  (size = 4*min(lat$c_max_slots,server_slot_count) )
;
	ALIGN_LONG			; align to longword boundary
$DEF	CSB_L_UCBLST

	$DEFEND	CSB


;+
;	Terminal overflow input buffer definitions
;
;  The terminal overflow buffer is only used when a call is made to
;  the XOFF routine to stop the input flow. The overflow buffer is
;  allocated and the rest of the input data is copied to the overflow
;  buffer. When we are resumed at XON, the data from the input overflow
;  buffer is dumped into the class driver.
;
;-

	$DEFINI	INB	GLOBAL

$DEF	INB_W_BOFF	.BLKW	1	; Offset to start of data
$DEF	INB_W_BCNT	.BLKW	1	; Count of data remaining
$DEF	INB_L_SPARE	.BLKL	1	; Spare longword
$DEF	INB_W_SIZE	.BLKW	1	; Size of structure
$DEF	INB_B_TYPE	.BLKB	1	; Type of structure
$DEF	INB_B_SPARE	.BLKB	1	; Spare byte
$DEF	INB_C_LENGTH			; Size of structure header

	$DEFEND	INB



;+
;	Receive buffer offsets and bit definitions
;
;  The format of receive and transmit buffers is identical for fields
;  Starting with and following the destination address field. Ease of
;  implemenatation  dictates that the offsets  be defined relative to
;  the start of the buffer.
;
;  These are the offsets into the architecturally defined portion of 
;  the receive buffer itself.
;-

	$DEFINI	RCV	GLOBAL

.=0
$DEF	RCV_T_DATA			; Start of data is right here
$DEF	RCV_B_FLAG	.BLKB	1	; Flags byte and message type
	;
	; Flag bits:
	;
_VIELD	FLAG,0,<-			;* Flags byte bit definitions recv & xmit
	<RRF,1,M>,-			;* Response requested flag
	<MASTER,1,M>,-			;* Remote station always sets this flag
	<MTYPE,6,M>,-			;* Message type bits
	>
	;
	; Message types:
	;
 $EQU	MTYP_C_RUN	0		;* Run message
 $EQU	MTYP_C_START	1		;* Start message
 $EQU	MTYP_C_HALT	2		;* Halt message
 $EQU	MTYP_C_CONF	10		;* Configuration message

$DEF	RCV_B_NUM_SLOTS	.BLKB	1	; Number of slots in buffer
$DEF	RCV_W_DSTID			; Destination virtual circuit id
$DEF	RCV_B_DSTIDN	.BLKB	1	; Destination virtual circuit id number
$DEF	RCV_B_DSTIDS	.BLKB	1	; Destination virtual circuit id seq
$DEF	RCV_W_SRCID			; Source virtual circuit id
$DEF	RCV_B_SRCIDN	.BLKB	1	; Source virtual circuit id number
$DEF	RCV_B_SRCIDS	.BLKB	1	; Source virtual circuit id
					;  sequence number

$DEF	RCV_B_SEQ	.BLKB	1	; Buffer sequence number
$DEF	RCV_B_ACK	.BLKB	1	; Sequence number acknowledgement
$DEF	RCV_T_MDATA			; Start of type dependent data

	$DEFEND	RCV


;
; Define START message offsets (used for both xmits and recvs)
;
	$DEFINI	STRT	GLOBAL
$DEF	STRT_W_MSGSIZ	.BLKW	1	; Data link frame size
$DEF	STRT_B_PVER	.BLKB	1	; Circuit protocol version
$DEF	STRT_B_PECO	.BLKB	1	; Circuit Eng. change order level
$DEF	STRT_B_MAXSLOTS	.BLKB	1	; Maximum simultaneous slots
$DEF	STRT_B_DL_BFRS	.BLKB	1	; Number of extra rcv bfrs in server
$DEF	STRT_B_CIR_TIMR	.BLKB	1	; Local circuit timer in milliseconds
$DEF	STRT_B_KPA_TIMR	.BLKB	1	; Local keep alive timer in seconds
$DEF	STRT_W_FAC_NUM	.BLKW	1	; Facility number
$DEF	STRT_W_PROD_TYP	.BLKW	1	; Product type code
$DEF	STRT_C_LENGTH			; Length of fixed portion of message
;
; Start of variable length parameters
;
$DEF	STRT_B_VAR		; Start of variable portion of start message
$DEF	STRT_B_NODE_LEN	.BLKB	1	; Destination node name length
$DEF	STRT_T_NODE	.BLKB	GHB$K_NAMELEN ; Destination node name text
$DEF	STRT_B_SYS_LEN	.BLKB	1	; Source node name length
$DEF	STRT_T_SYS	.BLKB	GHB$K_NAMELEN ; Source node name text
$DEF	STRT_B_ID_LEN	.BLKB	1	; Source node descriptor length
$DEF	STRT_T_ID	.BLKB	GHB$K_IDLEN ; Source node descriptor text
$DEF	STRT_B_LOC_LEN	.BLKB	1	; Source location length
$DEF	STRT_T_LOC	.BLKB	LAT$C_LOC_LEN ; Source location text
$DEF	STRT_B_PARAM	.BLKB	1	; Parameter code
 $EQU	STRT_C_VAR_LEN	<.-STRT_B_VAR>	; Length of variable portion of start
					;   message
	$DEFEND STRT

;
; Define STOP message offsets
;
	$DEFINI	STOP	GLOBAL
$DEF	STOP_B_RCODE	.BLKB		; Circuit disconnect reason
$DEF	STOP_B_RLEN	.BLKB		; Reason length in bytes
$DEF	STOP_T_REAS			; Reason ASCII text
	$DEFEND	STOP



;+
;	Transmit buffer offsets and bit definitions
;
;	The buffer header is defined to be the same as that used by
;	the Ethernet datalink drivers.
;-

 	$DEFINI	CXB	GLOBAL		; Transmit complex buffer
;
; Define the transmit/receive offsets in the CXB
;
. = CXB$L_END_ACTION
$DEF	CXB$L_T_ENDADR	.BLKL	1	; End address of data to transmit

. = CXB$W_LENGTH
	ASSUME	CXB$W_OFFSET EQ CXB$W_LENGTH+2
$DEF	CXB$L_T_CSB			; CSB address

. = CXB$L_IRP
$DEF	CXB$L_T_SAVE	.BLKL	1	; BOFF & BCNT save area

	$DEFEND	CXB

;
; Start of architecturally defined offsets
;
	$DEFINI	XMT	GLOBAL

. = CXB$C_HEADER - <6+6+2>
$DEF	XMT_G_DST	.BLKW	3	; Destination address

. = CXB$C_HEADER
$DEF	XMT_T_DATA			; Start of transmitted data
$DEF	XMT_B_FLAG	.BLKB	1	; Flags byte and message type

;
; Run message format:
;
$DEF	XMT_B_NUM_SLOTS	.BLKB	1	; Number of slots in buffer
$DEF	XMT_W_DSTID			; Destination virtual circuit id
$DEF	XMT_B_DSTIDN	.BLKB	1	; Destination virtual circuit id number
$DEF	XMT_B_DSTIDS	.BLKB	1	; Destination virtual circuit id seq
$DEF	XMT_W_SRCID			; Source virtual circuit id
$DEF	XMT_B_SRCIDN	.BLKB	1	; Source virtual circuit id number
$DEF	XMT_B_SRCIDS	.BLKB	1	; Source virtual circuit id
					;   sequence number

$DEF	XMT_B_SEQ	.BLKB	1	; Buffer sequence number
$DEF	XMT_B_ACK	.BLKB	1	; Sequence number acknowledgement
$DEF	XMT_T_MDATA			; Start of RUN message data

;
; Multicast (CONFIGURATION) message format:
;
	. = XMT_B_FLAG+1
$DEF	XMT_B_MC_CIR_TIMER	.BLKB	1	; Circuit timer
$DEF	XMT_B_MC_HI_VER		.BLKB	1	; Highest supported protocol version
$DEF	XMT_B_MC_LO_VER		.BLKB	1	; Lowest supported protocol version
$DEF	XMT_B_MC_CUR_VER	.BLKB	1	; version of this message
$DEF	XMT_B_MC_CUR_ECO	.BLKB	1	; eco of this message
$DEF	XMT_B_MC_INCARN		.BLKB	1	; Message incarnation
$DEF	XMT_B_MC_CHG_FLAG	.BLKB	1	; Changed fields in this msg

	_VIELD	XMT_CHFLG,0,<-
	<GROUP,1,M>,-				;* NODE group codes changed
	<NDESC,1,M>,-				;* NODE descriptor changed
	<SVCNAM,1,M>,-				;* Service name/number changed
	<RATE,1,M>,-				;* Service ratings changed
	<SDESC,1,M>,-				;* Service classes changed
	<CLASS,1,M>,-				;* Service classes changed
	<,1>,-					;* RESERVED
	<OTHER,1,M>,-				;* One of the OTHER fields changed
	>
 $EQU	XMT_CHFLG_M_ALL <^XFF>			;* All codes changed

$DEF	XMT_W_MC_MSG_SIZ	.BLKW	1	; Maximum frame size
 $EQU	XMT_C_MC_LENGTH		<.-XMT_T_DATA>	; Size of fixed part of multicast message

$DEF	XMT_B_MC_SET		; Start of LATCP set portion of multicast msg
$DEF	XMT_B_MC_MULTIMR	.BLKB	1	; Multicast message timer
$DEF	XMT_B_MC_STATUS		.BLKB	1	; Node status
$DEF	XMT_B_MC_GRP_LEN	.BLKB	1	; Number of group codes
$DEF	XMT_T_MC_GROUP		.BLKB	LAT$C_GRP_LEN ; Group code field
$DEF	XMT_B_MC_NODE_LEN	.BLKB	1	; Node name length
$DEF	XMT_T_MC_NODE		.BLKB	GHB$K_NAMELEN ; NODE name
$DEF	XMT_B_MC_NUM_SVCS	.BLKB	1	; Number of services

$DEF	XMT_B_MC_RATE		.BLKB	1	; Service rating
$DEF	XMT_B_MC_NAME_LEN	.BLKB	1	; Service name length
$DEF	XMT_T_MC_NAME		.BLKB	GHB$K_NAMELEN ; Service name
$DEF	XMT_B_MC_ID_LEN		.BLKB	1	; Length of Identification field
$DEF	XMT_T_MC_ID		.BLKB	GHB$K_IDLEN ; Identification field
 $EQU	XMT_C_MC_SVC_SIZE	<.-XMT_B_MC_RATE> ; Size of each service field

$DEF	XMT_T_MC_MORE_SVC	.BLKB	<<LAT$C_MAX_SERVICES-1>*XMT_C_MC_SVC_SIZE>

$DEF	XMT_B_MC_SVC_LEN	.BLKB	1	; Number of service classes
$DEF	XMT_B_MC_SVC		.BLKB	LAT$C_SVC_LEN ; Service classes
 $EQU	XMT_C_MC_TOTAL  <.-XMT_T_DATA>		; Length of total message
	ASSUME	XMT_C_MC_TOTAL LE LAT$C_MAX_MSGSIZ

 $EQU	XMT_C_HDRLEN	<XMT_T_MDATA - XMT_T_DATA>
					; Length of header
 $EQU	XMT_C_MAXDATA	<LAT$C_MAX_MSGSIZ - XMT_C_HDRLEN>
					; Data in slots
 $EQU	XMT_C_MAXLEN	<LAT$C_MAX_MSGSIZ + XMT_T_DATA>
					; Total size of a buffer
 	$DEFEND	XMT

;+
;	Buffer slot offsets
;
;	Each slot is formatted identically in both 
;	transmit and receive buffers as defined below.
;-

 	$DEFINI	SLT	GLOBAL

$DEF	SLT_T_START			; Start of slot
$DEF	SLT_B_DSTID	.BLKB	1	; Destination slot ID
$DEF	SLT_B_SRCID	.BLKB	1	; Source slot ID
$DEF	SLT_B_COUNT	.BLKB	1	; Character count in slot
$DEF	SLT_B_REAS			; Stop/reject slot reason (low nibble)
$DEF	SLT_B_CRED			; Credits extended (low order nibble)
$DEF	SLT_B_TYPE	.BLKB	1	; Slot type (high order nibble)
	; STOP/REJECT reason codes:
 $EQU	SLT_C_USD	1		; * User requested disconnect
 $EQU	SLT_C_SYS	2		; * System shutdown
 $EQU	SLT_C_INVSLOT	3		; * Invalid slot received
 $EQU	SLT_C_INVSVC	4		; * Invalid service class received
 $EQU	SLT_C_RESOURCE	5		; * Insufficient resources
	; Slot type codes:
 $EQU	SLT_C_DA_SLOT	<^X00>		; * DATA_A slot
 $EQU	SLT_C_STR_SLOT	<^X09>		; * START slot
 $EQU	SLT_C_DB_SLOT	<^X0A>		; * DATA_B slot
 $EQU	SLT_C_ATT_SLOT	<^X0B>		; * ATTENTION slot
 $EQU	SLT_C_REJ_SLOT	<^X0C>		; * REJECT slot
 $EQU	SLT_C_STP_SLOT	<^X0D>		; * STOP slot
$DEF	SLT_T_DATA			; Start of slot data

;
; Start slot data definitions
;
. = SLT_T_DATA
$DEF	SLT_B_SVCC	.BLKB	1	; Service class
$EQU	SLT_C_SVC_INTT	1		; * Interactive Terminals
$DEF	SLT_B_AT_SLTSIZ	.BLKB	1	; Maximum length of attention slot
$DEF	SLT_B_DT_SLTSIZ	.BLKB	1	; Maximum length of Data slot
$DEF	SLT_B_DST_NAMLEN .BLKB	1	; Length of destination slot name
$DEF	SLT_T_DST_NAME	.BLKB	GHB$K_NAMELEN
$DEF	SLT_B_SRC_NAMLEN .BLKB	1	; Length of source slot name
$DEF	SLT_B_SRC_NAME	.BLKB	GHB$K_NAMELEN
 $EQU	SLT_S_START_SLOT <.-SLT_T_DATA> ; Length of Start slot
$DEF	SLT_B_PARAMS			; Start of parameter area
 $EQU	SLT_C_START_FLAG	1	;* Start slot parameter flag is code 1
	_VIELD	SLT_FLAG,0,<-
		<REMOTE,1,M>,-		;* Remote line
		<LOGIN,1,M>,-		;* Disable auto-login
		<BIND,1,M>,-		;* Terminal UCB is bound to server
		>

;
; DATA_B slot data definitions
;
. = SLT_T_DATA
$DEF	SLT_B_DB_CONTROL	.BLKB	1	; DATA_B slot control flag
	_VIELD	SLT_DB,0,<-
		<IFENA,1,M>,-			; Turn on flow control of keyboard input
		<IFDIS,1,M>,-			; Turn off flow control of keyb input
		<OFENA,1,M>,-			; Output flow on
		<OFDIS,1,M>,-			; Output flow off
		<BREAK,1,M>,-			; Break condition detected (recv slots)
		>
$DEF	SLT_B_DB_OFOF	.BLKB	1		; Output-off flow char (from keyboard)
$DEF	SLT_B_DB_OFON	.BLKB	1		; Output-on flow char (from keyboard)
$DEF	SLT_B_DB_IFOF	.BLKB	1		; Input-off flow character (from host)
$DEF	SLT_B_DB_IFON	.BLKB	1		; Input-on flow character (from host)
 $EQU	SLT_S_DB_LEN	<.-SLT_T_DATA>		; Length of DATA_B data
 $EQU	SLT_S_DB_SLOT	<.-SLT_T_START>		; Length of DATA_B slot

;
; ATTention slot data definitions
;
. = SLT_T_DATA
$DEF	SLT_B_ATT_CONTROL	.BLKB	1	; ATTENTION slot control flag
	_VIELD	SLT_ATT,0,<-
		<,5>,-				; RESERVED
		<ABORT,1,M>,-			; Abort (flush pipe)
		>
 $EQU	SLT_S_ATT_LEN	<.-SLT_T_DATA>		; Length of Attention data
 $EQU	SLT_S_ATT_SLOT	<.-SLT_T_START>		; Length of Attention slot

;
; STOP slot data definitions
;
. = SLT_T_DATA
$DEF	SLT_B_STP_RLEN	.BLKB	1		; STOP slot reason length
 $EQU	SLT_S_STP_LEN	<.-SLT_T_DATA>		; Length of fixed STOP slot data
 $EQU	SLT_S_STP_SLOT	<.-SLT_T_START>		; Length of fixed STOP slot
$DEF	SLT_T_STP_REAS				; STOP slot reason (variable)

;
; REJect slot data definitions
;
. = SLT_T_DATA
$DEF	SLT_B_REJ_RLEN	.BLKB	1		; REJ slot reason length
 $EQU	SLT_S_REJ_LEN	<.-SLT_T_DATA>		; Length of fixed REJ slot data
 $EQU	SLT_S_REJ_SLOT	<.-SLT_T_START>		; Length of fixed REJ slot
$DEF	SLT_T_REJ_REAS				; REJ slot reason (variable)

 	$DEFEND	SLT

;
;	Local macros
;

.MACRO	INC_CTR,	BASE, TYPE=L, ?L
	INC'TYPE	BASE			; Increment counter
	BNEQ	L				; Br if no overflow
	DEC'TYPE	BASE			; Else, latch at maximum
L:
.END	INC_CTR

.MACRO	ADD_CTR,	BASE1, BASE2, TYPE=L, ?L
	ADD'TYPE	BASE1,BASE2		; Add counters
	BCC	L				; Br if no overflow
	MNEG'TYPE	#1,BASE2		; Else, latch at maximum
L:
.END	ADD_CTR

.MACRO	$DISPATCH,	INDX,VECTOR,TYPE=W,NMODE=S^#,?MN,?MX,?S,?SS,?ZZ
SS:

	.MACRO	$DSP1,$DSP1_1
		.IRP	$DSP1_2,$DSP1_1
			$DSP2	$DSP1_2
		.ENDR
	.ENDM	$DSP1

	.MACRO	$DSP2,$DSP2_1,$DSP2_2
		.=<$DSP2_1-MN>*2 + S
		.WORD	$DSP2_2-S
	.ENDM	$DSP2


	.MACRO	$BND1,$BND1_1,$BND1_2,$BND1_3
		$BND2	$BND1_1,$BND1_2
	.ENDM	$BND1

	.MACRO	$BND2,$BND2_1,$BND2_2
		.IIF	$BND2_1,$BND2_2-.,	.=$BND2_2
	.ENDM	$BND2

	.MACRO	$BND	$BND_1,$BND_2
		.IRP	$BND_3,<$BND_2>
			$BND1	$BND_1,$BND_3
		.ENDR
	.ENDM	$BND

	.=0
ZZ:
	$BND	GT,<VECTOR>
MX:
	$BND	LT,<VECTOR>
MN:
	.=SS

CASE'TYPE	INDX,#<MN-ZZ>,NMODE'<MX-MN>
S:
	.REPT	MX-MN+1
	.WORD	<MX-MN>*2 + 2
	.ENDR

	.=S

	$DSP1	<<VECTOR>>

	.=<MX-MN>*2 + S + 2

.ENDM	$DISPATCH


	.MACRO	SETBIT BIT, BASE, ?L	; Set specified bit
	BBSS	BIT, BASE, L
L:
	.ENDM

	.MACRO	CLRBIT BIT, BASE, ?L	; Clear specified bit
	BBCC	BIT, BASE, L
L:
	.ENDM

	.MACRO	BREAK
	JSB	G^INI$BRK
	.ENDM

	.MACRO	DEBUG
	TSTL	@#-1
	.ENDM	DEBUG


	.SBTTL	Driver Prologue Table

	.PSECT	$$$105_PROLOGUE

;
; Driver prologue table:
;

LT$DPT::				; Driver start
	DPTAB	-			; Driver prologue table
		END=LT$END,-		; Address of end of module
		UCBSIZE=UCB$C_LT_LENGTH,-; Size of each ucb of port driver
		ADAPTER=NULL,-		; Adapter type
		NAME=LTDRIVER,-		; Name of driver
		VECTOR=LT$VECTOR	; Port driver vector table
	DPT_STORE INIT
	DPT_STORE UCB,UCB$B_FIPL,B,LAT$C_IPL ; Fork ipl
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-; Characteristics
			DEV$M_REC!-	;
			DEV$M_AVL!-	;
			DEV$M_IDV!-	;
			DEV$M_ODV!-	;
			DEV$M_TRM!-	;
			DEV$M_CCL>
	DPT_STORE UCB,UCB$L_DEVCHAR2,L,<-
			DEV$M_NNM>	; Prefix name with <node$>
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM;
	DPT_STORE UCB,UCB$B_TT_DETYPE,B,TT$_UNKNOWN	; Type
	DPT_STORE UCB,UCB$W_TT_DESIZE,@W,TTY$GW_DEFBUF	; Buffer size
	DPT_STORE UCB,UCB$L_TT_DECHAR,@L,TTY$GL_DEFCHAR	; Default characters
	DPT_STORE UCB,UCB$L_TT_DECHA1,@L,TTY$GL_DEFCHAR2; Default characters
	DPT_STORE UCB,UCB$W_TT_DESPEE,@B,TTY$GB_DEFSPEED; Default speed
	DPT_STORE UCB,UCB$W_TT_DESPEE+1,@B,TTY$GB_RSPEED; Default rspeed
	DPT_STORE UCB,UCB$B_TT_DEPARI,@B,TTY$GB_PARITY	; Default parity
;**	DPT_STORE UCB,UCB$B_TT_PARITY,@B,TTY$GB_PARITY	; Default parity
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN	; Type
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF	; Buffer size
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR	; Default characters
	DPT_STORE UCB,UCB$L_TT_DEVDP1,@L,TTY$GL_DEFCHAR2; Default characters
	DPT_STORE UCB,UCB$W_TT_SPEED,@B,TTY$GB_DEFSPEED	; Default speed
	DPT_STORE UCB,UCB$W_TT_SPEED+1,@B,TTY$GB_RSPEED	; Default rspeed
	DPT_STORE UCB,UCB$B_DIPL,B,LAT$C_IPL		; Device ipl
	DPT_STORE UCB,UCB$L_TT_WFLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_WBLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_RTIMOU,L,0		; Zero read timed out
;**	DPT_STORE UCB,UCB$W_TT_PRTCTL,W,TTY$M_PC_NOTIME	; Disable all timers
	DPT_STORE ORB,ORB$B_FLAGS,B,-			; Default flags
			   <ORB$M_PROT_16>		; SOGW word protection
	DPT_STORE ORB,ORB$W_PROT,@W,TTY$GW_PROT    	; Default protection
	DPT_STORE ORB,ORB$L_OWNER,@L,TTY$GL_OWNUIC 	; Default owner uic
	DPT_STORE DDB,DDB$L_DDT,D,LT$DDT

	DPT_STORE REINIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,LT$CTRL_INIT ; Controller init
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,LT$UNIT_INIT ; Unit init
	DPT_STORE END





	DDTAB	DEVNAM = LT,-	; Dummy port driver dispatch table
		START  = 0,-
		FUNCTB = 0


	.SBTTL	Local Storage


	.PSECT	$$$115_DRIVER,LONG

;
; Local storage
;

;+
;	Circuit State Block table
;
;  This table is indexed by RCV_B_DSTIDN in received buffers. A
;  concentrator always uses the same value when refering to a
;  host for a second time. The RCV_B_DSTIDS byte is a check byte
;  which helps prevent random or outdated references to CSBs.
;
;-

	.ALIGN	LONG

GHB_L_CSBTABLE:
	.BLKL	LAT$C_MAX_CSBS			; CSB address table
GHB_B_LOC_CCHK:					; Table of local
	.BLKB	LAT$C_MAX_CSBS+1		; circuit checks


;
;	Timer queue element
;
;	Used to timeout CSB's that have had no activity.
;

	.ALIGN	LONG
GHB_G_TQE:
	.BLKB	TQE$C_LENGTH



;
;	Host counter block
;

	.ALIGN	LONG
GHB_AREA:			; Communications area
	.BLKB	GHB$S_COMM_AREA

	.ALIGN LONG

GHB_L_UCB0:	.BLKL	1	; LT UCB zero address
GHB_L_DEADLINK:	.BLKL	1	; List of dead UCBs
GHB_L_FFI:	.BLKL	1	; FFI block address
GHB_L_NULLCPU:	.BLKL	1	; Pointer to null CPU time
GHB_L_LASTCPU:	.BLKL	1	; Value of last null CPU sample
GHB_L_NULLSEC:	.BLKL	1	; Value of latt null CPU sample on secondary
GHB_B_STATUS:	.BLKB	1	; Host status byte
	_VIELD	GHB_STS,0,<-
		<MULTI,1,M>,-	; Multicast buffer in use
		<ACTIVE,1,M>,-	; LTDRIVER is active
		<SHUT,1,M>,-	; Shutdown is in progress
		<TQE,1,M>,-	; Waiting for TQE to fire
		>
GHB_B_INCARN:	.BLKB	1	; Incarnation number for multicast message
GHB_B_OLD_CSBCNT: .BLKB	1	; Count of old CSBs on queue
GHB_B_RATE:	.BLKB	1	; Initial rating computed from memory size
;
; Multicast data set by LATCP
;
	.ALIGN 	LONG
GHB_W_MC_SIZE:	.BLKW	1	; Size of name and ID strings
GHB_T_MC_DATA:	.BLKB	XMT_C_MC_TOTAL+16 ; Name and ID storage + fudge factor

;
; Multicast (Configuration) Message Destination Ethernet address
;
	.ALIGN	LONG
GHB_Q_MULTIADD:	.WORD	LAT$C_MULTIADD1	; LAT Multicast destination address
		.WORD	LAT$C_MULTIADD2	;	...
		.WORD	LAT$C_MULTIADD3	;	...
					; Picks up next word also (garbage)
;
; Data to control multicast buffer
;
GHB_W_MULTIMR:	.BLKW	1		; Timer for multicast transmits
GHB_L_MULTIBFR:	.BLKL	1		; Address of the multicast buffer

;
; Host Multicast (Configuration) Message fixed portion template
;	(Fields are order-dependent and adjacent)
;
	ASSUME	XMT_B_FLAG          EQ  XMT_T_DATA
	ASSUME	XMT_B_MC_CIR_TIMER  EQ  XMT_B_FLAG+1
	ASSUME	XMT_B_MC_HI_VER     EQ  XMT_B_MC_CIR_TIMER+1
	ASSUME	XMT_B_MC_LO_VER     EQ  XMT_B_MC_HI_VER+1
	ASSUME	XMT_B_MC_CUR_VER    EQ  XMT_B_MC_LO_VER+1
	ASSUME	XMT_B_MC_CUR_ECO    EQ  XMT_B_MC_CUR_VER+1
	ASSUME	XMT_B_MC_INCARN     EQ  XMT_B_MC_CUR_ECO+1
	ASSUME	XMT_B_MC_CHG_FLAG   EQ  XMT_B_MC_INCARN+1
	ASSUME	XMT_W_MC_MSG_SIZ    EQ  XMT_B_MC_CHG_FLAG+1
	ASSUME	XMT_B_MC_SET        EQ  XMT_W_MC_MSG_SIZ+2
GHB_T_MC_MSG:				; Start of multicast msg fixed data
		.BYTE	MTYP_C_CONF@FLAG_V_MTYPE ; Message type
		.BYTE	<LAT$C_CIR_TIMER+9>/10	; Host preferred Circuit timer
		.BYTE	LAT$C_HI_VER	; Highest LAT protocol version supported
		.BYTE	LAT$C_LO_VER	; Lowest LAT protocol version supported
		.BYTE	LAT$C_CUR_VER	; Current LAT protocol version
		.BYTE	LAT$C_CUR_ECO	; Current LAT protocol ECO version
		.BYTE	0		; Message incarnation (filled in later)
		.BYTE	0		; Change flags (filled in later)
		.WORD	LAT$C_MAX_MSGSIZ ; Maximum message size

;
; Standard Start message (fixed portion) template
;
	ASSUME	STRT_W_MSGSIZ	EQ  0
	ASSUME	STRT_B_PVER	EQ  STRT_W_MSGSIZ+2
	ASSUME	STRT_B_PECO	EQ  STRT_B_PVER+1
	ASSUME	STRT_B_MAXSLOTS	EQ  STRT_B_PECO+1
	ASSUME	STRT_B_DL_BFRS  EQ  STRT_B_MAXSLOTS+1
	ASSUME	STRT_B_CIR_TIMR EQ  STRT_B_DL_BFRS+1
	ASSUME	STRT_B_KPA_TIMR EQ  STRT_B_CIR_TIMR+1
	ASSUME	STRT_W_FAC_NUM	EQ  STRT_B_KPA_TIMR+1
	ASSUME	STRT_W_PROD_TYP	EQ  STRT_W_FAC_NUM+2
GHB_W_STRT_LEN:	.BLKW	1		; Length of start message
GHB_T_STRT_MSG:				; Start of start message fixed data
		.WORD	LAT$C_MAX_MSGSIZ ; Maximum Ethernet frame size
		.BYTE	LAT$C_CUR_VER	; Current LAT protocol version
		.BYTE	LAT$C_CUR_ECO	; Current LAT ECO version
		.BYTE	LAT$C_MAX_SLOTS	; Maximum number of Slots per circuit
		.BYTE	0		; Number of additional buffers (remote)
		.BLKB	2		; Remote parameters only
		.WORD	0		; Facility number (not yet implemented)
		.WORD	LAT$C_VMS 	; Product type code

	ASSUME	STRT_B_VAR   EQ  STRT_W_PROD_TYP+2
GHB_T_STRT_VAR:	.BLKB	STRT_C_VAR_LEN	; Variable portion of start message
;
; Standard Start slot template
;
GHB_T_STRT_SLOT:			; Start of the start slot data
		.BYTE	SLT_C_SVC_INTT	; Service class
		.BYTE	LAT$C_MAX_SLOTSIZ ; Attention slot size
		.BYTE	LAT$C_MAX_SLOTSIZ ; Data slot size
		.BLKB	2		; Null source and destination slot names
	GHB_C_STRT_SLOTL = <.-GHB_T_STRT_SLOT>

	.SBTTL	Port Vector

;
; The associated class driver uses this table to command the port driver.
; The address of this table is contained in the terminal ucb extension area.
; The offset definitons are defined by ttydefs.
;

;
;	LAT specific dispatch table
;
; ORDER DEPENDENCY
;  The following symbol must immediately precede the vector
;

	.ALIGN	LONG
GHB_L_AREA:
	.BLKL	1				; Address of counter vector
LT$VECTOR:
	$VECINI	LT,LT$NULL
	$VEC	STARTIO,LT$STARTIO		; Start new output
	$VEC	DISCONNECT,LT$DISCONNECT	; Hangup port
	$VEC	ABORT,LT$ABORT			; Abort output
	$VEC	SET_LINE,LT$FLOW_CHANGE		; Change flow control
	$VEC	XON,LT$XON			; Send xon sequence
	$VEC	XOFF,LT$XOFF			; Send xoff sequence
;	$VEC	DS_SET,LT$DS_SET		; Dataset transitions
	$VECEND

LT$NULL:					; Null port routine
	RSB


;
; Stop reasons
;

.MACRO	$REASON RSNCD, RSNBIT, RSNSTR, ?L
	.ALIGN WORD
	.SIGNED_WORD L-.
	.BYTE RSNCD, RSNBIT
L:	.ASCIC	/RSNSTR/
.ENDM

LAT_C_CRSN_DONE		= 1		; No slots in VC
LAT_C_CRSN_IVMSG	= 2		; Invalid message
LAT_C_CRSN_IVSCI	= 3		; Invalid slave conn id
LAT_C_CRSN_IVMCI	= 4		; invalid master conn id
LAT_C_CRSN_DISC		= 5		; Disconnect requested
LAT_C_CRSN_PROGRESS	= 6		; No progress being made
LAT_C_CRSN_TMO		= 7		; Timeout of circuit
LAT_C_CRSN_RETRANS	= 8		; Retransmit count exceeded
LAT_C_CRSN_RESOURCE	= 9		; No resources
LAT_C_CRSN_TIMRANG	= 10		; Timer value out of range


LAT_C_RSN_xxx = 0			; junk

LT_RSN_START:
	$REASON	-
		GHB$V_START,-
		LAT_C_RSN_XXX,-
	<other than start msg with a zero src index>
LT_RSN_CSBZERO:
	$REASON	-
		GHB$V_CSBZERO,-
		LAT_C_RSN_XXX,-
	<circuit index zero>
LT_RSN_CSBRANGE:
	$REASON	-
		GHB$V_CSBRANGE,-
		LAT_C_RSN_XXX,-
	<circuit index out of range>
LT_RSN_CSBINVALID:
	$REASON	-
		GHB$V_CSBINVALID,-
		LAT_C_RSN_XXX,-
	<circuit index invalid>
LT_RSN_CSBSTALE:
	$REASON	-
		GHB$V_CSBSTALE,-
		LAT_C_RSN_XXX,-
	<circuit stale reference>
LT_RSN_HALT:
	$REASON	-
		GHB$V_HALT,-
		LAT_C_RSN_XXX,-
	<circuit forced to halt>
LT_RSN_INVALIDLOCID:
	$REASON	-
		GHB$V_INVALIDLOCID,-
		LAT_C_RSN_XXX,-
	<invalid local slot id>
LT_RSN_INVALIDREMID:
	$REASON	-
		GHB$V_INVALIDREMID,-
		LAT_C_RSN_XXX,-
	<invalid remote slot id>
LT_RSN_BADCREDITS:
	$REASON	-
		GHB$V_BADCREDITS,-
		LAT_C_RSN_XXX,-
	<bad number of credits in slot>
LT_RSN_REPCREATE:
	$REASON	-
		GHB$V_REPCREATE,-
		LAT_C_RSN_XXX,-
	<repeat create of slot by server>
LT_RSN_REPDISC:
	$REASON	-
		GHB$V_REPDISC,-
		LAT_C_RSN_XXX,-
	<repeat disconnect of slot by server>

.ALIGN	LONG


	.SBTTL	LT$CTRL_INIT  - Controller Initialization 

	.DEFAULT DISPLACEMENT, WORD
;++
; LT$CTRL_INIT - Initialize port driver
;
; Functional description:
;
; This routine is entered at driver load and power recovery.
;
; Inputs:
;
;	R6 = DDB address
;	R8 = CRB address
;
; Outputs:
;
;	R0 through r3 are modified.
;
; Implicit inputs:
;
;	IPL = IPL$_POWER
;
;--
LT$CTRL_INIT:				; Initialize controller
;
; Save the address of unit zero for cloning ucbs, if its here now.
;
	MOVL	DDB$L_UCB(R6), R1	; Its in the device data block
	BEQL	5$			; Do not store a zero
	MOVL	R1, GHB_L_UCB0		; Save its address
5$:
	MOVL	G^SCH$GL_NULLPCB+PCB$L_PHD,- ; Get address of NULL PHD
		 GHB_L_NULLCPU
	ADDL	#PHD$L_CPUTIM,GHB_L_NULLCPU ; Get offset to "idle time"

;
; Attempt to relocate terminal class vector table in case we are the
; first port driver to load.
;

	MOVL	G^TTY$GL_DPT,R1		; Get terminal class driver DPT address
	MOVZWL	DPT$W_VECTOR(R1),R0	; Get offset to class vector
	ADDL3	R0,R1,R0		; Calculate virtual address
10$:	TSTL	(R0)			; Already relocated or done?
	BLEQ	20$			; Br if yes
	ADDL	R1,(R0)+		; Else, add bias
	BRB	10$			; Loop till done
;
; Relocate port vector table
;
20$:
	MOVAL	LT$DPT,R1		; Get our DPT address
	MOVAL	LT$VECTOR,R0		; Get address of our dispatch vector
30$:
	TSTL	(R0)			; Already relocated or done?
	BLEQ	40$			; Br if yes, powerfail
	ADDL	R1,(R0)+		; Else, add bias
	BRB	30$			; Loop til done
40$:
	MOVAB	LT$STRENTRY,-		; Set address of start entry point
		GHB$L_STRENTRY+GHB_AREA	; 
	MOVAB	LT$SHUTENTRY,-		; Set address shutdown entry point
		GHB$L_SHUTENTRY+GHB_AREA;
	MOVAB	LT$SETENTRY,-		; Set address of multicast set entry
		GHB$L_SETENTRY+GHB_AREA	;
	MOVAB	GHB_AREA,-		; Save address of the common area
		GHB_L_AREA		;   so we can find them from LATCP
	MOVB	G^EXE$GQ_SYSTIME,-	; Get a random number
		GHB_B_INCARN		;  and save for the message seed value

	MOVAB	GHB_T_MC_DATA,-		; Address of multicast data area
		GHB$L_NODE+GHB_AREA

	ASSUME	GHB$B_LATVERSION  EQ  GHB$W_VMSVERSION+2
	ASSUME	GHB$B_LATECO      EQ  GHB$B_LATVERSION+1
	MOVL	#<<LAT$C_CUR_ECO>@8! -	; Store current ECO
		 LAT$C_CUR_VER>@16! -	;	    and VERsion
		 LAT$C_VMS_VER, -	;	and VMS VERsion
		GHB$W_VMSVERSION+GHB_AREA
	MOVB	#LAT$C_KEEP_CSB,-	; Set number of CSBs to keep around
		GHB_B_OLD_CSBCNT
	MOVAB	GHB_L_CSBTABLE,-	; Store address of CSB table
		GHB$L_CSBLST+GHB_AREA
	MOVAB	GHB$Q_OLD_CSBS+GHB_AREA,R0 ; Get address of old CSB entries
	TSTL	(R0)			; Already initialized?
	BNEQ	50$			; Br if yes, skip next section
	MOVL	R0,(R0)			; Initialize listhead
	MOVL	R0,4(R0)		;	...

50$:	;
	;  Setup the initial rating value, based on memory size
	;
	MOVL	G^MMG$GL_MAXPFN,R0	; Get the max PFN count
	DIVL	#8192,R0		; Weight by 4MB chunks
	SUBL3	R0,#8,R0		; Compute for up to 32 MB systems
	BGEQ	70$			; Br if result okay
	CLRL	R0			; Else, more than 32 MB - impressive!
70$:	SUBB3	R0,#255,GHB_B_RATE	; Store initial rating
	RSB

	.IF DEFINED LT_HISTORY

	.SBTTL	LT$HISTORY  - Save history in the buffer
;++
; LT$HISTORY - Save history in the buffer
;
;   Save history on transmits and receives.
;   The history buffer is defined as follows:
;
;		+-------------------------+
;		!  Pointer to next slot   !
;		!-------------------------!
;		! Pointer to end of buffer!
;		!-------------------------!
;		!spare!type! buffer size  !
;		!-------------------------!
;		!      ... data ...       !
;
;		!			  !
;		+-------------------------+
;
; Inputs:
;	R0 -> data to save
;
; Outputs:
;	R1 is clobbered
;--

	SLOT_SIZE = 32			; Size of each history slot

LT$HISTORY:
	MOVL	GHB$L_HISTORY+GHB_AREA,R1 ; Point to history buffer
	BEQL	90$			; Br if none
					;
	PUSHL	R0			; Save R0
	ADDL3	#SLOT_SIZE,-		; Compute end address for this slot
		 HBF_L_NEXT(R1),R0
	CMPL	R0,HBF_L_BUFEND(R1)	; Are we past the end?
	BLEQU	30$			; Br if no, continue
	MOVAB	HBF_Z_DATA(R1),-	; Else, back to beginning
		HBF_L_NEXT(R1)
30$:	MOVL	HBF_L_NEXT(R1),R1	; Get address of next available slot
	MOVQ	G^EXE$GQ_SYSTIME,(R1)+	; Store time in first quadword
	MOVL	(SP),R0			; Get back buffer address
	MOVQ	(R0)+, (R1)+		; Save the data
	MOVQ	(R0)+, (R1)+		; Save the data
	MOVQ	(R0)+, (R1)+		; Save the data
	ASSUME	HBF_L_NEXT EQ 0
	MOVL	R1,@GHB$L_HISTORY+GHB_AREA ; Save address of next slot
	POPL	R0			; Restore R0
					;
90$:	RSB
	.ENDC	;; DEFINED LT_HISTORY

	.SBTTL	LT$STRENTRY  - Entry to start driver
;++
; LT$STRENTRY - Start LTDRIVER entry point
;
; Functional description:
;
;	This entry is called by the startup program to initialize the
;	driver.  Here we save the datalink UCB address, allocate the CSB's
;	and start the first receive.
;
; Inputs:
;	R5 = UCB address of datalink
;
; Implicit inputs:
;
;	Called in user context.
;
; Outputs:
;	R0 = success or failure
;--


LT$STRENTRY:
	DSBINT	#LAT$C_IPL		; Raise IPL to prevent interruption
	MOVL	R5,GHB$L_UCB+GHB_AREA	; Save the datalink UCB address

	MOVAB	GHB_L_CSBTABLE,R9	; Get CSB table base address
	MOVZBL	#LAT$C_MAX_CSBS,R10	; Get table length in longwords
20$:	CLRL	(R9)+			; Zero the whole table
	SOBGTR	R10,20$			; Do whole table
	;
	;  Save the last CPU idle value
	;
	MOVL	@GHB_L_NULLCPU,-	; Save last idle value
		 GHB_L_LASTCPU
	MOVL	G^EXE$GL_MP,R0		; Get ptr to MP code
	BEQL	40$			; Br if not there
	MOVL	MPS$GL_NULLCPU(R0),-	; Else, get Secondary null time
		 GHB_L_NULLSEC
40$: 	;
	;  See if the datalink supports the fast interface and if so
	;  then allocate an FFI block and initialize that interface.
	;
	CLRL	R0			; Assume error
	MOVL	UCB$L_CRB(R5), R1	; Get address of datalink's CRB
	MOVL	CRB$L_INTD+VEC$L_START(R1), R1 ; Get address of FFI INIT routine
	BEQL	70$			; Br if not present
	BSBW	LT$GETFFI		; Else, create and initialize FFI
	BLBC	R0,70$			; Br if error
	MOVL	R4,GHB_L_FFI		; Else, save FFI block address

	CLRBIT	#GHB_STS_V_MULTI,-	; Clear the multicast busy flag
		 GHB_B_STATUS
	CLRL	GHB_L_MULTIBFR		; No multicast buffer is possible
	BSBW	LT$SETENTRY		; Setup multicast message

	MOVL	GHB_L_UCB0, R0		; Set unit seed in the ucb
	BEQL	70$			; No ucb0, bad news
	CLRW	UCB$W_MB_SEED(R0)	; Start with unit 1
	BSBW	LT$SET_TIMER		; Start timer, so we always have a tick

	MOVL	GHB$L_UCB+GHB_AREA, R5	; Get datalink UCB address
	INCW	UCB$W_REFC(R5)		; One more ref to keep it around for us
	BISW	#^x8000,UCB$W_DEVSTS(R5); Allow unit to be re-started
					;   automatically by datalink
	MOVZBL	#SS$_NORMAL, R0		; Return success
70$:	BLBS	R0, 80$			; Br if okay
	CLRL	GHB$L_UCB+GHB_AREA	; Else, forget about datalink UCB
	BSBB	LT$SHUTENTRY		; Clean it all up
	MOVZWL	#SS$_INSFMEM, R0	; Return not enough memory
80$:	ENBINT				; Restore IPL
	RSB


	.SBTTL	LT$GETFFI - Get the FFI block and initialize FFI interface
;++
; LT$GETFFI - Get FFI block
;
; Functional description:
;
;	Initialize the FFI interface.
;
; Inputs:
;
;	R1 = Address of FFI INIT routine in datalink driver
;	R5 = UCB address of datalink
;
; Outputs:
;
;	R0 = Status
;	R1-R4 are destroyed.
;
;--

LT$GETFFI:
	PUSHL	R1			; Save init routine address
	MOVZBL	#FFI$C_LENGTH,R1	; Set length of buffer to allocate
	JSB	G^EXE$ALONONPAGED	; Try to allocate an FFI block
	BLBC	R0,30$			; Br if error
	MOVL	R2,R4			; Copy FFI block address
	ASSUME	FFI$L_FL EQ 0
	ASSUME	FFI$L_BL EQ FFI$L_FL+4
	ASSUME	FFI$W_SIZE EQ FFI$L_BL+4
	ASSUME	FFI$B_TYPE EQ FFI$W_SIZE+2
	ASSUME	FFI$B_SPARE EQ FFI$B_TYPE+1
	CLRQ	(R2)+			; Clear link pointers
	MOVL	#<DYN$C_BUFIO@16>!FFI$C_LENGTH,(R2)+ ; Store block size & type
	ASSUME	FFI$L_CTX_DL EQ FFI$B_SPARE+1
	ASSUME	FFI$L_XMIT EQ FFI$L_CTX_DL+4
	ASSUME	FFI$L_XMIT_DONE EQ FFI$L_XMIT+4
	ASSUME	FFI$L_RECV_DONE EQ FFI$L_XMIT_DONE+4
	ASSUME	FFI$L_ERROR EQ FFI$L_RECV_DONE+4
	ASSUME	FFI$L_SHUT_DONE EQ FFI$L_ERROR+4
	CLRQ	(R2)+			; Zero CTX & XMIT routine address
	MOVAB	W^LT$XMT_FFIDONE,(R2)+	; Store XMIT Complete routine address
	MOVAB	W^LT$FFI_RCV_MSG,(R2)+	; Store RECV Complete routine address
	MOVAB	W^LT$ASYNCERR,(R2)+	; Store address of ERROR handler
	MOVAB	W^LT$SHUT_DONE,(R2)+	; Store address of SHUTDOWN handler
	ASSUME	FFI$L_SPARE0 EQ FFI$L_SHUT_DONE+4
	ASSUME	FFI$L_SPARE1 EQ FFI$L_SPARE0+4
	ASSUME	FFI$L_SPARE2 EQ FFI$L_SPARE1+4
	ASSUME	FFI$L_SPARE3 EQ FFI$L_SPARE2+4
	CLRQ	(R2)+			; Not used
	CLRQ	(R2)+
	ASSUME	FFI$L_DL_UCB EQ FFI$L_SPARE3+4
	ASSUME	FFI$L_PID EQ FFI$L_DL_UCB+4
	ASSUME	FFI$W_CHAN EQ FFI$L_PID+4
	MOVL	R5,(R2)+		; Store datalink UCB address
	CLRL	(R2)+			; Zero PID
	CLRW	(R2)+			; Zero CHAN
	MOVZBL	#SS$_NORMAL,R0		; Return success
30$:	POPL	R1			; Restore R1
	BLBC	R0,90$			; Br if allocation error
	CLRL	R3			; No parameters
	JSB	(R1)			; Else, call datalink init routine
	BLBS	R0,90$			; Br if success
	MOVL	R4,R0			; Else, copy FFI block address	
	BSBW	LT$DEALPOOL		; Deallocate the FFI block
	CLRL	R0			; Return failure
90$:	RSB

	.SBTTL	LT$SHUTENTRY  - Shutdown entry point
;++
; LT$SHUTENTRY - Shutdown LTDRIVER entry point
;
; Functional description:
;
;	Shutdown things when we are done.
;
; Inputs:
;	none
;
; Implicit inputs:
;
;	Called in user context.
;
; Outputs:
;	none
;--

LT$SHUTENTRY:
	DSBINT	#LAT$C_IPL		; Sync with rest of things
	SETBIT	#GHB_STS_V_SHUT,-	; Indicate that shutdown has been
		 GHB_B_STATUS		;    requested

;
;	Deallocate and shut down all the circuits
;
	MOVAL	GHB_L_CSBTABLE, R9	; Table of CSB addresses
	MOVZBL	#LAT$C_MAX_CSBS, R10	; and its length
40$:	MOVL	(R9)+, R8		; Get a CSB address
	BEQL	60$			; No CSB address here
	BSBW	LT$CIRCDEAD		; Kill all processes on this one
60$:	SOBGTR	R10, 40$		; Til end of table

;
; We can reduce our interest in the datalink UCB here early because
; the LAT control program still has a channel to the UCB and is still
; active.   The UCB will disappear when the LATCP deassigns its last
; channel to it.
;

	MOVL	GHB$L_UCB+GHB_AREA, R9	; Get datalink UCB and reduce our interest
	BEQL	80$			; No ucb here
	BICW	#^x8000,UCB$W_DEVSTS(R9); Don't want datalink to re-start
					;   any more!
	DECW	UCB$W_REFC(R9)		; Let datalink UCB go away.
	CLRL	GHB$L_UCB+GHB_AREA	; Forget we ever had it
					; This prevents more circuits from
					; being accepted.
	;
	;  Wait for any datalink re-start timer to expire. Spin on
	;  the INTERLOCK bit.
	;
	SETIPL	#IPL$_ASTDEL		; Prevent us from being deleted,
					;  but allow scheduling activity
70$:	BBC	#14,UCB$W_DEVSTS(R9),80$ ; Proceed if UCB can evaporate
	BSBB	BUILD_TQE		; Wait around for a while
	BRB	70$			; Try again

80$:
;
;	Now we must wait for all the CSBs to disappear.  We must not leave
;	here until all the processes have run down and the CSBs are gone
;	since latstart can be used again very quickly and that could cause
;	CSBs to be allocated again.  If processes don't run down we will
;	be stuck here until they do.
;
	SETIPL	#IPL$_ASTDEL		; Prevent us from being deleted,
					;  but allow scheduling activity
	BRB	110$			; See if CSB's are all gone
	;
	;  Now delay while we wait for CSB's to run down
	;
100$:	BSBB	BUILD_TQE		; Build TQE to wait on and wait

110$:	MOVAL	GHB_L_CSBTABLE,R9	; Table of CSB addresses
	MOVZBL	#LAT$C_MAX_CSBS, R10	;   and its length
120$:	MOVL	(R9)+, R8		; Get a CSB address
	BNEQ	100$			; Just spin here looking
	SOBGTR	R10, 120$		; Til end of table
	;
	;  Now wait for all the UCBs to dissappear except unit 0
	;
	BRB	160$			; Check if we're all done

140$:	BSBB	BUILD_TQE		; Build TQE to wait on and wait
	;
	;  Now delay while we wait for terminal UCB's to run down
	;
160$:	MOVL	GHB_L_UCB0,R0		; Get the LT UCB address
	BEQL	180$			; ???
	MOVL	UCB$L_CRB(R0),R1	; Get the CRB address
	CMPW	CRB$W_REFC(R1),#1	; All done ?
	BNEQ	140$			; Br if no	
180$:	;
	;  Reset completion routines for datalink's FFI interface
	;
	SETIPL	#LAT$C_IPL		; Sync access to rest of driver
	MOVL	GHB_L_FFI, R5		; Get FFI block address
	BEQL	200$			; Br if none
	MOVAB	W^LT$DROPCXB,-		; Drop all RECEIVE buffers
		FFI$L_RECV_DONE(R5)
	MOVAB	W^LT$FFIPOSTDONE,-	; Deallocate all TRANSMIT CXBs
		FFI$L_XMIT_DONE(R5)
200$:	;
	;  Deallocate the multicast buffer
	;
	MOVL	GHB_L_MULTIBFR,R0	; Get the multicast buffer
	BEQL	220$			; Br if none
	ASSUME	GHB_STS_V_MULTI EQ 0
	BLBS	GHB_B_STATUS,220$	; Br if multicast buffer is active
	BSBW	LT$DEALPOOL		; Else, deallocate the multicast buffer
220$:	CLRL	GHB_L_MULTIBFR		; Forget we had a multicast buffer
	;
	;  Flush all CSBs on the old CSB display queue
	;
240$:	REMQUE	@GHB$Q_OLD_CSBS+GHB_AREA,R0 ; Get CSB address
	BVS	300$			; Br if none
	BSBW	LT$DEALPOOL		; Else, deallocate the CSB
	BRB	240$			; Loop til done
300$:	MOVB	#LAT$C_KEEP_CSB,-	; Reset number of CSBs to keep around
		GHB_B_OLD_CSBCNT
	;
	;  Mark LTDRIVER as inactive
	;
	CLRB	GHB_B_STATUS		; Clear ACTIVE flag to stop timer
					;   clear SHUTdown flag
					;   clear MULTIcast buffer flag
	ENBINT
	RSB


	.SBTTL	TQE TIMER BUILDING AND WAITING ROUTINES
;++
; BUILD_TQE - Build a TQE
;
; Inputs:
;	IPL = ASTDEL
;
; Implicit inputs:
;
;	Called in user context
;
; Outputs:
;	R0-R5 are destroyed
;--

BUILD_TQE:
	JSB	G^EXE$ALLOCTQE		; Allocate a TQE (returns IPL = ASTDEL)
	BLBC	R0,90$			; Br if allocation failure
	MOVB	#TQE$C_SSSNGL,TQE$B_RQTYPE(R2) ; Indicate single shot request
	MOVAB	B^SHUT_TIMER,TQE$L_FPC(R2) ; Set wake up routine address
	MOVPSL	-(SP)			; Push current PSL to resume process
	ASSUME	IPL$_SYNCH EQ IPL$_TIMER
	SETIPL	#IPL$_SYNCH		; Sync access to system data base
	MOVQ	G^EXE$GQ_SYSTIME,R0	; Get current time
	ADDL	#LAT$C_SHUTDELAY,R0	; Calculate expiration time
	ADWC	#0,R1			; Add carry to top half
	MOVL	R2,R5			; Copy TQE address
	JSB	G^EXE$INSTIMQ		; Insert TQE on timer queue
	CLRBIT	#GHB_STS_V_TQE,-	; Indicate TQE not complete - yet
		 GHB_B_STATUS
	BRB	60$			; Wait for TQE
40$:	BBS	#GHB_STS_V_TQE,-	; Br if TQE is complete
		 GHB_B_STATUS,90$
	MOVPSL	-(SP)			; Push current PSL to resume process
60$:	MOVL	G^SCH$GL_CURPCB,R4	; Get current PCB address
	MOVZBL	#RSN$_ASTWAIT,R0	; Set waiting resource
	JSB	G^SCH$RWAIT		; Make process wait for resource
	BRB	40$			; Check if TQE expired
90$:	RSB				; Return to caller

;++
; SHUT_TIMER
;
;	This routine wakes up the waiting process
;
; Inputs:
;	R4 = PCB address
;	R5 = TQE address
;
;	IPL = IPL$_TIMER
;
; Outputs:
;	R0 is destroyed
;	R5 = TQE address of system non-repeating TQE
;--

SHUT_TIMER:
	SETBIT	#GHB_STS_V_TQE,-	; Indicate TQE has completed
		 GHB_B_STATUS
	MOVZBL	#RSN$_ASTWAIT,R0	; Set waiting resource
	JSB	G^SCH$RAVAIL		; Mark resource	available
	MOVL	R5,R0			; Copy TQE address
	BSBW	LT$DEALPOOL		; Deallocate the TQE
	MOVAL	G^EXE$AL_TQENOREPT,R5	; Setup SYSTEM no repeat TQE address
	RSB				; Return to caller

	.SBTTL	LT$SHUT_DONE - Datalink shutdown complete entry
;++
; LT$SHUT_DONE - Datalink shutdown complete entry point
;
; Functional description:
;
;	Deallocate the FFI block when datalink is all done.
;
; inputs:
;	R4 = FFI block address
;
; outputs:
;	R0,R1,R4 are destroyed
;	All other registers must be preserved
;--

LT$SHUT_DONE::
	PUSHR	#^M<R2,R3,R5>		; Save registers
	MOVL	GHB_L_FFI,R0		; Get FFI block address
	CLRL	GHB_L_FFI		; Zero pointer to FFI block
	BSBW	LT$DEALPOOL		; Deallocate the FFI block
	POPR	#^M<R2,R3,R5>		; Restore registers
	RSB

	.SBTTL	LT$ASYNCERR - Process async errors from datalink
;++
; LT$ASYNCERR - Process async errors from datalink
;
; Functional description:
;
; 	Do Nothing.
;
;--
LT$ASYNCERR:
	RSB

	.SBTTL	LT$SETENTRY  - Set a new multicast message
;++
; LT$SETENTRY - Set new multicast message
;
; Functional description:
;
; Take the data from the multicast data area and store it in a new message
; or bump the incarnation so we know to do it next time.
;
; Inputs:
;	None.
;
; Outputs:
;	R0 = success or failure
;	All other registers are preserved.
;
; Implicit outputs:
;	Multicast timer set to 1 second interval.
;
;--

LT$SETENTRY:
	DSBINT	#LAT$C_IPL
	PUSHR	#^M<R1,R2,R3,R4,R5,R6>	; Save registers
	CLRL	R6			; Assume no old CXB change flags
	MOVL	GHB_L_MULTIBFR, R2	; Get the Multicast CXB
	BEQL	10$			; Br if none, go make one
	INCB	GHB_B_INCARN		; Bump the incarnation count
	ASSUME	GHB_STS_V_MULTI EQ 0
	BLBC	GHB_B_STATUS, 5$	; Br if multicast buffer is free
	BRW	70$			; Else, do this operation later
	;
	;  Multicast buffer is available, deallocate it!
	;
5$:	MOVB	XMT_B_MC_CHG_FLAG(R2),R6; Save previous change flags
	MOVL	R2, R0			; Deallocate the old CXB buffer
  	CLRL	GHB_L_MULTIBFR		; NO more mutlicast CXB buffer
	BSBW	LT$DEALPOOL		; Dump the buffer

10$:	MOVZWL	GHB_W_MC_SIZE, R1	; Get size of data set by LATCP
	ADDL	#XMT_B_MC_SET, R1	;    plus message overhead
	JSB	G^EXE$ALONONPAGED	; Now get the buffer
	BLBC	R0, 80$			; No pool for buffer
	MOVW	R1, CXB$W_SIZE(R2)	; Size of buffer
	ASSUME	CXB$B_CODE EQ CXB$B_TYPE+1
	MOVW	#<1@8>!DYN$C_CXB,-	; Set type and indicate multicast
		CXB$B_TYPE(R2)		;  buffer
	MOVW	#XMT_T_DATA,CXB$W_BOFF(R2) ; Set offset to start of data
	MOVL	R2, GHB_L_MULTIBFR	; Save address of the buffer
	;
	; Copy fixed portion of multicast message
	;
	MOVAB	GHB_T_MC_MSG,R1		; Point to msg template
	MOVC3	#XMT_C_MC_LENGTH,(R1),-	; Copy the fixed portion of message
		 XMT_T_DATA(R2)
	;
	; Copy the variable data set by LATCP
	;
	MOVAB	GHB_T_MC_DATA,R1	; Get address of variable data
	MOVC3	GHB_W_MC_SIZE,(R1),(R3)	; Copy the variable data
	;
	; Set change flags, and incarnation number
	;
	MOVL	GHB_L_MULTIBFR,R2	; Get back the multicast buffer
	XORB3	#XMT_CHFLG_M_ALL,R6,-	; Set change flags
		 XMT_B_MC_CHG_FLAG(R2)
	MOVB	GHB_B_INCARN,-		; Set incarnation number
		 XMT_B_MC_INCARN(R2)
	MOVAB	XMT_T_DATA(R2), R0	; Address of start of data
	SUBL	R0, R3			; Calculate the length
	MOVW	R3, CXB$W_BCNT(R2)	; Set length of message
	;
	; Copy the node name and descriptor for the START message
	;
	MOVAB	GHB_T_MC_DATA+2,R1	; Get address of multicast variable data
	MOVAB	GHB_T_STRT_VAR,R3	; Get address of start msg variable data
	MOVL	R3, R6			; Save address of start of variable data
	MOVZBL	(R1)+, R0		; Get size of group codes
	ADDL	R0, R1			; Calculate address of node name
	MOVZBW	(R1), R0		; Get size of node name
	INCW	R0			; Include the byte count
	MOVC3	R0,(R1),(R3)		; Copy the node name
	MOVZBW	(R1), R0		; Get size of node descriptor
	INCW	R0			; Include the byte count
	MOVC3	R0,(R1),(R3)		; Copy the node descriptor
	CLRW	(R3)+			; No location text, no parameters
	SUBL	R6, R3			; Calculate length of start message
	ADDW3	#STRT_C_LENGTH, R3, -	; Store length in holding cell
		 GHB_W_STRT_LEN
70$:	MOVZWL	#SS$_NORMAL, R0		; Return success
80$:	MOVW	#1, GHB_W_MULTIMR	; Send multicast msg on next tick
90$:	POPR	#^M<R1,R2,R3,R4,R5,R6>	; Restore registers
	ENBINT
	RSB


	.SBTTL	LT$UNIT_INIT  - Unit Initialization
;++
; LT$UNIT_INIT - Unit Initialization
;
; Functional description:
;
; This routine performs a simple unit initialization.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0-R3 are modified
;--

LT$UNIT_INIT:				
	BBS	#UCB$V_POWER,-		; Skip if power fail recovery
		UCB$L_STS(R5), 70$	;

	MOVL	G^TTY$GL_DPT,R1		; Address of class dpt
	MOVZWL	DPT$W_VECTOR(R1),R0	; Locate class driver vector table
	ADDL	R0,R1			; Relocate base address
	MOVL	R1,UCB$L_TT_CLASS(R5)	; Set terminal class driver vector

	MOVL	CLASS_GETNXT(R1),UCB$L_TT_GETNXT(R5)
	MOVL	CLASS_PUTNXT(R1),UCB$L_TT_PUTNXT(R5)
	MOVL	UCB$L_DDB(R5),R0	; Get DDB address
	MOVL	CLASS_DDT(R1),DDB$L_DDT(R0)
	MOVL	CLASS_DDT(R1),UCB$L_DDT(R5) ; Set DDT address in UCB

	TSTW	UCB$W_UNIT(R5)		; Special action for ucb 0
	BEQL	20$			; Its is unit zero
	CLRBIT	#UCB$V_TEMPLATE,-	; All others lose the template
		UCB$L_STS(R5)		;  bit so they won't clone on assign
	BRB	40$			; Continue
20$:	MOVL	R5, GHB_L_UCB0		; Save address of ucb zero
;
; We are setting or clearing some bits in the LTA0 device here so that all
; later lta devices will have them set/clear the same way.  These bits are
; different from the defaults that are set in the sysgen parameters for
; the other types of terminals.
;
;	SETBIT	#TT$V_MODEM, -		; Set modem so we do modem
;		UCB$L_TT_DECHAR(R5)	;  processing for this terminal
	SETBIT	#TT$V_REMOTE,-		; Set remote so we know its a remote
		UCB$L_TT_DECHAR(R5)	;  terminal forever.
					; See setup_ucb routine for reasons
	CLRBIT	#TT2$V_AUTOBAUD,-	; We do not autobaud here.
		UCB$L_TT_DECHA1(R5)	;
	SETBIT	#TT2$V_HANGUP,-		; Set default for terminal to hangup
		UCB$L_TT_DECHA1(R5)	; on logout.  this can be cleared by
					; the user from his terminal.
	SETBIT	#TTY$V_PC_NOTIME,-	; no timer service please
		 UCB$W_TT_PRTCTL(R5)	; ...
40$:	;
	; Finish initializing UCB.
	;
	BSBB	LT$UCB_INIT		; Initialize the terminal UCB
	BRB	90$			; And leave

70$:	MOVL	UCB$L_LT_CSB(R5), R0	; On power fail, reset the timeout
	BEQL	90$			; No CSB, just forget it
	MOVW	CSB_W_TIMRESET(R0),-	; And just wait on some thing
		CSB_W_TIMEOUT(R0)	; To happen.
90$:	RSB

	.SBTTL	LT$UCB_INIT  - Initialize a terminal UCB
;++
; LT$UCB_INIT - Initialize a terminal UCB
;
; Functional description:
;
;	Init the terminal UCB before starting a process to use it.
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;	R5 = UCB address
;	R0, R1 clobbered
;--

LT$UCB_INIT:
	TSTW	UCB$W_UNIT(R5)		; Is this unit #0?
	BEQL	90$			; Br if yes, skip it
	TSTW	UCB$W_REFC(R5)		; Any channels attached?
	BNEQ	40$			; Br if yes, don't reinit UCB
	ASHL	UCB$W_UNIT(R5),#1,R1	; Build unit's bit mask
	MOVW	R1,UCB$B_ERTCNT(R5)	; Save it
	CLRB	UCB$B_LT_LOCID(R5)	; Flag as available (no local slot indx)
	MOVAL	LT$VECTOR,-		; Set the port address in ucb
		UCB$L_TT_PORT(R5)	;  in case port driver reloaded
	CLRL	UCB$L_TT_WFLINK(R5)	; Zero to force reinit of queue head
	MOVL	UCB$L_TT_CLASS(R5),R1	; Address class vector table
	JSB	@CLASS_SETUP_UCB(R1)	; Init UCB fields
40$:
	MOVB	#UCB$M_LT_DATA,-	; Look for data first time
		 UCB$B_LT_DATAW(R5) 
	MOVB	#LAT$C_UCB_BUFSIZ,-	; Init buffer
		UCB$B_LT_MAXC(R5)	;	...
	CLRB	UCB$B_LT_CURC(R5)	;	...
	CLRB	UCB$B_LT_TCRED(R5)	;	...
	CLRW	UCB$W_TT_OUTLEN(R5)	; No data waiting
90$:	RSB

	.SBTTL	LT$STARTIO  - Start I/O routine
;++
; LT$STARTIO - Start I/O Operation
;
; Functional description:
;
; This routine is entered from the device independent terminal startio
; Routine to enable output interrupts on an idle unit.
;
; Inputs:
;
; R3 =	character	and	cc = plus
; R3 =	address		and	cc = minus	and	R2 = count
; R5 = ucb address
;
; Outputs:
;
;	R5 = UCB address
;	R0,R1,R2,R3 and R4 are modified
;--

LT$STARTIO:				; Start I/O on unit
	PUSHR	#^M<R5,R6,R8,R9,R10>
	MOVL	UCB$L_LT_CSB(R5), R8	; Get Circuit State Block
	BEQL	85$			; Br if UCB is hanging up
	;
	;  Dispatch on our terminal UCB state
	;
	$DISPATCH   UCB$B_LT_STATE(R5),TYPE=B,-
	<-	; state		; action
	  <UCB$C_LT_STATE_KILL	168$>,-	; KILL state, flush data
	>

	;  All other states -- okay to send data

	BISB	#UCB$M_LT_DATA,-	; Assume output data available
		 UCB$B_LT_DATAW(R5) 
	;
	;   Buffer data locally
	;
5$:	$DISPATCH   UCB$B_TT_OUTYPE(R5),TYPE=B,-
	<-	; type		; action
		< 0	170$>,-		; No data, allow more calls
		< 1	10$>,-		; Single character
	>
	;
	;  Default to burst data
	;
	MOVL	UCB$L_TT_OUTADR(R5),R3	; Get output buffer address
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	;  and charcter count
	BRB	30$			; Continue in common path

10$:	MOVAB	UCB$B_LT_MAXC(R5),R0	; Get address of maxc
	CMPB	(R0)+,(R0)		; Any room left ?
	BGTR	20$			; Br if yes
	DECB	(R0)			; Make room for it
20$:	INCB	(R0)			; Update count
	MOVZBL	(R0),R1			; Get count
	ADDL	R1,R0			; Form destination address
	MOVB	R3,(R0)			; Load character
;
;	We are setting up the address and count of buffered characters in
;	case we are balanced and we should send these characters in a msg
;	to come out of balanced mode
;
	MOVZBL	UCB$B_LT_CURC(R5), R2	; Get count of buffered characters
	MOVAB	UCB$B_LT_CBUF(R5), R3	; Get address of buffer
30$:	BBC	#FLAG_V_RRF,-		; Br if we can we send an
		CSB_B_FLAG(R8),70$	;  unsolicited message
60$:	BRW	190$
;
; Transmit data to concentrator
;
70$:	DECB	UCB$B_LT_TCRED(R5)	; Use a credit
	BGEQ	90$			; Br if we have one to use
80$:	INCB	UCB$B_LT_TCRED(R5)	; Else, no credits
;
;	Woops.  We find we have data and we can't send it anywhere since
;	we have no credit.  Never mind we can just leave here.  We will
;	receive a credit message eventually.  We are set non-balanced here
;	and if we leave so that all the int bits are turned off in the
;	other ucbs, and this one, then we won't get anymore embarrassing
;	startio calls.  When we get the credit message we will start things
;	up again.
;
	BRW	180$			; Leave quietly

;
;	We have nowhere to put the data and the circuit is down, so just
;	clear interrupt expected, discard the data and return
;
85$:	BRW	168$			; Leave, flush data & clear INT expected

90$:	MOVAQ	CSB_Q_XBUFQ(R8),R6	; Get transmit buffer queue address
	CMPL	(R6), R6		; Is there a transmit buffer?
	BEQL	80$			; Br if no transmit buffer, ignore it
	MOVB	#1, CSB_B_NUM_SLOTS(R8)	; We have data for the server now
	SETBIT	#FLAG_V_RRF,-		; No more unsolicited messages
		 CSB_B_FLAG(R8)		;
	MOVW	#LAT$C_HOST_TIMER, -	; Set retransmit timer
		 CSB_W_XMTTMO(R8)	; 
	MOVL	(R6), R6		; Get the buffer address
	MOVAB	UCB$B_LT_CBUF(R5), R0	; Address the UCB extension
	CMPL	R3, R0			; Is that our buffer?
	BNEQ	100$			; Br if no
; ***
; Reading the code I noticed the following line(s) would not work if
; the startio entry were to discover that it were balanced after 
; previous previous calls stored data in the UCB extensions because 
; we were not balanced. I guess that never happens, because UCB$B_LT_CURC
; would not be equal to one, as assumed below, but some higher value. BEM
; ***
	DECB	UCB$B_LT_CURC(R5)	; Yes. Don't save the character there
100$:
	MOVAB	XMT_T_MDATA(R6), R9	; Address of the slot to use (first)
	MOVZBL	UCB$B_LT_SLOTSZ(R5), R10; Get the maximum slot size

	ASSUME SLT_B_DSTID EQ 0
	ASSUME SLT_B_SRCID EQ <SLT_B_DSTID+1>
	ASSUME SLT_B_COUNT EQ <SLT_B_SRCID+1>
	ASSUME SLT_B_CRED EQ <SLT_B_COUNT+1>

	ASSUME	UCB$B_LT_LOCID EQ UCB$B_LT_REMID+1

	MOVW	UCB$B_LT_REMID(R5), (R9)+ ; Load remote and local ids
	MOVB	R10, (R9)+		; Save the character count
	;
	; Extend credits to concentrator if needed
	;
	ADDB3	UCB$B_LT_XCRED(R5),-	; See if we need to send
		#LAT$C_MAX_RCRED,R0	;   a credit to the remote
	ADDB	R0,UCB$B_LT_RCRED(R5)	; Add them to total credits to send
	SUBB	R0,UCB$B_LT_XCRED(R5)	; Credits have been extended
	MOVB	UCB$B_LT_RCRED(R5), (R9)+ ; Load credits
	CLRB	UCB$B_LT_RCRED(R5)	; Don't send them again!

110$:	CMPL	R2, R10			; Do we have more than we can handle?
	BLEQU	120$			; Br if no, its just fine
	MOVL	R10, R2			; Use just what we can handle
120$:	SUBL	R2, R10			; Adjust what we have left
; ***
; Reading the code I noticed the following line(s) would not work if
; the startio entry were to discover that it were balanced after 
; previous calls stored data in the UCB extensions because 
; we were not balanced. I guess that never happens, because R2 would
; not reflect the UCB extension data area. BEM
; ***
	ADDL2	R2,UCB$L_TT_OUTADR(R5)	; Update UCB state
	SUBW2	R2,UCB$W_TT_OUTLEN(R5)	; Update UCB state
	PUSHL	R5			; Save the UCB address
	MOVC3	R2,(R3),(R9)		; Copy the string
	POPL	R5			; Restore the UCB address
	MOVL	R3,R9			; Set address of next available byte
	TSTL	R10			; Do we have any left?
	BEQL	155$			; Br if no, all done.
	JSB	@UCB$L_TT_GETNXT(R5)	; Else, call back class driver for more
	BEQL	150$			; Br if no more to be had
	BGTR	140$			; Br is single character
	;
	;  Found a burst of data
	;
	MOVL	UCB$L_TT_OUTADR(R5),R3	; Get output buffer address
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	;  and charcter count
 	BRB	110$			; Else buffer address

140$:	;
	;  Found a single character
	;
	MOVL	#1, R2			; Else, just one character returned
	MOVB	R3, (R9)		;  and fake many chars returned
	MOVL	R9, R3			; Copy buffer address
	BRB	110$			;  and continue

150$:	BICW	#UCB$M_INT,UCB$L_STS(R5);Allow more start io calls (checked)
	BICB	#UCB$M_LT_DATA,-	;  no output data available
		 UCB$B_LT_DATAW(R5) 
155$:	SUBL3	R6, R9, R2		; Make the length of the data to
	SUBL	#XMT_T_DATA, R2		;  transmit
	INCL	R9			; Round end address of data
	BICL	#1,R9			;	...
	MOVL	R9,CXB$L_T_ENDADR(R6)	; Store it in the CXB
	SUBL	#<<XMT_T_MDATA- -	; Make total characters in slot
		XMT_T_DATA> + -		; minus those already accounted for
		SLT_T_DATA>, R2		; beyond the circuit and slot headers
	MOVB	R2, <SLT_B_COUNT+-	; Store that count away.
		XMT_T_MDATA>(R6)	; In the first slot maxc

	.IF DEFINED LT_XMT_CHECK
	;
	;  debug code
	;
	MOVQ	CSB_T_CIRCHDR(R8),-		; Move the circ header
		XMT_T_DATA(R6)			; to look at real msg
	MOVZBL	XMT_B_NUM_SLOTS(R6), R1		; number of valid slots
	BNEQ	160$				; We have some, skip check
	; No slots - we must only have a circuit header!
	MOVAB	XMT_T_MDATA(R6), R0		; Past circuit header
	CMPL	R0, R9				; Only have a circuit header?
	BEQL	160$				; Br if yes, okay
	DEBUG					; Not correct

	.ENDC	;; DEFINED LT_XMT_CHECK

160$:	MOVL	R8, R4			; CSB address for call
	BSBW	LT$XMITONE		; Transmit the buffer
	POPR	#^M<R5,R6,R8,R9,R10>
	RSB

168$:	;
	;  Discard output data, no session active !
	;
	BSBW	LT$FLUSH_DATA		; Flush the output data

170$:	;
	;  Allow more calls to startio
	;
	BICW	#UCB$M_INT, -		; Allow more calls here
		UCB$L_STS(R5)		;
180$:	POPR	#^M<R5,R6,R8,R9,R10>
	RSB

;
;	Not balanced, so buffer data if we can.
;	R2 = count
;	R3 -> data
;

190$:	MOVAB	UCB$B_LT_CBUF(R5), R4	; Address of character buffer
	CMPL	R3, R4			; Is this the character buffer?
	BEQL	210$			; Br if yes, check if its full
	MOVZBL	UCB$B_LT_CURC(R5), R0	; Calculate amount of room
	CLRL	R1			;  left in the output buffer
	SUBB3	R0, -			;	...
		UCB$B_LT_MAXC(R5), R1	;	...
	CMPL	R1, R2			; Do we have room?
	BLEQ	180$			; Br if no, so shut output off
	CLRW	UCB$W_TT_OUTLEN(R5)	; Else, forget about the data here.
	ADDB2	R2, UCB$B_LT_CURC(R5)	; Calculate the number of chars
	MOVAB	(R4)[R0], R1		;  and get address to put them
200$:
	PUSHL	R5			; Save the UCB address
	MOVC3	R2,(R3),(R1)		; Copy the string
	POPL	R5			; Restore the UCB address

210$:	CMPB	UCB$B_LT_CURC(R5), -	; Is buffer full?
		UCB$B_LT_MAXC(R5)
	BGEQ	180$			; Br if yes, shut off output
	JSB	@UCB$L_TT_GETNXT(R5)	; Else, get more data
	BEQL	170$			; No more data, so just return
	BRW	5$			; Else, process data


	.SBTTL	LT$FLUSH_DATA  - Flush buffered output data and drain TT buffer
;++
; LT$FLUSH_DATA - Flush buffered output data and drain class driver buffer
;
; Functional description:
;
; Flush buffered output data and drain class driver output buffer.
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;	R3 is destroyed.
;--

LT$FLUSH_DATA:
20$:	JSB	@UCB$L_TT_GETNXT(R5)	; Call back for more to class driver
	BEQL	90$			; Br if no more to be had
	BRB	20$			; Else, drain all output data
90$:	CLRW	UCB$W_TT_OUTLEN(R5)	; Clear CLASS driver output data
	CLRB	UCB$B_LT_CURC(R5)	; Dump UCB output buffering
	RSB

	.SBTTL	LT$ABORT  - Abort (flush) buffered output data
;++
; LT$ABORT - Abort buffered output data
;
; Functional description:
;
; Abort (flush) buffered output data
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;
;--

LT$ABORT:
	CLRB	UCB$B_LT_CURC(R5)	; Dump UCB buffering
	CLRW	UCB$W_TT_OUTLEN(R5)	; Dump pending class driver data,
					;  (might have dissappeared)
	BISB	#UCB$M_LT_ABORT,- 	; Abort requested
		 UCB$B_LT_DATAW(R5)
	RSB




	.SBTTL	LT$FLOW_CHANGE  - Change flow control

;+
;	LT$FLOW_CHANGE
;
; Function: Inform terminal server of change in host flow control.
;		The terminal server will mimic host policy.
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;
;-

LT$FLOW_CHANGE:
	BISB	#UCB$M_LT_FLOW,-	; Flow change 
		 UCB$B_LT_DATAW(R5)
	RSB


	.SBTTL	LT$XON  - Resume input stream into class driver
;++
; LT$XON - Resume input stream into class driver
;
; Inputs:
;	R3 = XON character
;	R5 = UCB address
;
; Outputs:
;
;	R3 is destroyed
;--
LT$XON:
	PUSHR	#^M<R0,R1,R11,AP>	; Save registers
	CLRBIT	#UCB$V_LT_OVFLOW,-	; Clear overflow indicator
		 UCB$B_LT_LATSTS(R5)
	MOVL	UCB$L_LT_INPBUF(R5),R0	; Get address of input buffer
	BEQL	70$			; Br if none, nothing to do
	INCB	UCB$B_LT_XCRED(R5)	; Okay to return credit now

	.IF DEFINED LT_CRED_CHECK
	BLEQ	10$			; Br if okay
	DEBUG				; Else, we went too far
10$:
	.ENDC	;; DEFINED LT_CRED_CHECK

	ASSUME	UCB$B_LT_LATSTS EQ UCB$B_LT_DATAW+1

	BISW	#<UCB$M_LT_INPUT@8>!UCB$M_LT_DATA,- ; Data potentially available
		 UCB$B_LT_DATAW(R5)	;   and INPUT stream in enabled
	BISB	#UCB$M_INT,UCB$L_STS(R5); Force no data to be returned
	MOVZWL	INB_W_BCNT(R0),AP	; Get count of bytes remaining
	MOVZWL	INB_W_BOFF(R0),R11	; Get offset to start of input data
	ADDL	R0,R11			; Calculate address of input data
	;
	;  Feed remaining data into class driver
	;
30$:	MOVZBL	(R11)+,R3		; Get next character
	JSB	@UCB$L_TT_PUTNXT(R5)	; Pass character to class driver
	BBS	#UCB$V_LT_OVFLOW,-	; Br if overflow, wait for next XON
		 UCB$B_LT_LATSTS(R5),50$
	SOBGTR	AP,30$			; Loop if more
	MOVL	UCB$L_LT_INPBUF(R5),R0	; Get input buffer address
	BSBW	LT$DEALPOOL		; Deallocate the input buffer
	CLRL	UCB$L_LT_INPBUF(R5)	; Zero input buffer pointer
50$:	BICB	#UCB$M_LT_INPUT,-	; Input stream is now disabled
		 UCB$B_LT_LATSTS(R5)
70$:	POPR	#^M<R0,R1,R11,AP>	; Restore registers
	RSB

	.SBTTL	LT$XOFF  - Stop input stream into class driver

;++
; LT$XOFF - Stop input stream into class driver
;
; Inputs:
;	R3 = XOFF character (^S or ^G)
;	R5 = UCB address
;	AP = count of bytes remaining
;	R11 = address of input data
;
; Implicit inputs:
;
;	UCB$V_LT_INPUT bit must be on UCB$B_LT_LATSTS status byte.
;
; Outputs:
;	R3 is destroyed
;
;--
LT$XOFF:
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save registers
	CMPB	R3,#TTY_C_BELL		; Is this a control_G?
	BEQL	90$			; Br if yes, do nothing
	BBC	#UCB$V_LT_INPUT,-	; Br if input stream not enabled
		 UCB$B_LT_LATSTS(R5),90$
	CMPL	AP,#1			; Any data to buffer? (counting current)
	BLEQ	90$			; Br if no, skip it
	DECL	AP			; Else, account for character just passed
	SETBIT	#UCB$V_LT_OVFLOW,-	; Set overflow indicator
		 UCB$B_LT_LATSTS(R5)
	MOVL	UCB$L_LT_INPBUF(R5),R2	; Get input buffer
	BNEQ	30$			; Br if one there
	ADDL3	#INB_C_LENGTH,AP,R1	; Else, calculate length of buffer
	JSB	G^EXE$ALONONPAGED	; Allocate a buffer
	BLBC	R0,90$			; Br if no buffer
	MOVL	R2,UCB$L_LT_INPBUF(R5)	; Save address of input buffer
	MOVW	R1,INB_W_SIZE(R2)	; Set size of input buffer
30$:	ASSUME	INB_B_SPARE EQ INB_B_TYPE+1
	MOVZBW	#DYN$C_BUFIO,INB_B_TYPE(R2) ; Set structure type
	MOVW	AP,INB_W_BCNT(R2)	; Set size of remaining string
	MOVW	#INB_C_LENGTH,INB_W_BOFF(R2) ; Set offset to start of data
	;
	;  Don't return credit... wait for XON
	;
	DECB	UCB$B_LT_XCRED(R5)	; Don't return credit

	.IF DEFINED LT_CRED_CHECK
	CMPB	UCB$B_LT_XCRED(R5),-	; Did we goof?
		#-LAT$C_MAX_RCRED
	BGEQU	10$			; Br if okay
	DEBUG				; Else, we went too far
10$:
	.ENDC	;; DEFINED LT_CRED_CHECK

	MOVC3	AP,(R11),INB_C_LENGTH(R2) ; Copy the data
90$:	POPR	#^M<R0,R1,R2,R4,R5>	; Restore registers
	RSB				; Return to caller


	.SBTTL	LT$FFI_RCV_MSG - FAST Interface Receive Complete routine
;++
; LT$FFI_RCV_MSG - FAST Interface Receive Complete routine
;
; Functional description:
;
; Each time a frame is received, the data is passed to the class driver
; for each terminal represented within the frame. Echoed data is copied
; into a frame to be transmitted back to the concentrator, and finally
; the transmit frame is queued for transmission after appropriate
; virtual circuit maintenance functions are performed.
;
; Inputs:
;
;	R3 = CXB address
;	R4 = FFI address
;
;	IPL = SYNCH
;
; Outputs:
;
;	R1-R5 are preserved.
;
;	The interrupt is dismissed when the received frame
;	has been compeletely processed. The CXB is always
;	returned to the datalink driver.
;
;--
	
	ASSUME	LAT$C_IPL EQ IPL$_SYNCH
LT$FFI_RCV_MSG:
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP> ; Save registers

	MOVZWL	CXB$W_BOFF(R3),R6	; Get offset to start of data
	ADDL	R3,R6			; Get pointer to start of data

	.IF DEFINED LT_HISTORY
;
;	Save history of receives
;
	MOVAB	RCV_B_FLAG(R6), R0	; Address is circuit header
	BSBW	LT$HISTORY		; Store the data
	.ENDC	;; DEFINED LT_HISTORY

	INC_CTR	GHB$L_RCOUNT+GHB_AREA	; Count frame
;
;  Validate received frame
;
	MOVZWL	RCV_W_DSTID(R6),R0	; Get remote vci
	BNEQ	120$			; Got index, okay
	CMPB	#<MTYP_C_START@FLAG_V_MTYPE>!- ; Is this a start message?
		FLAG_M_MASTER,-
		RCV_B_FLAG(R6)
	BNEQ	91$			; Br if no, signal protocol error
;
;  START message received on an inactive circuit, try to start up a
;  new circuit.
;
	TSTL	GHB$L_UCB+GHB_AREA	; Data link UCB still here?
	BEQL	99$			; No, then don't accept circuit
	TSTW	RCV_W_SRCID(R6)		; Is the source ID zero?
	BEQL	96$			; Br if yes, protocol error
	TSTB	RCV_B_SEQ(R6)		; Is this the correct sequenced msg?
	BNEQ	97$			; Br if not, protocol error
	BSBW	LT$NEW_CIRCUIT		; Initialize and/or allocate CSB
	BLBS	R0, 19$			; Go ahead, CSB address in R8
					;  startup any transmits waiting
	TSTL	R0			; Are we ignoring a duplicate start msg?
	BNEQ	100$			; Br if yes, just retransmit start msg
	INC_CTR	GHB$L_RESOURCE+GHB_AREA	; Else, no CSB to use
	BRB	99$			; So just ignore it

19$:	BRW	190$			; Long branch

91$:	MOVZBL	#GHB$V_START,FP		; Invalid START message received
	BRB	98$			; continue
93$:	MOVZBL	#GHB$V_CSBRANGE,FP	; Bad range on CSB index
	BRB	98$			; continue
94$:	MOVZBL	#GHB$V_CSBINVALID,FP	; Invalid CSB index
	BRB	98$			; continue
95$:	MOVZBL	#GHB$V_CSBSTALE,FP	; Stale CSB index
	BRB	98$			; continue
96$:	MOVZBL	#GHB$V_INVALIDREMID,FP	; Invalid remote circuit id
	BRB	98$			; continue
97$:	MOVZBL	#GHB$V_INVALIDSEQ,FP	; Invalid sequence number
;;;	BRB	98$			; continue
98$:	SETBIT	FP,GHB$L_PROTOMASK+GHB_AREA ; Set bit mask
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; Increment counter
99$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP> ; Restore registers
	RSB				; Return to caller

	;
	;  A duplicate frame was received
	;
100$:	INC_CTR	GHB$L_DUPLMSG+GHB_AREA	; We received a duplicate message
	INC_CTR	GHB$L_RETRANS+GHB_AREA	; We are retransmitting a message
	BRW	LT$REPLY_REXMIT		; This data is stale, resend buffers
;
;
;  Non-zero circuit ID !
;	 - circuit must be active already
;
;  Inputs:	R0 = CSB index
;		R3 = CXB address
;		R6 = Pointer to start of data
;
;
120$:	MOVZBL	R0,R1			; Get CSB index
	CMPL	R1, #LAT$C_MAX_CSBS	; Range check
	BGTR	93$			; Br if bad range, protocol error
	MOVL	GHB_L_CSBTABLE-4[R1],R8	; Get CSB address
	BEQL	94$			; Br if invalid CSB, protocol error
	CMPW	R0,CSB_W_LOCID(R8)	; Valid reference ?
	BNEQ	95$			; Br if no, Stale reference to CSB
	INC_CTR	CSB_Z_LCB+LCB_L_MSG_RCV(R8) ; Count one more rcvd msg
	;
	;  Check ACK number and complete any transmits acknowledged
	;
130$:	MOVZBL	RCV_B_ACK(R6), R3	; Get the ack from the message
	MOVB	R3, CSB_B_RACK(R8)	;
	SUBB	CSB_B_XSEQ(R8), R3	; Set up the normallized ack
	MOVAQ	CSB_Q_XWAITQ(R8), R2	; Look through the wait queue for it
	MOVL	R2, R1			;

140$:	MOVL	(R1), R1		; Next item in queue
150$:	CMPL	R1, R2			; End of queue
	BEQL	190$			; Done with that search
	SUBB3	CSB_B_XSEQ(R8), -	; Normallize the seq of message
		XMT_B_SEQ(R1), -	;
		R0			;
	CMPB	R0, R3			; If the seq is greater than ack,
	BGTR	140$			; wait on another ack
	MOVL	(R1), R4		; Save link to next item
	REMQUE	(R1), R1		; Remove acked message from wait queue
	INSQUE	(R1), -			; And insert on tail of transmit queue
		@CSB_Q_XBUFQ+4(R8)	;
	DECB	CSB_B_XMTCNT(R8)	; One less to transmit
	MOVL	R4, R1			; Restore link
	BRB	150$			;
170$:	;
	;  Invalid sequence number received
	;
	INC_CTR	CSB_Z_LCB+LCB_W_SEQ_ERR(R8),W ; Bad sequence number
	BRB	100$			; Also count as duplicate
180$:	;
	;  No transmit buffer available
	;
	INC_CTR	GHB$L_NOXBFR+GHB_AREA	; Not transmit buffer available
	BRW	99$			; And exit
	;
	;  Make sure that we have a transmit buffer to respond with
	;
190$:	MOVAQ	CSB_Q_XBUFQ(R8), R2	; Look to see if we have at least one
	CMPL	R2, (R2)		; transmit buffer
	BEQL	180$			; Br if None, just retransmit and wait

	MOVW	CSB_W_TIMRESET(R8),-	; Reset timer for timeout of circuit
		CSB_W_TIMEOUT(R8)	; Since we got a valid message.
	CMPB	RCV_B_SEQ(R6),CSB_B_RSEQ(R8) ; Right sequence number ?
	BNEQ	170$			; Br if no, retransmit all messages


;
;  Dispatch on message type
;
;   Inputs:
;
;	R8 = CSB address
;	R6 = CXB address
;
	INCB	CSB_B_RSEQ(R8)		; Next time it's the next number
	MOVB	RCV_B_SEQ(R6),CSB_B_XACK(R8) ; Tell other guy we got this one
	EXTZV	#FLAG_V_MTYPE,-		; Obtain the message type
		#FLAG_S_MTYPE,-
		RCV_B_FLAG(R6), R0

	$DISPATCH	R0,TYPE=B,-	; Dispatch on message type
	<-	; msg type	; action
		<MTYP_C_RUN	LT$RCV_RUN_MSG>,- ; RUN message received
		<MTYP_C_START	LT$RCV_START_MSG>,- ; START message received
		<MTYP_C_HALT	LT$RCV_HALT_MSG>,- ; HALT message received
	>

;;	BRB	LT$FORCE_HALT		; All others, force halt

	.SBTTL	PROCESS RECEIVED MESSAGE
;++
;
;  Other guy is halted or all screwed up
;
;--

LT$FORCE_HALT:		; receive halt msg
			; invalid circuit state in msg
			; invalid circuit state in CSB
			; invalid local vci
	SETBIT	#GHB$V_HALT,-
		GHB$L_PROTOMASK+GHB_AREA ; Circuit forced to halted
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; Increment protocol error counter

LT$STATE_HALT:
	BSBW	LT$CIRCDEAD		; Circuit is dead now
	BRW	LT$REPLY_REXMIT		; Transmit halt message

;++
;
;  Other system is halted
;
;--

LT$RCV_HALT_MSG:
	BSBW	LT$CIRCDEAD		; Circuit is dead now
	BRW	LT$REPLY_DONE		; All done

;++
;
;  Other guy is starting up
;
;--

LT$RCV_START_MSG:

	$DISPATCH CSB_B_STATE(R8),TYPE=B,- ; Dispatch on our CSB state
	<- ; state		; action
	<CSB_C_STATE_HALT	LT$STATE_START>,- ; Enter the START state
	<CSB_C_STATE_START	LT$REPLY_MSG>,-	 ; Re-send START message
	<CSB_C_STATE_RUN	LT$STATE_HALT>,- ; Enter the HALTED state
	>

	BRB	LT$FORCE_HALT		; What kind of kinky state is this ?

;++
;
;  Other guy is running
;
;--

LT$RCV_RUN_MSG:

	$DISPATCH	CSB_B_STATE(R8),TYPE=B,- ; Dispatch on our CSB state
	<-	; state			; action 
		<CSB_C_STATE_HALT	LT$REPLY_MSG>,- ; Send STOP message
		<CSB_C_STATE_START	LT$STATE_ENTER_RUN>,- ; Enter RUN state
		<CSB_C_STATE_RUN	LT$STATE_RUN>,- ; Stay in RUN state
	>

	BRB	LT$FORCE_HALT		; What kind of kinky state is this ?

	.SBTTL	CIRCUIT STATE TRANSITIONS
;++
;
;  We can go only from halted to starting
;
;--

LT$STATE_START:
	MOVB	#CSB_C_STATE_START,-	;
		CSB_B_STATE(R8)		; Now we are starting
	MOVB	#MTYP_C_START@FLAG_V_MTYPE,- ; Set the start message type
		CSB_B_FLAG(R8)		;
	MOVW	RCV_W_SRCID(R6),-	;
		CSB_W_REMID(R8)		; Save his circuit id
	MOVL	CSB_Q_XBUFQ(R8),R9	; Format a start message
	MOVAB	GHB_T_STRT_MSG,R0	; Get start address of template data
	MOVC3	GHB_W_STRT_LEN,(R0),-	; Copy the start message
		 XMT_T_MDATA(R9)
	MOVL	R3, CXB$L_T_ENDADR(R9)	; Store end address of data
	BRW	LT$REPLY_ALT		; Go send the reply message

;++
;
;  We transit to the running state only from the starting state
;
;--

LT$STATE_ENTER_RUN:			; Enter the RUNNING state
	MOVB	#CSB_C_STATE_RUN,-	; Now we are running
		CSB_B_STATE(R8) 
	MOVB	#MTYP_C_RUN@FLAG_V_MTYPE,- ; Set the run message type
		CSB_B_FLAG(R8)

;++
;
;  Update state from validated frame
;
;--

LT$STATE_RUN:
	CMPW	RCV_W_SRCID(R6),-	; Referencing a valid circuit?
		CSB_W_REMID(R8)
	BNEQ	LT$FORCE_HALT		; Br if not, force a halt
	MOVL	CSB_Q_XBUFQ(R8),R9	; Get transmit buffer address
	;
	;  Set up for the receive loop
	;
	CLRBIT	#FLAG_V_RRF,-		; No response requested until
		CSB_B_FLAG(R8)		;  a credit is used
	CLRB	CSB_B_NUM_SLOTS(R8)	; Assume no output data (balanced)
	CLRW	CSB_W_XMTTMO(R8)	; Circuit state is no longer timed
	MOVAB	RCV_T_MDATA(R6),R7	; Receive buffer first slot address
	MOVAB	XMT_T_MDATA(R9),R9	; Transmit buffer first slot address
	MOVZWL	CSB_W_MAX_MSGSIZ(R8),R10 ; Total chars available to slots
	MOVZBL	RCV_B_NUM_SLOTS(R6),FP	; Get slot loop count
	BNEQ	SLOT_LOOP_IN		; Got some input data
	BRW	SLOT_LOOP_OUT		; Go process output buffer


	.SBTTL	PROCESS RECEIVED SLOT DATA
;++
; PROCESS RECEIVED SLOT DATA
;
; Functional description:
;
; Now we are set up to pass data to and from the class driver:
;
; The following loop copies data from the receive buffer into the class
; driver.
;
; Inputs:
;	R0-R4 available
;	R5 =  UCB address
;	R6 =  CXB address
;	R7 =  current receive buffer slot address
;	R8 =  CSB address
;	R9 =  current transmit buffer slot address
;	R10 = transmit buffer bytes left
;	R11 = scratch (used as current input slot character copy base register)
;	AP =  scratch (used as loop count register)
; 	FP =  number of slots to process in received message
;
; Outputs:
;	none.
;
;   We continue by processing the output slot loop.
;
;--
	.ENABLE	LOCAL_BLOCK
SLOT_LOOP_IN:				; Input data slot loop
	MOVZBL	SLT_B_DSTID(R7),R1	; Is this slot alive ?
	BNEQ	20$ 			; Br if possible
	TSTB	SLT_B_SRCID(R7)		; Is the remote index valid?
	BEQL	10$			; Br if not, ignore slot
	;
	;  Zero local slot index with non-zero remote (someone's attempting
	;    to login). Must be a start slot!
	;
	EXTZV	#4,#4,SLT_B_CRED(R7),R0	; Get slot type
	CMPB	#SLT_C_STR_SLOT,R0	; Is this a start slot ?
	BNEQ	LOOP_ABORT		; Br if not, ignore slot
	BSBW	LT$ALC_UCB		; Try to allocate an LT UCB
	BLBS	R0, 10$			; Br if success
	INC_CTR	GHB$L_RESOURCE+GHB_AREA	; Else, no UCB for us to use
	;
	;  Send back a reject slot in the case of resource errors
	;
	ASSUME	SLT_S_REJ_SLOT&1 EQ 1	; Assume we need rounding
	CMPL	R10,-			; Enough room for REJECT slot header?
		#SLT_S_REJ_SLOT+1
	BLSS	10$			; Nope, just ignore the data
	INCB	CSB_B_NUM_SLOTS(R8)	; Increment slot count
	MOVB	SLT_B_SRCID(R7),(R9)+	; Copy local id from receive message
	CLRB	(R9)+			; Tell him we are not here !
	MOVB	#SLT_S_REJ_LEN,(R9)+	; Load slot byte count
	MOVB	#SLT_C_REJ_SLOT@4,(R9)	; Load REJECT slot format
	BISB	#SLT_C_RESOURCE,(R9)+	; Load reason code (resource error)
	ASSUME	SLT_S_REJ_SLOT&1 EQ 1	; Assume we need rounding
	CLRB	(R9)+			; Round up to even boundary
	SUBL2	#SLT_S_REJ_SLOT+1,R10	; Adjust bytes left for other slots
10$:	BRW	NEXT_SLOT		; Just process the next slot.
20$:	;
	;  Validate UCB reference - non-zero local index
	;
	CMPB	R1, CSB_B_MAX_SLOTS(R8)	; Do a range check on the local index
	BGTRU	90$			; Br if not in range
	MOVL	CSB_L_UCBLST-4(R8)[R1],R5 ; Get UCB address
	BGEQ	70$			; That slot doesn't live here anymore
	CMPB	SLT_B_SRCID(R7),UCB$B_LT_REMID(R5) ; Valid remote reference?
	BEQL	LOAD_CREDITS		; Br if yes, process slot
	TSTB	SLT_B_SRCID(R7)		; Else, are we hanging up from remote?
	BNEQ	LOOP_ABORT		; Br if no, invalid slot
;
;  Received a zero in the slot source-id - is this a stop slot?
;
40$:	EXTZV	#4,#4,SLT_B_CRED(R7),R0	; Get slot type
	CMPB	#SLT_C_STP_SLOT,R0	; Is this a STOP slot?
	BNEQ	LOOP_ABORT		; Br if not, do nothing
	BSBW	LT$HANGUP_UCB_NOW	; Hangup the UCB to logout process
	BRB	NEXT_SLOT0		; Process next slot
;
;  Flag protocol error and ignore slot
;
LOOP_ABORT:
	SETBIT	#GHB$V_INVALIDLOCID,-
		GHB$L_PROTOMASK+GHB_AREA ; Invalid remote ID or slot format
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; 

;
;  Conditionally send stop slot
;
70$:	TSTB	SLT_B_SRCID(R7)		; Check remote slot index
	BEQL	NEXT_SLOT0		; Br if empty slot

	ASSUME	SLT_S_STP_SLOT&1 EQ 1	; Assume we need rounding
	CMPL	R10,-			; Enough room for STOP slot header?
		#SLT_S_STP_SLOT+1
	BLSS	NEXT_SLOT0		; Nope, just ignore the data
	INCB	CSB_B_NUM_SLOTS(R8)	; Increment slot count
	MOVB	SLT_B_SRCID(R7),(R9)+	; Copy local id from receive message
	CLRB	(R9)+			; Tell him we are not here !
	MOVB	#SLT_S_STP_LEN,(R9)+	; Load slot byte count
	MOVB	#SLT_C_STP_SLOT@4,(R9)+	; Load stop slot format
	MOVB	#SLT_C_INVSLOT,(R9)+	; load reason code
	ASSUME	SLT_S_STP_SLOT&1 EQ 1	; Assume we need rounding
	CLRB	(R9)+			; round up to even boundary
	SUBL2	#SLT_S_STP_SLOT+1,R10	; Adjust bytes left for other slots
	BRB	NEXT_SLOT0		; Go do next input slot
;
;  Range check error, is this really a disconnect slot ?
;
90$:	TSTB	SLT_B_SRCID(R7)		; Empty remote slot index? (stop slot?)
	BEQL	NEXT_SLOT0		; Br if yes, ignore the slot.
	SETBIT	#GHB$V_INVALIDREMID,-
		GHB$L_PROTOMASK+GHB_AREA; Invalid LOCID with REMID non_zero
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; Count as protocol error
	BRB	70$			; Send a stop slot

NEXT_SLOT0:
	BRW	NEXT_SLOT		; Branch aid

	.DISABLE LOCAL_BLOCK

	.SBTTL	PROCESS SLOT CREDITS RECEIVED
;++
;
;  Update UCB credit account from received message slots
;
;--
LOAD_CREDITS:
	MOVB	SLT_B_CRED(R7),R0	; Get credits and slot type
	ASSUME	SLT_C_DA_SLOT EQ 0	; assumption
	BGEQ	50$			; Got a DATA_A slot
	EXTZV	#0, #4, SLT_B_CRED(R7), R0 ; Get the credit counts
	EXTZV	#4, #4, SLT_B_CRED(R7), R1 ; Get the slot type
	$DISPATCH	R1,TYPE=B,-	; Dispatch on slot type
	<-	; slot type	; action
		<SLT_C_DB_SLOT	20$>,-	; DATA_B slot????
		<SLT_C_ATT_SLOT 40$>,-	; Attention slot
	>

	BRW	LOOP_ABORT		; All others, including Reject slot

;  DATA_B slot

20$:	BISB	#UCB$M_LT_DATA,-	; Remember to at least send back the
		 UCB$B_LT_DATAW(R5)	;    credits!
	INCB	UCB$B_LT_XCRED(R5)	; One less credit on remote end (negative)
	BLEQ	40$			; Br if credits not exceeded, proceed
	BSBW	LT$HANGUP_UCB		; Else, Hangup the UCB to logout process

;  ATTention slot, IGNORE DATA

40$:	ADDB	R0,UCB$B_LT_TCRED(R5)	; Update credits
	BRB	NEXT_SLOT		; Skip to next slot

;  RUN slot

50$:	ADDB	R0,UCB$B_LT_TCRED(R5)	; Update credits


	.IF DEFINED LT_CRED_CHECK
	CMPB	UCB$B_LT_TCRED(R5),#2
	BLEQ	60$			; Br if ok
	SETBIT	#GHB$V_BADCREDITS,-
		GHB$L_PROTOMASK+GHB_AREA; Too many credits in host
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; Too many credits in host
	BSBW	LT$HANGUP_UCB		; Hangup the UCB to logout process
60$:
	.ENDC	;; DEFINED LT_CRED_CHECK

;
;  Move terminal data through class driver
;
;	R3 - contains the character
;	R5 - UCB address
;
	MOVZBL	SLT_B_COUNT(R7),AP	; Character count for this slot
	BEQL	NEXT_SLOT		; No input here
	MOVAB	SLT_T_DATA(R7),R11	; Source of characters
	BBS	#UCB$V_LT_HANGUP, -	; If device is hanging up, do not con-
		UCB$B_LT_LATSTS(R5),NEXT_SLOT ; fuse class driver with more data
	INCB	UCB$B_LT_XCRED(R5)	; One less credit on remote end (negative)
	BLEQ	70$			; Br if credits not exceeded, proceed
	BSBW	LT$HANGUP_UCB		; Else, Hangup the UCB to logout process
	BRB	NEXT_SLOT		; Continue
70$:	;
	;  Indicate that input stream is running again, and data is potentially
	;  available.
	;
	ASSUME	UCB$B_LT_LATSTS EQ UCB$B_LT_DATAW+1

	BISW	#<UCB$M_LT_INPUT@8>!UCB$M_LT_DATA,- ; Data potentially available
		 UCB$B_LT_DATAW(R5)	;   and INPUT stream in enabled
	BISB	#UCB$M_INT,UCB$L_STS(R5); Force no data to be returned
	;
	;  Dump characters into class driver
	;
80$:	MOVZBL	(R11)+,R3		; Get next character
	BBS	#UCB$V_LT_OVFLOW,-	; Br if overflow, wait for XON
		 UCB$B_LT_LATSTS(R5),90$
	JSB	@UCB$L_TT_PUTNXT(R5)	; Pass character to class driver
	BNEQ	ECHO_ERROR		; Br if character being echoed
	SOBGTR	AP,80$			; Do all characters

90$:	BICB	#UCB$M_LT_INPUT,-	; Input stream is now disabled
		 UCB$B_LT_LATSTS(R5)
;
;  Bump pointers to the next slot
;
NEXT_SLOT:
	MOVZBL	SLT_B_COUNT(R7), R0	; Max bytes in the slot
	MOVAB	<SLT_T_DATA+1>(R7)-	; Compute address of next slot +1
		[R0], R7		; to help round to word
	BICL	#1, R7			; make it a word boundary.
	DECL	FP			; Loop on all slots
	BEQL	SLOT_LOOP_OUT		; Done all input slots, now process
					;  any output data
	BRW	SLOT_LOOP_IN		; Process all received slots

ECHO_ERROR:				; Character being echoed???
	DEBUG				;;&& Should not get to here

	.SBTTL	BUILD A STOP SLOT
;++
; BUILD A STOP SLOT
;
; Functional description:
;
; Build a stop slot in the out message buffer, then delete the UCB.
;
; Inputs:
;	R5  = UCB address
;	R8  = CSB address
;	R9  = current transmit buffer slot address
;	R10 = transmit buffer bytes left
;
; Outputs:
;	R5  = UCB address
;	R8  = CSB address
;	R9  = current transmit buffer slot address
;	R10 = transmit buffer bytes left
;
;--

SEND_STOP_SLOT:
	TSTB	UCB$B_LT_CURC(R5)	; Is UCB data waiting?
	BEQL	30$			; Br if no, send the STOP slot
	BRW	CREDIT_CHECK		; Send data if our credit is good

30$:	CMPL	R10, #SLT_T_DATA	; Enough room for STOP slot?
	BLEQ	ONE_LESS		; Br if no, send it next time
	INCB	CSB_B_NUM_SLOTS(R8)	; Update slot count

	ASSUME	SLT_B_DSTID EQ 0
	MOVB	UCB$B_LT_REMID(R5), (R9)+ ; Send the remote slot index

	ASSUME	SLT_B_SRCID EQ SLT_B_DSTID+1
	ASSUME	SLT_B_COUNT EQ SLT_B_SRCID+1
	CLRW	(R9)+			; Zero SRCID for a stop slot
					;   and no data 
	ASSUME	SLT_B_CRED EQ SLT_B_COUNT+1
	MOVB	#SLT_C_STP_SLOT@4,(R9)+	; Load stop slot format & no credits
	SUBL	#SLT_T_DATA,R10		; Adjust bytes left for other slots
					;;&&;;** Skip call if HOST BIND
	BSBW	LT$KILLUCB		; Wipe out the UCB now.
	BRB	ONE_LESS		; Get next slot

	.SBTTL	PROCESS OUTPUT SLOT DATA
;++
; PROCESS OUTPUT SLOT DATA
;
; Functional description:
;
; Now output any waiting data from each UCB on this circuit and any
; data returned from the class driver is transfered to the appropriate
; output slot in the transmit buffer.
;
; Inputs:
;	R0-R4 available
;	R5  = UCB address
;	R6,R7 =  scratch
;	R8  = CSB address
;	R9  = current transmit buffer slot address
;	R10 = transmit buffer bytes left
;	R11-FP = scratch
;
; Outputs:
;	none.
;
; We continue processing in the send reply message section.
;
;--
SLOT_LOOP_OUT:
	MOVZBL	CSB_B_REFC(R8),FP	; Set output UCB loop count
	MOVAL	CSB_L_UCBLST(R8),R7	; Set base address of UCB vector
ONE_LESS:				; One less unit left
	DECL	FP			; Any UCBs left ?
	BGEQ	10$			; Br if yes
	BRW	LOOP_EXIT		; Else, exit loop
10$:
	MOVL	(R7)+,R5		; Get next UCB address
	BEQL	10$			; ignore holes in non-dense vector
	;
	;  Dispatch on our terminal UCB state
	;
	$DISPATCH   UCB$B_LT_STATE(R5),TYPE=B,-
	<-	; state		; action
	<UCB$C_LT_STATE_STOP	SEND_STOP_SLOT>,- ; STOP state, send stop slot
	<UCB$C_LT_STATE_KILL	ONE_LESS>,-	; KILL state, ignore this
	>
					; RUN and START, just fall through

	TSTB	UCB$B_LT_DATAW(R5)	; Is there any data waiting?
	BEQL	ONE_LESS		; Br if no, skip this UCB
;
;  Check for ABORT message first
;
	BBCC	#UCB$V_LT_ABORT,-	; Br if no abort requested
		 UCB$B_LT_DATAW(R5),30$ ;   and clear flag
	;
	;  Send an ATTention slot
	;
	ASSUME	SLT_S_ATT_SLOT&1 EQ 1	; Assume we need rounding
	CMPL	R10, #SLT_S_ATT_SLOT+1	; Enough room for ATTENTION slot ?
	BLEQ	50$			; Br if no, skip it (use br helper)
	INCB	CSB_B_NUM_SLOTS(R8)	; Update slot count

	ASSUME	UCB$B_LT_LOCID EQ UCB$B_LT_REMID+1
	ASSUME	SLT_B_DSTID EQ 0
	ASSUME	SLT_B_SRCID EQ SLT_B_DSTID+1
	ASSUME	SLT_B_COUNT EQ SLT_B_SRCID+1
	ASSUME	SLT_B_TYPE EQ SLT_B_COUNT+1
	ASSUME	SLT_B_ATT_CONTROL EQ SLT_B_TYPE+1

	MOVW	UCB$B_LT_REMID(R5), (R9)+ ; Send the remote slot id
	MOVB	#SLT_S_ATT_LEN,(R9)+	; Set ATTENTION slot data size
	MOVB	#SLT_C_ATT_SLOT@4,(R9)+	; Load ATTn type & no credits

	ASSUME	SLT_S_ATT_SLOT&1 EQ 1	; Assume we need rounding
	MOVW	#SLT_ATT_M_ABORT,(R9)+	; Send abort flag & zero byte
	SUBL	#SLT_S_ATT_SLOT+1,R10 	; Account from room taken
;
;  Check for flow control message
;
30$:
	BBCC	#UCB$V_LT_FLOW,-	; Br if no flow requested
		 UCB$B_LT_DATAW(R5),90$ ;   and clear flag
	;
	;  Send DATA_B slot
	;
	DECB	UCB$B_LT_TCRED(R5)	; Use up a credit
	BGEQ	40$			; Br if okay, continue
	INCB	UCB$B_LT_TCRED(R5)	; Else, restore credits
	SETBIT	#UCB$V_LT_FLOW,-	; Remember to send flow control
		 UCB$B_LT_DATAW(R5)	;  when we have good credit
	BRB	90$			; And continue

40$:
	ASSUME	SLT_S_DB_SLOT&1 EQ 1	; Assume we need rounding
	CMPL	R10,-			; Enough room for DATA_B slot ?
		 #<SLT_S_DB_SLOT+1>	;     rounded up
50$:	BLEQ	90$			; Br if no, skip it (branch helper)
	INCB	CSB_B_NUM_SLOTS(R8)	; Update slot count

	ASSUME	UCB$B_LT_LOCID EQ UCB$B_LT_REMID+1
	ASSUME	SLT_B_DSTID EQ 0
	ASSUME	SLT_B_SRCID EQ SLT_B_DSTID+1
	ASSUME	SLT_B_COUNT EQ SLT_B_SRCID+1
	ASSUME	SLT_B_TYPE EQ SLT_B_COUNT+1
	ASSUME	SLT_B_DB_CONTROL EQ SLT_B_TYPE+1
	ASSUME	SLT_B_DB_OFOF EQ SLT_B_DB_CONTROL+1
	ASSUME	SLT_B_DB_OFON EQ SLT_B_DB_OFOF+1
	ASSUME	SLT_B_DB_IFOF EQ SLT_B_DB_OFON+1
	ASSUME	SLT_B_DB_IFON EQ SLT_B_DB_IFOF+1

	MOVW	UCB$B_LT_REMID(R5), (R9)+ ; Send the remote slot id
	MOVB	#SLT_S_DB_LEN,(R9)+	; Set DATA_B data size
	MOVB	#SLT_C_DB_SLOT@4,(R9)+	; Load DATA_B type & no credits
	MOVB	#SLT_DB_M_IFENA!SLT_DB_M_OFENA,(R9)+ ; Assume default values
	MOVL	#<17@24>!<19@16>!<17@8>!<19@0>,(R9)+ ; Assume default values

	BITW	#TT$M_HOSTSYNC,UCB$L_DEVDEPEND(R5) ; Assumed ^S and ^Q
	BNEQ	60$			; Br if ok
	MOVW	#<7@0>,-2(R9)		; Else, we were wrong

60$:
	BITW	#TT$M_TTSYNC,UCB$L_DEVDEPEND(R5) ; Assumed ^S and ^Q
	BNEQ	70$			; Br if assumption was correct
	BICB	#SLT_DB_M_OFENA,-5(R9)	; Else, clear output flow enable
	BISB	#SLT_DB_M_OFDIS,-5(R9)	; and set output flow disable

70$:
	ASSUME	SLT_S_DB_SLOT&1 EQ 1	; Assume we need rounding
	CLRB	(R9)+			; Round up
	SUBL	#SLT_S_DB_SLOT+1,R10	; Adjust bytes left (rounded up)

;
;  Check if there is any output data waiting
;
90$:


;++
;
;  Any credits and enough room in output buffer for this slot ?
;
;--
CREDIT_CHECK:				; UNUSED LABEL (breaks up LSB)
;
;  Flush all characters to transmit buffer
;
;	R8 = CSB address
;	R5 = UCB address
;
	MOVZBL	UCB$B_LT_SLOTSZ(R5),R6	; Get maximum slot size
	CMPL	R10,R6			; Is space left greater?
	BGTR	10$			; Br if yes, then we can use it
	MOVL	R10,R6			; Else, use lesser size
10$:	SUBL	#SLT_T_DATA, R6		; Subtract slot header size
	BGTR	30$			; Br if enough room
20$:	SETBIT	#FLAG_V_RRF,-		; Else, indicate response requested
		 CSB_B_FLAG(R8)		;  since not all data fit in buffer
	BRW	ONE_LESS		; No room left in output slot
30$:	MOVL	R6,AP			; Get room left in output slot
	MOVAB	SLT_T_DATA(R9),R11	; Sink of characters
	;
	;  Check if we have credits, or if we need to return credits
	;  before building the message.
	;
	TSTB	UCB$B_LT_TCRED(R5)	; Any credits we can use to send msg?
	BGTR	40$			; Br if yes, okay to build data message
	ASSUME	LAT$C_MAX_RCRED EQ 1
	TSTB	UCB$B_LT_XCRED(R5)	; Remote have any credits?
	BNEQ	20$			; Br if yes, just leave now
	BRW	USE_CREDIT		; Else, send back credits
40$:	;
	;  Any data from startio ?
	;
	MOVZBL	UCB$B_LT_CURC(R5),R2	; Get characters in startio ?
	BEQL	70$			; Br if none
	MOVAB	UCB$B_LT_CBUF(R5),R3	; Set address of buffer
	CMPL	AP,R2			; Got enough room in xmit buffer?
	BGEQ	60$			; Br if yes
;
;	R2 = COUNT
;	R3 -> DATA
;
	SUBB2	AP, UCB$B_LT_CURC(R5)	; Save residual count
	PUSHL	R5			; Save the UCB address
	MOVC3	AP,(R3),(R11)		; Copy the string from UCB to output bfr
	POPL	R5			; Restore the UCB address
	MOVL	R3,R11			; Set address of next available byte
	MOVAB	UCB$B_LT_CBUF(R5), R2	; Copy residual chars to beginning
	MOVZBL	UCB$B_LT_CURC(R5), R3	;  of UCB buffer area
	PUSHL	R5			; Save the UCB address
	MOVC3	R3,(R1),(R2)		; Move the string up in the UCB
	POPL	R5			; Restore the UCB address
	CLRL	AP			; No more room left
	BRW	USE_CREDIT		; Use a credit and send them

60$:	CLRB	UCB$B_LT_CURC(R5)	; No data now
	SUBL2	R2,AP			; Adjust room left in slot
	PUSHL	R5			; Save the UCB address
	MOVC3	R2,(R3),(R11)		; Copy the string
	POPL	R5			; Restore the UCB address
	MOVL	R3,R11			; Set address of next available byte
	TSTL	AP			; Any room left in slot ?
	BLEQ	USE_CREDIT		; No, just transmit data
;
;  Check if there is any data from last time
;
70$: 	CVTWL	UCB$W_TT_OUTLEN(R5),R2	; Any data left from last time ?
	BLEQ	GET_MORE		; Br if no, try for new data
	MOVL	UCB$L_TT_OUTADR(R5),R3	; Get address of data
	CMPL	AP,R2			; Enough room in buffer ?
	BGEQ	80$			; Br if yes
	MOVL	AP, R2			; Use all the space we have left
80$:	SUBW2	R2,UCB$W_TT_OUTLEN(R5)	; Adjust descriptor
	ADDL2	R2,UCB$L_TT_OUTADR(R5)	; ...
	SUBL	R2, AP			; Adjust count of chars left
	PUSHL	R5			; Save the UCB address
	MOVC3	R2,(R3),(R11)		; Copy the string
	POPL	R5			; Restore the UCB address
	MOVL	R3,R11			; Set address of next available byte
	TSTL	AP			; Any room left now?
	BGTR	GET_MORE		; Br if yes, get some more data
	BRB	USE_CREDIT		; Else, try next slot

;
;  Loop draining class driver until no data is left or buffer is full
;
GET_MORE:
	JSB	@UCB$L_TT_GETNXT(R5)	; Get characters from class driver
;
; R1-R4		modified
; R3 = ??	and cc = 0		! No more data
; R3 = char	and cc = +		! One character
; R3 = ??	and cc = -		! Burst data (TT_OUTADR, TT_OUTLEN)
; R5 - ucb address
;
	BEQL	USE_CREDIT1		; No characters
	BLSS	GOT_A_LOT		; Got more than one character

	MOVB	R3,(R11)+		; Copy character to output
	DECL	AP			; Adjust room in slot
	BGTR	GET_MORE		; Go get more
	BRB	USE_CREDIT		; No room left in slot
GOT_A_LOT:
	MOVL	UCB$L_TT_OUTADR(R5),R3	; Get output buffer address
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	;  and charcter count
	CMPL	AP,R2			; Got enough room in output buffer?
	BGEQ	10$			; Br if yes
	MOVL	AP,R2			; Output maximum possible
10$:	SUBL2	R2,AP			; Adjust room left in slot
	ADDL	R2,UCB$L_TT_OUTADR(R5)	; Update output address
	SUBW2	R2,UCB$W_TT_OUTLEN(R5)	;  and charcter count
	PUSHL	R5			; Save the UCB address
	MOVC3	R2,(R3),(R11)		; Copy the string
	POPL	R5			; restore the UCB address
	MOVL	R3,R11			; set address of next available byte
	TSTL	AP			; Any room left in slot ?
	BGTR	GET_MORE		; Br if yes, look for more

	.SBTTL	CONSUME CREDIT WHEN FILLING IN SLOT FIELD
;
;  If any data was added to output slot, use credit locally, pass credit
;  to other end if needed, and set circuit mode to unbalanced.
;
	.ENABL	LSB
USE_CREDIT:
	BISW	#UCB$M_INT,UCB$L_STS(R5); Set interrupt expected, locks
					;  out transmits from STARTIO
	BRB	10$			; Continue

USE_CREDIT1:
	BICW	#UCB$M_INT,UCB$L_STS(R5); Clear interrupt expected
	BBS	#UCB$V_LT_OVFLOW,-	; Don't clear data waiting flag
		 UCB$B_LT_LATSTS(R5),10$;  if we're waiting for OVFLOW to clear
	BICB	#UCB$M_LT_DATA,-	; No more output data waiting
		 UCB$B_LT_DATAW(R5) 
10$:
;;&&	SUBL3	AP,R6,AP		; form character count in AP
;;&&	DECB	UCB$B_LT_TCRED(R5)	; Use up a credit
;;&&	BISB	#FLAG_M_RRF,-		; Set response requested flag
;;&&		 CSB_B_FLAG(R8)		; 
	BISB	#FLAG_M_RRF,-		; Set response requested flag
		 CSB_B_FLAG(R8)		; 
	SUBL3	AP,R6,AP		; Calculate character count in AP
	BEQL	20$			; Br if no data, DON'T use credit
	DECB	UCB$B_LT_TCRED(R5)	; Else, use up a credit
	ASSUME	SLT_C_DA_SLOT EQ 0
	ADDB3	UCB$B_LT_XCRED(R5),-	; Calculate credits to send to remote
		#LAT$C_MAX_RCRED,R0	;   system as DATA_A slot
	BRB	40$			; Send credits and data
	ASSUME	SLT_C_DA_SLOT EQ 0
20$:	ADDB3	UCB$B_LT_XCRED(R5),-	; See if we need to send
		#LAT$C_MAX_RCRED,R0	;   a credit to the remote
	BEQL	60$			; Br if no, send nothing
40$:	ADDB	R0,UCB$B_LT_RCRED(R5)	; Else, add in credits to send
	SUBB	R0,UCB$B_LT_XCRED(R5)	; Credits have been extended
;
;	Setup slot header and advance pointer to next transmit slot header
;
	ASSUME	UCB$B_LT_LOCID EQ UCB$B_LT_REMID+1
	ASSUME	SLT_B_SRCID EQ SLT_B_DSTID+1

	MOVW	UCB$B_LT_REMID(R5),-	; Set up slot connection ids
		 SLT_B_DSTID(R9)
	INCB	CSB_B_NUM_SLOTS(R8)	; Update slot count
	MOVB	AP,SLT_B_COUNT(R9)	; Load character count
	MOVB	UCB$B_LT_RCRED(R5),-	; Load slot type and credits
		 SLT_B_CRED(R9)
	ASSUME	SLT_C_DA_SLOT EQ 0
	CLRB	UCB$B_LT_RCRED(R5)	; Set RUN state, no more credits
	MOVL	R9, R0			; Copy slot starting address
	MOVL	R11, R9			; Address of start of next slot
	INCL	R9			; Make word address
	BICL	#1, R9			; which is even
	SUBL3	R0, R9, R0		; Compute bytes used by slot
	SUBL2	R0, R10			; Adjust bytes left for other slots
60$:	BRW	ONE_LESS		; go do next UCB
	
LOOP_EXIT:
;
;	Compute and save the number of bytes in the transmit buffer.
;
;	R9 -> end of data in the transmit buffer
;
	;
	;  There is a special case where the XMIT buffer can be taken,
	;  and that is when the circuit is halted. So if the circuit is
	;  in the HALT state, then we can assume we no longer have the
	;  XMIT buffer that we copied data into.
	;
	$DISPATCH	CSB_B_STATE(R8),TYPE=B,- ; Dispatch on our CSB state
	<-	; state			; action 
		<CSB_C_STATE_HALT	LT$REPLY_DONE>,- ; All done, exit
	>

	TSTB	CSB_B_NUM_SLOTS(R8)	; Are there any slots?
	BNEQ	80$			; Br if yes, continue
	BICB	#FLAG_M_RRF,-		; Else, clear RRF flag
		 CSB_B_FLAG(R8)		; 
80$:	MOVL	CSB_Q_XBUFQ(R8), R1	; Address of buffer
	MOVL	R9, CXB$L_T_ENDADR(R1)	; Save end address of data
	.DSABL	LSB

	.SBTTL	SEND REPLY RESPONSE TO RECEIVED MESSAGE

LT$REPLY_MSG:
;
;  We come here to transmit a new frame in response to a received frame
;
;	R8   =	CSB address
;
	MOVL	CSB_Q_XBUFQ(R8),R9	; Transmit buffer address

LT$REPLY_ALT:
	.IF DEFINED LT_XMT_CHECK
;
;	Debug code
;
;	check the format of the slots and make sure that they are
;	well formatted.
;
;	R8 = CSB address
;	R9 = transmit buffer address
;	R0-R3 clobbered
;
	MOVAQ	CSB_Q_XBUFQ(R8), R0		; Address of transmit head
	CMPL	R9, R0				; Is there a transmit buffer
	BNEQ	5$				; Nope, its the queue head
	DEBUG					; Can't be the queue head

5$:	MOVQ	CSB_T_CIRCHDR(R8),-		; Move the circ header
		XMT_T_DATA(R9)			; to look at real msg
	CMPB	XMT_B_FLAG(R9),-		; Only analyse running msgs
		#MTYP_C_RUN@FLAG_V_MTYPE	;  with slots
	BNEQ	50$				; Not a running message
	MOVL	CXB$L_T_ENDADR(R9), R2
	MOVAB	XMT_T_MDATA(R9), R0		; First slot address
	MOVZBL	XMT_B_NUM_SLOTS(R9), R1		; number of valid slots
	BNEQ	10$				; We have some
	;  No slot - message must only have a circuit header!
	CMPL	R2, R0				; Only circuit header?
	BEQL	50$				; Br if yes, okay
	DEBUG					; Not correct
	BRB	50$

10$:	MOVZBL	SLT_B_COUNT(R0), R3		; Look to next slot
	BGEQ	30$				; Must be greater or zero
	DEBUG					; Maxc not valid
30$:	ADDL	#SLT_T_DATA, R3			; Slot header length
	ADDL	R3, R0				; 
	INCL	R0				; Round to word boundary
	BICL	#1, R0				;
	CMPL	R0, R2				; Still inside buffer?
	BLEQU	40$				; Yep
	DEBUG					; Slot beyond buffer
40$:	SOBGTR	R1, 10$				; Check all slots
50$:
	.ENDC	;; DEFINED LT_XMT_CHECK

	MOVL	R8, R4				; CSB address to r4
	BSBW	LT$XMIT				; Transmit the buffer

LT$REPLY_DONE:					; All done
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP> ; Restore registers
	RSB


LT$REPLY_REXMIT:
;
;  Retransmit last message
;
;	R8 = CSB address
;
	MOVL	R8, R4			; CSB address to R4
	BSBW	LT$REXMIT		; Transmit all waiting buffers
	BRB	LT$REPLY_DONE		; Finish up


	.SBTTL	LT$CREATECSB  - Create a CSB
;++
; LT$CREATECSB - Create a CSB
;
;	Allocate a CSB for use and initialize it partially.
;
; Inputs:
;	R4 -> next entry in CSB table beyond the one that is free
;	R1 = length of UCB list at end of CSB
;
; Outputs:
;	R8 = new CSB address
;	R0 = success or failure
;
;	CSB table entry set to its address
;
;	R1-R2 are destroyed.
;--

LT$CREATECSB:
	ADDL	#CSB_C_FIXLENGTH+4,R1	; Add in size of fixed block +
					;  one "no access" UCB slot
	PUSHL	R3			; Save R3
	JSB	G^EXE$ALONONPAGED	; Get block
	POPL	R3			; Restore R3
	BLBC	R0, 10$			; Got block
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC5	#0,(SP),#0,R1,(R2)	; Zero block
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	MOVW	R1,CSB_W_SIZE(R2)	; Save size of CSB in CSB
	MOVB	#DYN$C_CDB, -		; Store an unlikely type in the 
		CSB_B_TYPE(R2)		; the block
	MOVAL	GHB_L_CSBTABLE, R0	; Create the slave index from the
	SUBL3	R0, R4, R0		; address in the CSB table
	DIVL2	#4, R0			; from 1 to n
	MOVB	R0, CSB_B_LOCIDN(R2)	; and save it in the CSB
    	MOVB	R0, CSB_B_INX(R2)	; Save it here also
	MOVB	GHB_B_LOC_CCHK[R0],-	; Obtain the check field for this
		CSB_B_LOCIDS(R2)	;     CSB slot
	;
	;  Initialize queue headers
	;
	MOVAB	CSB_Q_XBUFQ(R2), R0	; Initialize the queue headers for the
	MOVL	R0, (R0)		; transmit buffers
	MOVL	R0, 4(R0)		;
	MOVAB	CSB_Q_XWAITQ(R2), R0	;
	MOVL	R0, (R0)		;
	MOVL	R0, 4(R0)		;
	MOVL	R2, R8			; Return address of CSB here
	MOVL	R2, -(R4)		; Store address of CSB in table
	MOVZBL	#SS$_NORMAL, R0
10$:	RSB

	.SBTTL	 LT$NEW_CIRCUIT - Get Concentrator State Block
;++
; LT$NEW_CIRCUIT - Get concentrator state block and initialize it
;
; Functional description:
;
; Whenever a frame with a zero svci is seen and the circuit state is
; starting, we attempt to allocate a CSB and start a circuit.  First
; we check for a CSB with the same source address.  If any are found
; and the mvci matches and the state is starting, then we retransmit
; our starting message for that circuit.  If the other things are not
; true, then the circuit is clobbered to that source since the mvci
; does not match or the circuit is already running and the concentrator
; is trying to restart it perhaps because it rebooted.
;
; Inputs:
;	R3 =  CXB address
;	R6 =  receive buffer address
;	R10 = IDB address
;
; Outputs:
;	R6 =  receive buffer address
;	R8 =  CSB address
;	R0,R1,R2,R3,R4,R7 and R9 are modified
;--

LT$NEW_CIRCUIT:
	MOVAB	GHB_L_CSBTABLE,R4	; Find free entry in CSB_TABLE
	MOVZBL	#LAT$C_MAX_CSBS,R2	; Length of table  in longwords
10$:	MOVL	(R4)+,R8		; Get CSB address
	BEQL	30$			; Ignore unallocated ones for pass
;
;	If this is the same source address, then we are looking for a duplicate
;	starting message.  It will have the same local index and a state of
;	starting.  If this is not the case, then just clobber the circuit.
;
	CMPL	CXB$Q_STATION(R3),-	; NI source address match?
		CSB_Z_DST(R8)		;
	BNEQ	30$			; Br if not, look for more
	CMPW	CXB$Q_STATION+4(R3),-	; Rest match too?
		CSB_Z_DST+4(R8) 	;
	BNEQ	30$			; Br if not, look for more
	CMPW	RCV_W_DSTID(R6),-	; Is this a duplicate starting msg
		CSB_W_LOCID(R8)		;   with the same local vc indx/seq?
	BNEQ	20$			; Br if not, kill circuit
	CMPB	CSB_B_STATE(R8),-	; Is the state still starting?
		#CSB_C_STATE_START	;
	BNEQ	20$			; Br if not, kill circuit
	MOVL	#2, R0			; Else, tell higher code to retrans
	RSB				;   our starting message

20$:	BSBW	LT$CIRCDEAD		; Get rid of UCBs
	MNEGL	#1, CSB_Z_DST(R8)	; Form illegal address
	MNEGW	#1, CSB_Z_DST+4(R8)	;  to stop next compare

30$:	SOBGTR	R2,10$			; Try whole table
	;
	;  Search failed, try to find a free CSB 
	;
	BBS	#GHB_STS_V_SHUT,-	; Br if we are shutting down,
		 GHB_B_STATUS,50$	;   don't let connection succeed
	MOVAL	GHB_L_CSBTABLE, R4	; Look again for a free CSB
	MOVZBL	#LAT$C_MAX_CSBS, R2	; Set max CSBs
40$:	TSTL	(R4)+			; Is this slot free?
	BEQL	60$			; Br if yes, great
	SOBGTR	R2, 40$			; Loop til done
	;
	;  Return resouce error
	;
50$:	CLRL	R0			; Return failure indicating resource
	RSB				; failure

60$:	;
	;  Check the protocol version of the incoming message and reject all but
	;  our own.
	;
	MOVAB	RCV_T_MDATA(R6), R0	; Address of first slot
	CMPB	STRT_B_PVER(R0), -	; Check version number
		#LAT$C_CUR_VER
	BNEQ	50$			; Must be equal
	;
	;   Check the circuit timer value (in multiples of 10 ms).
	;   We will accept anything in the range 10 to 1270 ms; legal
	;   values are 1 to 127 in this byte field.
	;
	TSTB	STRT_B_CIR_TIMR(R0)	; Is this field positive and non-zero?
	BLEQ	50$			; Br if not, illegal value
;
;    ECO is not checked
;
;	R4 -> CSB table address -4
;
	;
	;  Compute size needed for UCB list at end of CSB,
	;  size is based on MIN [LAT$C_MAX_SLOTS, STRT_B_MAXSLOTS(R0)]
	;
	MOVZBL	#LAT$C_MAX_SLOTS,R5	; Assume ours is MIN value
	CMPB	STRT_B_MAXSLOTS(R0),R5	; Is rcvd slot count larger?
	BGEQU	70$			; Br if yes, use ours
	MOVB	STRT_B_MAXSLOTS(R0),R5	; Else, use smaller of two
70$:	ASHL	#2,R5,R1		; Multiply by 4, and save in R1

	BSBW	LT$CREATECSB		; Create a CSB
	BLBC	R0, 50$			; Br if resource error
	MOVB	R5,CSB_B_MAX_SLOTS(R8)	; Save the maximum allowed slot count
	;
	;  Save the server's name
	;
	ASSUME	STRT_B_SYS_LEN EQ STRT_T_NODE+GHB$K_NAMELEN
	MOVAB	RCV_T_MDATA(R6),R0	; Get address of first slot
	MOVZBL	STRT_B_NODE_LEN(R0),R1	; Get length of dest node name
	MOVAB	STRT_T_NODE(R0),R2	; Get address of dest node name
	ADDL	R1,R2			; Skip dest node name, point to src name
	MOVZBL	(R2),R1			; Get length of src (server) name
	CMPL	R1,#GHB$K_NAMELEN	; Is the name length okay?
	BLEQ	75$			; Br if yes, continue
	MOVZBL	#GHB$K_NAMELEN,R1	; Else, use maximum allowed
	MOVB	R1,(R2)			; Make size of name valid
75$:	INCL	R1			; Account for length byte
	PUSHR	#^M<R0,R3>		; Save registers
	MOVC3	R1,(R2),CSB_B_SERVER(R8) ; Copy the server name
	POPR	#^M<R0,R3>		; Restore registers
	;
	;  Make the circuit timeout value twice the keep_alive value
	;  received from the terminal server.
	;
	MOVW	#3600, CSB_W_TIMRESET(R8); Assume a default of one hour
	MOVZBL	STRT_B_KPA_TIMR(R0), R1	; Make timer reset value
	BEQL	80$			; Not a good value
	MULL2	#5,R1			; Look for five times the period,
	INCL	R1			;  and one more
	MOVZWL	R1,R5			; Check for overflow
	CMPL	R1,R5			; Did we overflow?
	BNEQ	80$			; Br if yes, use default value
	MOVW	R1, CSB_W_TIMRESET(R8)	; Set the value in the CSB
80$:	;
	;  Compute maximum buffer size to use
	;
	MOVW	#XMT_C_MAXDATA,-	; Assume ours is maximum allowed
		 CSB_W_MAX_MSGSIZ(R8)	;    message size
	SUBW	#XMT_C_HDRLEN,-		; Account for header is remotes size
		 STRT_W_MSGSIZ(R0)
	BLEQ	90$			; Br if not large enough
	CMPW	STRT_W_MSGSIZ(R0),-	; Is remotes buffer larger?
		 CSB_W_MAX_MSGSIZ(R8)
	BGEQU	90$			; Br if yes, use ours
	MOVW	STRT_W_MSGSIZ(R0),-	; Else, use smaller of two
		 CSB_W_MAX_MSGSIZ(R8)
90$:	;
	;  Note that locidn and xmit queue headers were setup by CREATECSB
	;
	MOVW	RCV_W_SRCID(R6),CSB_W_REMID(R8) ; In case of retransmit
	CLRB	CSB_B_NUM_SLOTS(R8)	; Mode default is balanced
	CLRW	CSB_W_XMTTMO(R8)	; Not timed state
	MOVW	CSB_W_TIMRESET(R8),-	; Set a nonzero timeout value
		 CSB_W_TIMEOUT(R8)	; even if the normal value is zero.
	CLRB	CSB_B_REFC(R8)		; No UCBs here
	MOVW	#LAT$C_PROGRESS,-	; Set for allowing progress
		 CSB_W_PROGRESS(R8)	; while we start up.

	MOVL	CXB$Q_STATION(R3),-	; Store remotes's NI address.
		 CSB_Z_DST(R8)
	MOVW	CXB$Q_STATION+4(R3),-	;	...
		 CSB_Z_DST+4(R8)
	MOVB	#CSB_C_STATE_HALT,-	; Circuit is halted
		 CSB_B_STATE(R8) 
	MNEGW	#1,CSB_W_XSEQ(R8)	; Initialize transmit sequence
	MOVW	#<-1@8!0>,CSB_W_RSEQ(R8); Initialize receive sequence
	;
	;  Obtain all necessary transmit buffers for use
	;
	CLRB	CSB_B_XMTBSY(R8)	; Not busy transmitting
	CLRB	CSB_B_XMTCNT(R8)	; No buffers waiting to transmit
	MOVAL	CSB_Q_XBUFQ(R8), R4	; Address of the transmit queue head
	MOVZBL	#LAT$C_XMT_BUFFERS, R5	; Set number of buffers

100$:	MOVZWL	#XMT_C_MAXLEN, R1	; Size of the buffers
	JSB	G^EXE$ALONONPAGED	; Allocate the buffer
	BLBC	R0, 110$		; No such buffer
	MOVW	R1, CXB$W_SIZE(R2)	; Store the size,
	ASSUME	CXB$B_CODE EQ CXB$B_TYPE+1
	MOVW	#DYN$C_CXB, -		; the block type
		CXB$B_TYPE(R2)		; and indicate not multicast buffer

	MOVL	R8,CXB$L_T_CSB(R2)	; Save CSB address in CXB
	MOVQ	CSB_Z_DST(R8),-		; Initialize the destination address
		CXB$Q_STATION(R2)
	CLRQ	XMT_T_DATA(R2)		; Zero circuit header
	MOVW	#XMT_T_DATA,-		; Store offset to start of data
		CXB$W_BOFF(R2)
	INSQUE	(R2), (R4)		; Queue the buffer
	SOBGTR	R5, 100$		; for each of the buffers

	MOVZBL	#SS$_NORMAL, R0
	RSB

	;
	;   Resource error return
	;
110$:	MOVL	R8, R4			; Move the CSB address for the call
	BSBW	LT$DEALOCSB		; Clean up the CSB before we leave 
	CLRL	R0			; Return an error
	RSB
	

	.SBTTL	LT$DEALOCSB  - Deallocate a CSB
;++
; LT$DEALOCSB
;
; FUNCTIONAL DESCRIPTION:
;
;	Deallocate the transmit buffers.
;
; INPUTS:
;	R4 = CSB address
;
; OUTPUTS:
;	R0-R3 are destroyed
;
;--

LT$DEALOCSB:
	MOVZBL	#LAT$C_XMT_BUFFERS-1,R1	; Get number of transmits -1
10$:	MOVL	CSB_L_XCXB(R4)[R1], R0	; Is an FFI transmit in progress ?
	BEQL	20$			; no
	CLRL	CXB$L_T_CSB(R0)		; Delete backpointer to CSB in CXB
20$:	SOBGEQ	R1,10$			; Loop if more
25$:	REMQUE	@CSB_Q_XBUFQ(R4), R0	; Now dump all the buffers
	BVS	30$			; No more buffers
	BSBW	LT$DEALPOOL		; Dump a buffer
	BRB	25$			;

30$:	REMQUE	@CSB_Q_XWAITQ(R4), R0	; Now dump all the waiters
	BVS	40$			; No more buffers
	BSBW	LT$DEALPOOL		; Dump a buffer
	BRB	30$			;

40$:	MOVZBL	CSB_B_INX(R4), R3	; Find our place in the table
	BNEQ	50$			; Great
	DEBUG				; Not properly initialized CSB

50$:	INCB	GHB_B_LOC_CCHK[R3]	; Bump the slot check digit
	MOVAL	GHB_L_CSBTABLE-4[R3],R0	; Address in table
	CMPL	(R0), R4		; Check this address with the one
	BEQL	60$			; we have.
	DEBUG				; Table is clobbered or CSB addr bad

60$:	CLRL	(R0)			; No CSB address here anymore
	;
	;  We will now save this CSB on the OLD CSB queue, but we will
	;  have to remove an old entry if we exceed our limit.
	;
	MOVL	R4,R0			; Copy CSB address just in case
					;  we want to deallocate it
	TSTL	CSB_Z_LCB+LCB_L_MSG_XMT(R4) ; Any information in counters?
	BNEQ	70$			; Br if yes, save it
	TSTL	CSB_Z_LCB+LCB_L_MSG_RCV(R4) ; Any information in counters?
	BNEQ	70$			; Br if yes, save it
	BRW	180$			; Else, nothing interesting here
70$:	;
	;  We will now scan the CSB list for any old CSBs that match this
	;  one, that way we will only save 1 entry per server.
	;
	MOVAB	GHB$Q_OLD_CSBS+GHB_AREA,R1 ; Get listhead of old CSBs
	MOVL	R1,R2			; ..twice
80$:	MOVL	(R2),R2			; Get next in queue
	CMPL	R2,R1			; Are we back to start?
	BEQL	100$			; Br if yes, no more - insert new entry
	CMPL	CSB_Z_DST(R4),-		; Does the Ethernet address match?
		CSB_Z_DST(R2)
	BNEQ	80$			; Br if no, try next
	CMPW	CSB_Z_DST+4(R4),-	; Full address match?
		CSB_Z_DST+4(R2)
	BNEQ	80$			; Br if no, try next
	MOVZBL	CSB_B_SERVER(R4),R3	; Get length of server name
	CMPB	R3,CSB_B_SERVER(R2)	; Lengths match?
	BNEQ	80$			; Br if no, try next
	PUSHR	#^M<R0,R1,R2>		; Save registers
	CMPC3	R3,CSB_T_SERVER(R4),-	; Does the server name match?
		CSB_T_SERVER(R2)
	POPR	#^M<R0,R1,R2>
	BNEQ	80$			; Br if no, try next
	;
	;    Take sum of counters and store in CSB @ R2
	;
	ADD_CTR	CSB_Z_LCB+LCB_L_MSG_XMT(R4),- ; XMITs
		CSB_Z_LCB+LCB_L_MSG_XMT(R2)
	ADD_CTR	CSB_Z_LCB+LCB_L_MSG_RCV(R4),- ; RCVs
		CSB_Z_LCB+LCB_L_MSG_RCV(R2)
	ADD_CTR	CSB_Z_LCB+LCB_L_MSG_REXMT(R4),- ; REXMTs
		CSB_Z_LCB+LCB_L_MSG_REXMT(R2)
	ADD_CTR	CSB_Z_LCB+LCB_W_SEQ_ERR(R4),- ; SEQ_ERRs
		CSB_Z_LCB+LCB_W_SEQ_ERR(R2),W
	ADD_CTR	CSB_Z_LCB+LCB_B_INV_MSG(R4),- ; INV_MSGs
		CSB_Z_LCB+LCB_B_INV_MSG(R2),B
	ADD_CTR	CSB_Z_LCB+LCB_B_INV_SLOT(R4),- ; INV_SLOTs
		CSB_Z_LCB+LCB_B_INV_SLOT(R2),B
	BRB	180$			; And delete the CSB @ R4
100$:	;
	;  Insert new CSB into list
	;
	INSQUE	(R4), @GHB$Q_OLD_CSBS+ -; Save CSB at end of CSB queue
		 GHB_AREA+4		;   since queue is time ordered
	DECB	GHB_B_OLD_CSBCNT	; Use up one more slot on queue
	BGEQ	190$			; Br if still within CSB limits
	INCB	GHB_B_OLD_CSBCNT	; Else, restore count
	REMQUE	@GHB$Q_OLD_CSBS+ -	; Remove oldest entry
		 GHB_AREA,R0
180$:	BSBW	LT$DEALPOOL		; Deallocate the CSB block
190$:	RSB

	.SBTTL	LT$CREATEUCB  - Create an LT UCB
;++
; LT$CREATEUCB - Create an LT UCB
;
;	Create a UCB by cloning it from the master UCB zero and
;	initialize it as part of the io database.  We can't lock
;	the io database for write access, because we aren't a
;	process.  So we just do it and hope for the best.  The
;	modifications are such that code scanning the database will
;	not be fooled if they are straight forward.  It is possible
;	to write code that will be confused when a new ucb appears,
;	but we don't have any solution other than waiting for the
;	the request to come here when the database is not locked.
;	That would probably mean that many connection attempts would
;	time out.
;
;			NB !!
;
;	The I/O data base is not locked!!
;
; Inputs:
;	none
;
; Outputs:
;	R5 = new UCB address
;	R0 = success or failure
;
;	R1-R4 clobbered
;--

LT$CREATEUCB:
	MOVL	GHB_L_UCB0, R5		; Get the UCB to clone from
	JSB	G^IOC$CLONE_UCB		; Clone the UCB
	BLBC	R0,90$			; Exit on error
	MOVL	R2,R5			; Else, copy new UCB address
	CLRW	UCB$W_REFC(R5)		; No refs yet!
90$:	RSB

	.SBTTL	LT$DESTROYUCB  - Destroy an LT UCB
;++
; LT$DESTROYUCB - Destroy an LT UCB
;
;	Delete a ucb from the io data base that has been disconnected.
;	This routine must be called at high IPL when the I/O database
;	is not in use by anyone.  We are going to deallocate a block
;	and if anyone has its address in a register, we are going
;	to go crash with a bang.  This situation is not quite the
;	same as the creation case where one can be much more cavalier.
;
;	Also note, that we must ensure that the LT UCB has been detached
;	from any VT UCB, and that the REFC has gone to zero. There is
;	a condition where the class driver will not detach a VT UCB
;	even though the disconnect entry point is called. This occurs if
;	loginout has not been run yet, but is about to be run. In this
;	case, the class driver will not have detached the LT UCB from the
;	VT UCB and we can check for that condition.
;
;		NB !!!
;	The I/O database is NOT locked for write access, BUT the MUTEX
;	is available!
;
; Inputs:
;	R5 = UCB to destroy
;
; Outputs:
;	R5 = UCB address
;	R0-R1 are destroyed.
;--

LT$DESTROYUCB:
	CMPL	R5,UCB$L_TT_LOGUCB(R5)	; Is this UCB ready for deletion?
	BNEQ	50$			; Br if no, requeue it
	TSTW	UCB$W_REFC(R5)		; All refs gone?
	BNEQ	50$			; Br if no, requeue it
	SETBIT	#UCB$V_DELETEUCB, -	; Else, allow UCB to be deleted
		UCB$L_STS(R5)
	JSB	G^IOC$DELETE_UCB	; Delete the UCB
	BRB	90$			; leave

50$:	MOVB	#UCB$C_LT_STATE_KILL,-	; Enter the KILL UCB state
		 UCB$B_LT_STATE(R5)
	CLRBIT	#UCB$V_LT_DEAD,-	; Clear the dead indicator
		 UCB$B_LT_LATSTS(R5)
	BSBW	LT$HANGUP_UCB		; And hangup the UCB again!
90$:	RSB				; Return

	.SBTTL	 LT$ALC_UCB - Allocate New LT UCB
;++
; LT$ALC_UCB - Allocate a new LT UCB
;
; Subroutine to select a UCB for a slot.
;
; Inputs:
;	R7 =  receive buffer slot address
;	R8 =  CSB address
;
; Outputs:
;	R0 =  success or failure
;	R5 =  UCB address
;	R7 =  receive buffer slot address
;	R8 =  CSB address
;	R1,R2,R3,R4 modified
;--

LT$ALC_UCB:
	CLRL	R0			; Return failure if no UCB

;;&&	*TEMP*  concentrator bug

	MOVAL	CSB_L_UCBLST(R8), R4	; Search the list for this CSB
	MOVL	R4, R3			; Save the address
	MOVZBL	CSB_B_MAX_SLOTS(R8), R1	; Get maximum in list
1$:	MOVL	(R4)+, R5		; Look in the table
	BEQL	2$			; A free slot, my word
	CMPB	SLT_B_SRCID(R7),-	; Is this the same terminal calling
		UCB$B_LT_REMID(R5)	;  again?
	BNEQ	2$			; No, then continue
	BRW	95$			; Yes, then setup message again
2$:	SOBGTR	R1, 1$			; look again

;;&&	*TEMP* concentrator bug


	MOVAL	CSB_L_UCBLST(R8), R4	; Search the list for this CSB
	MOVL	R4, R3			; save the address
	MOVZBL	CSB_B_MAX_SLOTS(R8), R1	; Get maximum in list
10$:	MOVL	(R4)+, R5		; Look in the table
	BEQL	20$			; A free slot, my word
	SOBGTR	R1, 10$			; look again
15$:	BRW	90$			; None to be had here, so fail

20$:	CMPB	SLT_B_COUNT(R7),-	; Is slot big enough?
		 #<SLT_B_DST_NAMLEN-SLT_T_DATA>+2
	BGEQ	30$			; Br if yes, okay
	INC_CTR	CSB_Z_LCB+LCB_B_INV_SLOT(R8) ; Else, say invalid slot
	BRB	15$			; And exit
					;
30$:	PUSHL	R4			; Save the address in table
	SUBL2	R3, R4			; Compute the index for this CSB
	DIVL2	#4, R4			;  as a small integer
	PUSHL	R4			; Save the index too
	BSBW	LT$CREATEUCB		; Create a raw lt UCB
	POPL	R4			; Obtain the index
	POPL	R3			;  and its address in CSB table
					;
	BLBC	R0, 15$			; Do we have one?, nope, too bad
	MOVL	R5, -(R3)		; Store its address in CSB table
	BSBW	LT$UCB_INIT		; Initialize the ucb
	MOVB	R4,UCB$B_LT_LOCID(R5)	; Set local slot index
	MOVB	SLT_B_SRCID(R7),-	; Load remote circuit id
		UCB$B_LT_REMID(R5) 	;
	EXTZV	#0,#4,SLT_B_CRED(R7),R0	; Get credit total extended
	ADDB3	#1,R0,UCB$B_LT_TCRED(R5); Give ourself an extra credit for
					;   sending the start slot
	MOVB	#SLT_C_STR_SLOT@4!LAT$C_MAX_RCRED,- ; Set slot type and credits
		 UCB$B_LT_RCRED(R5)
	MNEGB	#LAT$C_MAX_RCRED,-	; Set credits extended to remote end
		 UCB$B_LT_XCRED(R5)	;   kept as negative value
	CLRW	UCB$W_ERRCNT(R5)	; Reset the error counter that
					; we bump as we shut down.
	BISW	#<UCB$M_INT!-		; Expecting interrupts & online
		UCB$M_ONLINE>,-		;
		UCB$L_STS(R5)		;
	MOVL	R8,UCB$L_LT_CSB(R5)	; Load CSB address
	INCB	CSB_B_REFC(R8)		; One more UCB here
	;
	;  Compute maximum allowed slot size
	;
	MOVB	#LAT$C_MAX_SLOTSIZ,-	; Assume ours is the maximum
		 UCB$B_LT_SLOTSZ(R5)	;  slot size
	CMPB	SLT_B_DT_SLTSIZ(R7),-	; Is remotes size smaller?
		 UCB$B_LT_SLOTSZ(R5)
	BGEQU	40$			; Br if no, use ours
	MOVB	SLT_B_DT_SLTSIZ(R7),-	; Else, take remotes
		 UCB$B_LT_SLOTSZ(R5)
40$:	MOVB	#UCB$C_LT_STATE_RUN,-	; Set the initial state to RUN
		 UCB$B_LT_STATE(R5)
	MOVB	#GHB_C_STRT_SLOTL,-	; Build a start slot
		 UCB$B_LT_CURC(R5)
	PUSHL	R5			; Save UCB address
	MOVC3	#GHB_C_STRT_SLOTL,-	; Make it look like output data
		 GHB_T_STRT_SLOT,-
		 UCB$B_LT_CBUF(R5)
	POPL	R5			; Save UCB address
	BISB	#UCB$M_LT_DATA,-	; Force data through output slot
		 UCB$B_LT_DATAW(R5) 
	;
	;  Check for the disable login flag
	;
	MOVAB	SLT_B_DST_NAMLEN(R7),R1	; Skip to dest. slot name field
	MOVZBL	(R1)+,R0		; Get size of dest. name field
	ADDL	R0,R1			; Skip the dest. name field
	MOVZBL	(R1)+,R0		; Get size of src name field
	ADDL	R0,R1			; Skip the src name field
	MOVAB	SLT_T_DATA(R7),R0	; Compute size of slot skipped
	SUBL3	R0,R1,R2		;	...
	MOVZBL	SLT_B_COUNT(R7),R0	; Get size of entire slot
	SUBL	R2,R0			; Compute bytes remaining
	BLEQ	70$			; Br if no more data, do login
60$:	MOVZBL	(R1)+,R2		; Get parameter code
	BEQL	70$			; Br if none, assume auto-login
	DECL	R0			; One less byte left
	BLEQ	70$			; Br if no more data, do login
	MOVZBL	(R1)+,R3		; Get size of parameter
	SUBL	R3,R0			; Get remaining byte count
	BLEQ	70$			; Br if no more data, do login
	MOVL	R1,R4			; Save current parameter address
	ADDL	R3,R1			; Skip to next parameter
	CMPL	R2,#SLT_C_START_FLAG	; Is this the start slot flag byte?
	BNEQ	60$			; Br if no, look for next
	BBC	#SLT_FLAG_V_BIND,(R4),65$ ; Br if not a bind request
	CLRBIT	#TT2$V_HANGUP,-		; Else, set terminal to NOHANGUP
		UCB$L_TT_DECHA1(R5)	;   on logout
	SETBIT	#UCB$V_LT_BOUND,-	; Don't delete UCB after STOP slot
		UCB$B_LT_LATSTS(R5)	; ... only if we must KILL the UCB!
65$:	BBS	#SLT_FLAG_V_LOGIN,(R4),80$ ; Br if login is disabled
	;
	;  Ask the class driver to log us in
	;
70$:	MOVL	UCB$L_TT_CLASS(R5), R1	; Class dispatch vector
	MOVL	#1@13, R3		; Framming error with zero byte
	JSB	@CLASS_READERROR(R1)	; Cause read error
80$:	MOVZBL	#SS$_NORMAL, R0		; Do we have a UCB for you.
90$:	RSB

;;&&	*TEMP* concentrator  bug

95$:	SETBIT	#GHB$V_REPCREATE, -	; Set mask bit
		GHB$L_PROTOMASK+GHB_AREA ; Repeat create of slot
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; Increment protocol error counter
	BRW	40$
;;&&	*TEMP*  concentrator bug

	.SBTTL	LT$HANGUP_UCB  - Cause Terminal Hangup On UCB
;++
; LT$HANGUP_UCB - Hangup an LT UCB
;
; Cause all the hangup effects on a terminal device.  This should cause
; process rundown and deallocation of all channels to the UCB.
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;	none.
;
;--
	.ENABL	LSB
LT$HANGUP_UCB_NOW:
	;
	;  Dispatch on UCB (slot) state
	;
	$DISPATCH  UCB$B_LT_STATE(R5),TYPE=B,-
	<-	; state		; action
	<UCB$C_LT_STATE_STOP	LT$KILLUCB>,-	; Already disconnected,
	>

	;  Else

	MOVB	#UCB$C_LT_STATE_KILL,-		; Enter the KILL UCB state
		 UCB$B_LT_STATE(R5)

LT$HANGUP_UCB:
	PUSHR	#^M<R0,R1,R2,R3,R4>		; Save registers
	BICW	#UCB$M_INT,UCB$L_STS(R5)	; No interrupt expected (allows
						;   STARTIO to be called again
						;   to flush data).
	SETBIT	#UCB$V_LT_HANGUP,-		; Indicate that we're shutting
		 UCB$B_LT_LATSTS(R5)		;   down
	MOVL	UCB$L_TT_CLASS(R5),R0		; Class driver vector address
	JSB	@CLASS_DISCONNECT(R0)		; Call routine
	POPR	#^M<R0,R1,R2,R3,R4>		; Restore the regs
90$:	RSB

	.DSABL	LSB

	.SBTTL	LT$DISCONNECT  - Port Disconnect
;++
; LT$DISCONNECT - Disconnect the terminal Port driver
;
;	Port driver entry to disconnect a terminal.  called when
;	Last reference is gone.  here we free the slot in the buffer
;	And bump the sequence number.  also we set the UCB offline.
;
; Inputs:
;	R5 = UCB address
;	R0 -> lbc = delete UCB
;	R0 -> lbs = do not delete UCB
;
; Outputs:
;	R5 = UCB address
;	All other registers are preserved.
;
; Implicit inputs:
;	UCB$B_LT_STATE = KILL -> kill UCB immediately.
;			 STOP -> send stop slot, then kill UCB.
;			 ???? -> all others, set to STOP state.
;
;--

LT$DISCONNECT:
	;
	; Do not touch the UCB if it is the template UCB0
	;
	CMPL	R5,GHB_L_UCB0		; Is this the template ucb ?
	BEQL	90$			; Br if yes, don't touch it!
	;
	;   Dispatch on our UCB state
	;
	$DISPATCH  UCB$B_LT_STATE(R5),TYPE=B,-
	<-	; state		; action
	<UCB$C_LT_STATE_KILL	50$>,-	; KILLed, just kill the UCB now
	<UCB$C_LT_STATE_STOP	90$>,-	; STOPed, we've been here before
	>
					; ALL other states,
	;
	;  If the circuit is gone, or there is no CSB for the UCB
	;  then just delete the UCB immediately
	;
	TSTL	UCB$L_LT_CSB(R5)	; Do we have a circuit?
	BEQL	50$			; Br if none
	;
	;   Conditionally skip deallocation of UCB, on "hangup".
	;
	BLBS	R0,90$			; Br if not to "hangup" UCB
	MOVB	#UCB$C_LT_STATE_STOP,-	; Else, set STOP state, 
		 UCB$B_LT_STATE(R5)	;  to send STOP slot
	;
	;  Make sure that no data is given to CLASS driver, after
	;  we've been here!
	;
	SETBIT	#UCB$V_LT_HANGUP,-	; Indicate that we're shutting
		 UCB$B_LT_LATSTS(R5)	;   down
	BRB	90$			; Delete UCB when STOP is sent!

50$:	BSBW	LT$KILLUCB		; Get rid of the UCB now

90$:	RSB				; Done


	.SBTTL	LT$KILLUCB  - Delete a dried up UCB
;++
; LT$KILLUCB - Delete an LT UCB
;
; The UCB is all dried up one way or another.  So we must delete it if
; possible, else put it on the deadlink list to be deleted on the next
; timer tick.
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;	R5 = UCB address
;	All other registers preserved.
;
;--

LT$KILLUCB:
	PUSHR	#^M<R0,R1,R2,R3,R4>	; Save some volatile regs
	BICW	#<UCB$M_INT! -		; No interrupt expected
		UCB$M_ONLINE>,-		; Not online, but free now
		UCB$L_STS(R5)		; For use again
	BSBW	LT$FLUSH_DATA		; Flush all output data
	BSBW	LT$SIDELINEUCB		; Set the UCB aside from the circuit
	BBCS	#UCB$V_LT_DEAD,-	; If we already linked UCB to deadlist
		UCB$B_LT_LATSTS(R5),20$	;  then we have made an error
	SETBIT	#GHB$V_REPDISC,-	; KILLUCB called twice
		GHB$L_PROTOMASK+GHB_AREA; 
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA	; Increment protocol error counter
	BRB	90$			;
20$:	;
	;  We must destroy the UCB (not called from $DASSGN, so queue the
	;  UCB to the deadlist so it can be deallocated by the timer service.
	;  This is because the CLASS driver still uses the UCB even if we
	;  deallocate it!
	;
	MOVL	GHB_L_DEADLINK,-	; Link UCB into chain of dead UCBs
		UCB$L_LT_DEADLINK(R5)	; for disposal at timeout
	MOVL	R5, GHB_L_DEADLINK	;
90$:	POPR	#^M<R0,R1,R2,R3,R4>	; Restore the regs
	RSB

	.SBTTL	LT$SIDELINEUCB  - Set a UCB aside
;++
; LT$SIDELINEUCB
;
; Functional description:
;
; Set a UCB aside to dry up on its own.  Disconnect it from a running
; circuit.
;
; Inputs:
;	R5 = UCB address
;
; Outputs:
;	none
;	All registers preserved.
;
;--

LT$SIDELINEUCB:
	PUSHR	#^M<R3,R4>		; Save registers
	MOVL	UCB$L_LT_CSB(R5), R4	; Get the CSB address
	BEQL	10$			; None, this is already done
	MOVZBL	UCB$B_LT_LOCID(R5), R3	; Use the local slot index in UCB
	CLRL	CSB_L_UCBLST-4(R4)[R3]	; to adjust state of UCB list in CSB
	CLRL	UCB$L_LT_CSB(R5)	; Remember we have been here
	DECB	CSB_B_REFC(R4)		; One less UCB on this circuit
	BNEQ	10$			; We have more UCBs here
	BSBW	LT$STOPCIRC		; Then don't wait for return traffic
10$:	POPR	#^M<R3,R4>		; Restore registers
	RSB				; Return to caller

	.SBTTL	LT$CIRCDEAD  - Declare circuit dead
;++
; LT$CIRCDEAD  - Declare circuit dead.
;
; Functional description:
;
;	Log off all the processes on each UCB and waiting for them
;	to free their UCBs.  This will cause the CSB to go free too.
;	If this CSB has no ucb's attached, then the CSB is just cleaned up.
;
; Inputs:
;	R8 = CSB address
;
; Outputs:
;	All UCB's hungup.
;
;--

LT$CIRCDEAD:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Save registers
	TSTB	CSB_B_REFC(R8)			; Do we have any UCBs?
	BEQL	100$				; Br if no, so deallocate CSB
	MOVZBL	CSB_B_MAX_SLOTS(R8), R7		; Else, number of UCBs to scan
	MOVAL	CSB_L_UCBLST(R8), R6		; List of the UCBs
20$:	MOVL	(R6)+, R5			; Get next UCB address
	BGEQ	60$				; Not system address
	BSBW	LT$HANGUP_UCB_NOW		; Hangup the process on this UCB
60$:	SOBGTR	R7, 20$				; For all the units here

90$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Restore registers
	RSB					; Return to caller
	;
	; Refc has gone to zero, send a stop message
	;
100$:	MOVL	R8, R4				; Setup CSB address
	BSBB	LT$STOPCIRC			; Send a stop message on circ
	BRB	90$				; And exit


	.SBTTL	LT$STOPCIRC  - Transmit stop message
;++
; LT$STOPCIRC - Transmit stop message
;
; Functional description:
;
; Format and transmit stop message
;
; Inputs
;	R4 = CSB address
;	CSB_L_STOPREASON	addr of stop reason block
;
; Outputs:
;	none
;
;--

DEFREASN:
	.ASCIC	/Node terminated circuit./

LT$STOPCIRC:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Save registers
	MOVL	R4, R8				; Set CSB addr in r8
	TSTB	CSB_B_REFC(R8)			; We are not supposed to send
	BEQL	10$				; stop messages with 
	DEBUG					; outstanding ucbs on circ
10$:	CMPB	CSB_B_STATE(R8),-		; Have we been here before?
		#CSB_C_STATE_HALT		;
	BNEQ	15$				; Br if no
	BRW	90$				; Else, exit
15$:	MOVW	#1,CSB_W_TIMRESET(R8)		; Set timers for quick timeout
	MOVW	#1,CSB_W_TIMEOUT(R8)		;
	MOVB	#CSB_C_STATE_HALT,-		; and set state to halted
		CSB_B_STATE(R8)			;
    	CLRW	CSB_W_LOCID(R8)			; Zero the local ID
	MOVAQ	CSB_Q_XBUFQ(R8), R0		; Transmit buffer queue
	REMQUE	@(R0), R7			; Do we have a free buffer?
	BVC	30$				; Yep, got it
	REMQUE	@CSB_Q_XWAITQ(R8), R7		; Get a waiting bfr
	BVC	20$				; Ok, so use it
	DEBUG					; All buffers gone?????
20$:	DECB	CSB_B_XMTCNT(R8)		; One less buffer on waitq
30$:	INSQUE	(R7), (R0)			; Make it a free buffer
	MOVL	R7, R9				; Save bfr header adr
	MOVAB	XMT_T_DATA(R7), R7		; Stop message data
	MOVB	#MTYP_C_HALT@FLAG_V_MTYPE,-	; Send a HALT message
		CSB_B_FLAG(R8)			; 
	CLRB	CSB_B_NUM_SLOTS(R8)		; No slot data
	MOVAB	XMT_T_MDATA(R9), R3		; Set default end of data
	CLRB	(R3)+				; Set default reason code
	MOVAB	DEFREASN, R0			; Store a default text string
	MOVZBL	(R0), R1			; the count
	INCL	R1				; including the count
	MOVC3	R1, (R0), (R3)			; move count and string
	MOVL	CSB_L_STOPREASON(R8), R6	; Do we have a reason
	BEQL	40$				; No reason
	MOVZBL	2(R6), R0			; Set the reason bit
	SETBIT	R0,GHB$L_PROTOMASK+GHB_AREA	; and count the error
	INC_CTR	GHB$L_PROTOCOL+GHB_AREA		; as a halt
	MOVB	3(R6), -			; Store the reason code
		STOP_B_RCODE+XMT_T_MDATA(R9)	;
	MOVZWL	(R6), R0			; Offset to the string
	ADDL	R6, R0				; Set the address
	MOVZBL	(R0), R1			; Get the count
	INCL	R1				; and set the count
	MOVC3	R1, (R0), -			; copy the counted string
		STOP_B_RLEN+XMT_T_MDATA(R9)	; Leave r3 pointing beyond
40$:
	MOVL	R3, CXB$L_T_ENDADR(R9)		; and store in buffer
	MOVL	R8,R4				; copy CSB address
	BSBW	LT$XMIT				; and transmit the msg
50$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Restore registers
	RSB					; Return to caller

; Stop message sent once
; Just wipe CSB now

90$:	MOVL	R8, R4				; CSB address to R4
	BSBW	LT$DEALOCSB			; Deallocate CSB to pool
	BRB	50$				; And exit


	.SBTTL	LT$SET_TIMER  - Start Timer
;++
; LT$SET_TIMER - Start the timer
;
; Functional description:
;
;	Start timer ticking to scan the CSB's for dead circuits
;
; Inputs:
;	R0-R2 available
;
; Implicit Inputs:
;
;	IPL = LAT$C_IPL (8)
;
; Outputs:
;	R0-R2 are destroyed.
;
;--

LT$SET_TIMER:
	MOVAB	GHB_G_TQE, R0		; Address of timer queue element
	BBSS	#GHB_STS_V_ACTIVE,-	; Br if timer already active
		 GHB_B_STATUS,10$	;   and mark as active
	BISB	#DPT$M_NOUNLOAD,DPT$TAB+DPT$B_FLAGS ; Make driver unloadable
	MOVW	#TQE$C_LENGTH,-		; Setup timer queue entry block
		TQE$W_SIZE(R0)		; For its first use
	MOVB	#DYN$C_TQE,-		; With both the size and the type
		TQE$B_TYPE(R0)		; Code.
	PUSHR	#^M<R3,R4,R5>		; Save the fork context
	MOVL	R0, R5			; Use TQE as a fork block
;
; Use the TQE as a fork block to start the timer. This is because the
; timer must be started at or below QUEUEAST to synchronize access to the
; TIMER QUEUE.
;
	MOVB	#IPL$_QUEUEAST,-	; Set delivery IPL
		FKB$B_FIPL(R5)		;  of fork block
	BSBB	40$			; Create fork process
	MNEGL	#1,GHB$L_TIM_ACT+GHB_AREA ; Mark the timer as active for LATCP
	POPR	#^M<R3,R4,R5>		; Restore our context
10$:	RSB				; And return

;
;	Fork process to start the timer.  We need to go to synch from
;	fork ipl to start the timer.  We do this by going through
;	Queueast IPL to be safe - using the TQE as a fork block.
;

40$:	JSB	G^EXE$FORK		; Fork to start the timer ticking
	DSBINT	#IPL$_SYNCH		; Raise to synch
	MOVAB	W^LT$TICK,-		; Address of tick routine
		TQE$L_FPC(R5)		;  is the fork pc
	MOVL	G^TTY$GL_DELTA,-	; The tick time is from tty sysgen
		TQE$Q_DELTA(R5)		;  parameter for modem control
	MOVB	#TQE$C_SSREPT,-		; Repeating tick
		TQE$B_RQTYPE(R5)	;
	MOVQ	G^EXE$GQ_SYSTIME, R0	; Set the time
	ADDL	G^TTY$GL_DELTA, R0	;    from now
	ADWC	#0, R1			; Carry to top longword
	JSB	G^EXE$INSTIMQ		; Queue the timer element
	ENBINT				; Restore IPL and leave
	RSB

	.SBTTL	LT$TICK  - Timer Service Routine
;++
; LT$TICK - Timer Service Routine
;
; Functional description:
;
;	Enter here on each timer tick.  We scan the CSB table and
;	timeout each UCB with a matching CSB for each CSB that has
;	timed out.  For each receive on a circuit that has not timed
;	out we will reset its timer.
;
; Inputs:
;	R5 = TQE address
;
;	IPL = TIMER
;
; Outputs:
;	R0-R4 are destroyed.
;
;--
	.ENABLE	LOCAL_BLOCK

STOP_TQE:					; Stop the TQE
	BICB	#TQE$M_REPEAT,TQE$B_RQTYPE(R5)	; Clear the repeat flag
	BICB	#DPT$M_NOUNLOAD,DPT$TAB+DPT$B_FLAGS ; Make driver reloadable again
	CLRL	GHB$L_TIM_ACT+GHB_AREA		; Tell LATCP we are no longer
						;    active
	BRW	300$				; And leave

LT$TICK:
	DSBINT	#LAT$C_IPL			; Raise to synchronize LAT
	PUSHR	#^M<R5,R6,R7,R8,R9,R10,R11>	; Save all the registers
	BBC	#GHB_STS_V_ACTIVE,-		; Br if we went inactive
		 GHB_B_STATUS,STOP_TQE
;
; Scan all CSBs to retransmit in balanced mode and time out circuits 
; that appear to be dead.
;
	MOVL	#LAT$C_MAX_CSBS, R11		; Scan the CSB table for
	MOVAL	GHB_L_CSBTABLE, R10		; Active entries and check
20$:	MOVL	(R10)+ , R8			; Get the CSB address
	BEQL	90$				; Br if no CSB in this slot
;
;	Are we coming out of balanced mode and need to retransmit the
;	First message again??
;
	CMPB	CSB_B_STATE(R8), -		; State must be running
		#CSB_C_STATE_RUN		;   for active circuits
	BNEQ	60$				; Br if not
	TSTW	CSB_W_XMTTMO(R8)		; Timing out restart message?
	BEQL	60$				; Br if no
	DECW	CSB_W_XMTTMO(R8)		; Check for timeout
	BGTR	60$				; Br if not time yet
	INC_CTR	GHB$L_RETRANS+GHB_AREA		; Count a retransmission
	INC_CTR	CSB_Z_LCB+LCB_L_MSG_REXMT(R8)	;	...
	MOVL	R8, R4				; CSB address for call
	BSBW	LT$REXMIT			; Transmit the message
	MOVW	#LAT$C_HOST_TIMER,CSB_W_XMTTMO(R8) ; Reset the timeout
;
; Timeout circuit if needed
;
60$:	DECW	CSB_W_TIMEOUT(R8)		; Check the circuit timeout
	BNEQ	90$				; Br if not expired
	INC_CTR	GHB$L_CIRCDOWN+GHB_AREA		; Count circ down event
	BSBW	LT$CIRCDEAD			; Declare the circuit dead
	MOVW	CSB_W_TIMRESET(R8),-		; Reset the timeout to wait
		CSB_W_TIMEOUT(R8)		; a while.
90$:	SOBGTR	R11, 20$			; Loop till we are done

;
;	Now check to see if there are dead ucbs waiting to be cleaned up
;	and if noone is using the io database right now, we can delete them
;	all in a flash.
;

100$:	MOVAL	G^IOC$GL_MUTEX, R0		; Is anyone owning the io data
	CMPW	MTX$W_OWNCNT(R0), #-1		; base?  If so, then we must
	BNEQ	130$				; try again later.
	MOVL	GHB_L_DEADLINK, R4		; Good we own it then
	CLRL	GHB_L_DEADLINK			; Reset list pointer
110$:	TSTL	R4				; Any work to do?
	BEQL	130$				; All done
	MOVL	R4, R5				; UCB to delete
	MOVL	UCB$L_LT_DEADLINK(R5), R4	; Save link to next one
	BSBW	LT$DESTROYUCB			; Destroy this UCB
	BRB	110$				; and go back for more

130$:

;
;	Transmit a configuration message if its time.  We tell all
;	concentrators our node name, announcement string every
;	so often so they know we exist.
;

	DECW	GHB_W_MULTIMR			; Time to transmit?
	BLEQ	150$				; Br if yes, do it
140$:	BRW	300$				; Else, still time to go

150$:	MOVL	GHB_L_MULTIBFR, R2		; Get multicast buffer
	BEQL	155$				; Br if none
	ASSUME	GHB_STS_V_MULTI EQ 0
	BLBS	GHB_B_STATUS,140$		; Ignore, if already in progress
	CMPB	GHB_B_INCARN, -			; Has it been rebuilt?
		XMT_B_MC_INCARN(R2)		;  if so, incarn has been
	BEQL	160$				;  bumped to say so
155$:	BSBW	LT$SETENTRY			; Go rebuild the message
    	BLBC	R0, 140$			; Br if failure
160$:	MOVZBW	<XMT_B_MC_MULTIMR-XMT_B_MC_SET>- ; Reset multicast timer
		 +GHB_T_MC_DATA,GHB_W_MULTIMR	;     from LATCP set data
	BNEQ	161$				; Br if value is okay
	MOVW	#LAT$C_MULTI_TIMER,GHB_W_MULTIMR ; Reset timer
161$:	MOVL	GHB_L_MULTIBFR, R2		; Get multicast buffer
;
; Adjust host rating
;
	MOVAB	XMT_B_MC_GRP_LEN(R2), R1	; Compute address of node name:
	MOVZBL	(R1)+, R0			;   get count of groups
	ADDL	R0, R1				;   add in start address
	MOVZBL	(R1)+, R0			; Compute address of node desc.
	ADDL	R0, R1				;   add in start address
	MOVZBL	(R1)+, R0			; Calc start address of services
	ADDL	R0, R1				;   add in start address
	MOVL	R1, R4				; Save address of service count
	CMPB	(R1)+, #2			; Do we have two service names?
	BGEQ	163$				; Br if yes, process it
	BRW	170$				; Else, skip it
163$:	INCL	R1				; Skip rating byte
	MOVZBL	(R1)+, R0			; Calc start of first svc desc.
	ADDL	R0, R1				;	...
	MOVZBL	(R1)+, R0			; Calc start of second svc rate
	ADDL	R0, R1				;	...
	;
	;  Compute the service rating as follows:
	;
	;	 cpu_idle_time * 255
	;	--------------------- * cpu_weight
	;	100 * multicast timer
	;
	;
	;   where:  cpu_weight is 1 for a 790, 1/2 for 785, 3/8 for 780, etc.
	;
	;
	SUBL3	GHB_L_LASTCPU,@GHB_L_NULLCPU,R0	; Calculate "idle time"
	MOVL	@GHB_L_NULLCPU,GHB_L_LASTCPU	; Set new last cpu time
	MOVL	G^EXE$GL_MP,R6			; Get ptr to MP code
	BEQL	164$				; Br if not there
	SUBL3	GHB_L_NULLSEC,-			; Else, compute secondary idle
		 MPS$GL_NULLCPU(R6),R7		;   time
	MOVL	MPS$GL_NULLCPU(R6),-		; And set new secondary
		 GHB_L_NULLSEC			;   null time
	ASHL	#-1,R7,R7			; Get 50% of secondary null time
	SUBL	R7,R0				; Let secondary account for
						;   only 50% additional power
164$:	MULL	#255,R0				; Multiply by highest rating possible
	MOVZBL	#1,R3				; Start with 1
	CPUDISP	<<790, EIGHT>,-			; Give 790 the highest rating
		 <785, FOUR>,-			; Rate 785 as four
		 <780, THREE>,-			; Rate 780 as three
		 <750, TWO>,-			; Rate 750 as two
		 <730, ONE>,-			; etc.
		 <UV1, ONE>>			;

EIGHT:	ADDL	#4,R3				; Rating will be highest
FOUR:	INCL	R3				; next rating
THREE:	INCL	R3				;   etc.
TWO:	INCL	R3				;
ONE:
	MULL	R3,R0				; Compute adjusted rating
	DIVL	#800,R0				; Divide by highest rating + %
	MOVZBL	<XMT_B_MC_MULTIMR-XMT_B_MC_SET>- ; Get multicast timer
		 +GHB_T_MC_DATA,R3
	DIVL	R3,R0				; Normalize rating by time
	BEQL	165$				; Br if zero rating
	CMPL	R0,#255				; Ridiculous rating ?
	BLEQ	167$				; Br if no, continue
	MOVZBL	#254,R0				; Else, set highest rating
						;  let INCL up it to 255
165$:	;
	;  Don't let rating fall to zero, unless the joblimit is reached
	;  or the jobcnt if greater than or eqal to the joblim.
	;
	INCL	R0				; Else, set to minimum
167$:	CMPW	G^SYS$GW_IJOBCNT,G^SYS$GW_IJOBLIM ; Are we maxed out?
	BLSSU	169$				; Br if no, continue
	CLRL	R0				; Else, set to mimimum
169$:	CMPB	R0,(R1)				; New second service rating?
	BEQL	170$				; Br if no
	MOVB	R0,(R1)				; Else, set new 2nd svc rating
	BRB	175$

170$:	CMPB	G^SYS$GW_IJOBCNT, 1(R4)		; New number of interactive 
						;     users?
	BEQL	180$				; Br if no
175$:	MOVB	G^SYS$GW_IJOBCNT, 1(R4)		; Use the interactive count
						;  as the second rating
	INCB	XMT_B_MC_INCARN(R2)		; set new incarnation	
	INCB	GHB_B_INCARN			; no call LT$SETENTRY next time 
	XORB	#XMT_CHFLG_M_RATE,XMT_B_MC_CHG_FLAG(R2) ; flag rate change

180$:	MOVL	GHB_L_FFI, R4			; Get FFI block address
	BEQL	300$				; Br if none
	SETBIT	#GHB_STS_V_MULTI,GHB_B_STATUS	; Indicate that multicast is active
	MOVL	R2,R3				; Copy CXB address
	MOVQ	GHB_Q_MULTIADD,-		; Copy the destination address
		CXB$Q_STATION(R3)		;
	ASSUME	CXB$W_BCNT EQ CXB$W_BOFF+2
	MOVL	CXB$W_BOFF(R3),CXB$L_T_SAVE(R3) ; Save BOFF and BCNT

	JSB	@FFI$L_XMIT(R4)			; Start XMIT operation

300$:	POPR	#^M<R5,R6,R7,R8,R9,R10,R11>	; Restore the regs
	ENBINT					; Restore priority
	RSB

	.DISABLE LOCAL_BLOCK

	.SBTTL	LT$XMIT  - Transmit a message
;++
; LT$XMIT - Transmit a message
;
; FUNCTIONAL DESCRIPTION:
;
;	If the CXB is outstanding then record the fact that there is
;	a waiting message.  If the CXB is not outstanding, then ready
;	it for transmission and send it to the other driver as a write.
;
;	Transmissions must make progress.  That is the sequence and acks
;	of the messages must change over time or we decide that the
;	circuit is really deadlocked and we take it down.  We are generous
;	with the counter for detecting this deadlock.
;
; Input:
;	R4 = CSB address
;
; Output:
;	R0-R5 clobbered
;-

	.ENABLE	LOCAL_BLOCK

LT$XMIT:
	REMQUE	@CSB_Q_XBUFQ(R4), R3	; Remove the buffer from queue
	BVC	5$			; We had better have a buffer here.
	DEBUG				; Fatal error, no buffer
5$:	INCB	CSB_B_XMTCNT(R4)	; One more buffer to transmit
	INCB	CSB_B_XSEQ(R4)		; Next message to send
	MOVQ	CSB_T_CIRCHDR(R4),-	; Set the circuit header for the
		XMT_T_DATA(R3)		; message
	MOVAB	XMT_T_DATA(R3), R0	; Start of data to send
	SUBL	R0, CXB$L_T_ENDADR(R3)	; Make length from end address
	MOVW	CXB$L_T_ENDADR(R3),-	; Copy length to CXB format
		CXB$W_BCNT(R3)
	INSQUE	(R3), @CSB_Q_XWAITQ+4(R4) ; Queue to tail of waiting buffers
	TSTB	CSB_B_XMTBSY(R4)	; Transmitter busy?
	BEQL	60$			; Br if no, start transmitting
10$:	INCB	CSB_B_XMTBSY(R4)	; Else, count another transmit
					;  we just placed one on the wait queue
20$:	RSB

;
;	Transmit just the one buffer, not all the ones waiting.
;
LT$XMITONE:
	REMQUE	@CSB_Q_XBUFQ(R4), R3	; Get the one buffer of interest
	BVC	30$			; Got it
	DEBUG				; No buffer for this transmit
30$:	INCB	CSB_B_XMTCNT(R4)	; Count one more on wait queue
	INCB	CSB_B_XSEQ(R4)		; Next message to send
	MOVQ	CSB_T_CIRCHDR(R4),-	; Set the circuit header for the
		XMT_T_DATA(R3)		; message
	MOVAB	XMT_T_DATA(R3), R0	; Start of data to send
	SUBL	R0, CXB$L_T_ENDADR(R3)	; Make length from end address
	MOVW	CXB$L_T_ENDADR(R3),-	; Copy length to CXB format
		CXB$W_BCNT(R3)
	TSTB	CSB_B_XMTBSY(R4)	; Are we busy??
	BNEQ	40$			; Br if yes, so carry on
	INCB	CSB_B_XMTBSY(R4)	; Just one buffer
	BRB	90$			; Go

40$:	INSQUE	(R3), @CSB_Q_XWAITQ+4(R4) ; Place it on the queue
	BRB	10$			; And transmit later

LT$REXMIT:				; Entry to start a retransmit
	TSTB	CSB_B_XMTBSY(R4)	; Is the transmit busy??
	BNEQ	20$			; Br if yes, just leave
60$:	MOVB	CSB_B_XMTCNT(R4), -	; Start a series of retransmits
		CSB_B_XMTBSY(R4)	;


;;**	debug code
	CMPB	CSB_B_XMTCNT(R4),-	; All buffers on the transmit queue?
		#LAT$C_XMT_BUFFERS	;
	BLSS	80$			; Nope
	BEQL	70$			; Yes all of them
	DEBUG				; More than all of them
70$:	NOP
80$:
;;**	debug code

LT$XMTGO:				; Enter to transmit for waiters
	REMQUE	@CSB_Q_XWAITQ(R4), R3	; Obtain the next waiting buffer
	BVS	20$			; Br if no buffer to transmit
90$:	CMPW	CSB_W_PROGSEQ(R4),-	; Are we making progress?
		CSB_W_XSEQ(R4)		; are the seq and ack fields changing?
	BNEQ	100$			; Br if yes, splendid
	DECW	CSB_W_PROGRESS(R4)	; Nope, give them some time then
	BGTR	110$			; We have more time then
	INSQUE	(R3), CSB_Q_XBUFQ(R4)	; Put the buffer back into the CSB
	INC_CTR	GHB$L_CIRCDOWN+GHB_AREA	; Count a circuit timeout
	PUSHL	R8			; No more time.  Clobber the circuit
	MOVL	R4, R8			; Since it appears to be deadlocked.
	BSBW	LT$CIRCDEAD		; and clean it all up
	POPL	R8			;
	RSB

100$:	MOVW	CSB_W_XSEQ(R4),-	; Reset the current sequence and ack
		CSB_W_PROGSEQ(R4)	; to check against
	MOVW	#LAT$C_PROGRESS,-	; and reset the progress counter
		CSB_W_PROGRESS(R4)	;

110$:
;
;	Build the CXB to transmit
;
	MOVL	GHB_L_FFI, R5		; Get the FFI block address
	BEQL	150$			; Br if none
	MOVZBL	CSB_B_XCXB_INX(R4), R1	; Get XMIT CXB index slot
	MOVL	R3, CSB_L_XCXB(R4)[R1]	; Save address of CXB
	INCB	R1			; Skip to next slot
	BICB	#^C<LAT$C_XMT_BUFFERS-1>,R1 ; Modulo maximum
	MOVB	R1, CSB_B_XCXB_INX(R4)	; Save for next time
	PUSHL	R4			; Save R4
	MOVL	R5,R4			; Else, copy the FFI block address
	ASSUME	CXB$W_BCNT EQ CXB$W_BOFF+2
	MOVL	CXB$W_BOFF(R3),CXB$L_T_SAVE(R3) ; Save BOFF and BCNT
						;  progress
	.IF DEFINED LT_HISTORY
;
;	Save a history of transmits
;
	MOVAB	XMT_B_FLAG(R3), R0	; Address of data to save
	BSBW	LT$HISTORY		; Save the data

	.ENDC	;; DEFINED LT_HISTORY

	JSB	@FFI$L_XMIT(R4)		; Start the XMIT operation
	POPL	R4			; Restore R4
150$:	RSB				; Return to caller

	.DISABLE LOCAL_BLOCK


	.SBTTL	LT$XMT_FFIDONE  - FFI Transmit done routine
;++
; LT$XMT_FFIDONE - FFI Transmit completion routine
;
; FUNCTIONAL DESCRIPTION:
;
;	Post routine for a transmit.  Called directly from datalink
;	driver with CXB address in R3.  We have r0 - r5 to work with.
;
; INPUTS:
;	R0 =  Status of XMIT request
;	R3 = CXB address
;	R4 = FFI block address
;
;	IPL = SYNCH
;
; OUTPUTS:
;	R1,R2,R4,R5 clobbered
;--
	ASSUME	IPL$_SYNCH EQ LAT$C_IPL
LT$XMT_FFIDONE:
	PUSHR	#^M<R1,R2,R4,R5>	; Save registers
	ASSUME	CXB$W_BCNT EQ CXB$W_BOFF+2
	MOVL	CXB$L_T_SAVE(R3),CXB$W_BOFF(R3) ; Restore BOFF and BCNT
	INC_CTR	GHB$L_XCOUNT+GHB_AREA	; Count one more buffer away
	BLBS	R0, 20$			; Br if no error
	MOVZWL	R0,GHB$L_XERRCOD+GHB_AREA ; Save error code
	INC_CTR	GHB$L_XERR+GHB_AREA	; Count one more error, but ignore it
20$:	BLBS	CXB$B_CODE(R3),110$	; Br if multicast buffer
	MOVL	CXB$L_T_CSB(R3),R4	; Get CSB address
	BNEQ	40$			; Got it, continue
	MOVL	R3,R0			; Toss this CXB then since the
	BSBW	LT$DEALPOOL		;   CSB seems to be gone.
	BRB	70$			; Leave quietly

40$:	MOVZBL	#LAT$C_XMT_BUFFERS-1,R0	; Get number of CXBs
45$:	CMPL	R3,CSB_L_XCXB(R4)[R0]	; Same as we sent?
	BEQL	50$			; Br if yes, remove it
	SOBGEQ	R0,45$			; Loop if more
	DEBUG				;;&& oops
50$:	CLRL	CSB_L_XCXB(R4)[R0]	; Zero entry
	INC_CTR	CSB_Z_LCB+LCB_L_MSG_XMT(R4) ; Count one more transmit
	INSQUE	(R3), @CSB_Q_XWAITQ+4(R4) ; Queue to tail for retransmit
	DECB	CSB_B_XMTBSY(R4)	; Any more to transmit??
	BEQL	60$			; Nope all done
	BSBW	LT$XMTGO		; Transmit for waiter
	BRB	70$			; Not done transmitting all yet
60$:
;
; If all UCBs are gone and we have transmitted a stop message last,
; then we can make this CSB go away.
;

	TSTB	CSB_B_REFC(R4)		; Are all the UCB's gone?
	BNEQ	70$			;
	CMPB	CSB_B_FLAG(R4),-	; Is the circuit dead?
		#MTYP_C_HALT@FLAG_V_MTYPE
	BNEQ	70$			; Br if not
	BSBW	LT$DEALOCSB		; Get rid of the circuit block
70$:	POPR	#^M<R1,R2,R4,R5>	; Restore registers
	RSB
	;
	; Multicast buffer completed
	;
110$:	CLRBIT	#GHB_STS_V_MULTI,-	; Multicast is not busy now
		 GHB_B_STATUS 
	BRB	70$			; And exit


	.SBTTL	LT$FFIPOSTDONE  - Garbage transmit posting routine
;++
; LT$FFIPOSTDONE - Garbage transmit posting routine
;
; FUNCTIONAL DESCRIPTION:
;
;	Final post routine to dry up a CXB I/O when we are done
;	with the channel.  We simply deallocate any transmit buffer returned.
;
; INPUTS:
;	R3 = CXB address
;	R4 = FFI block address
;
; OUTPUTS:
;	R0 clobbered
;--

LT$FFIPOSTDONE:
	PUSHR	#^M<R1,R2,R4,R5>	; Save registers
	MOVL	R3,R0			; Copy CXB address
	BSBB	LT$DEALPOOL		; Drop the buffer
	POPR	#^M<R1,R2,R4,R5>	; Restore registers
LT$DROPCXB:				; Drop all RECEIVE CXBs
	RSB

LT$DEALPOOL:
	JMP	G^EXE$DEANONPAGED	; Deallocate the FFI block

LT$END:					; End of driver

	.END
