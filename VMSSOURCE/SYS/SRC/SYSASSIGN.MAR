	.TITLE	SYSASSIGN - SYSTEM SERVICE ASSIGN I/O CHANNEL
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 25-AUG-76
;
; SYSTEM SERVICE ASSIGN I/O CHANNEL
;
; MODIFIED BY:
;
;	V03-025	LMP0274		L. Mark Pilant,		11-Jul-1984  9:27
;		Fix a bug introduced in LMP0221 that caused read access to be
;		necessary to assign a channel to a shared device.
;
;	V03-024	KPL0003		Peter Lieberwirth	 3-May-1984
;		Fix problem with remote channel assignment introduced
;		in V03-022.
;
;	V03-023	TMK0001		Todd M. Katz		28-Apr-1984
;		Eliminate the $LOGDEF data definitions.
;
;	V03-022	KPL0002		Peter Lieberwirth	24-Apr-1984
;		Fix problems with remote device assignment introduced in
;		V03-020.
;
;	V03-021 RKS0021		RICK SPITZ		10-APR-1984
;		Fix problem in assign with shadow set unit.
;		Add support for physical terminal UCB redirection to
;		a logical UCB when DEV$V_RED is set in DEVCHAR2
;
;	V03-020	KPL0001		Peter Lieberwirth	 9-Apr-1984
;		1. If the high bit in the ACMODE byte is set, don't
;		   translate the logical name, because RMS already did.
;
;		2. Use LNM$SEARCH_ONE to translate the remote device name.
;		   Allocate a KRP to contain the equivlence string since 255
;		   bytes is too much kernel stack to use.  Recursively
;		   translate the logical name.
;
;		3. Use LNM$C_MAXDEPTH as the maximum logical name recursion
;		   depth.
;
;	V03-019	LMP0221		L. Mark Pilant,		30-Mar-1984  15:38
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-018	ACG0399		Andrew C. Goldstein,	24-Feb-1984  21:42
;		Track I/O database search and interlock rewrite;
;		remove generic assign feature
;
;	V03-017 EMD0045		Ellen M. Dusseault	1-Feb-1984
;		Add check for physical io privilege (phy_io) if device
;		is a shadow set member.
;
;	V03-016	LMP0185		L. Mark Pilant,		1-Feb-1984  13:49
;		Add support for device ACLs.
;
;	V03-015	TCM0006		Trudy C. Matthews	18-Jan-1984
;		Report SS$_NOTQUEUED status from $ENQ as SS$_DEVALLOC.
;		NOTQUEUED means that the device is allocated elsewhere in
;		the cluster.
;
;	V03-014	TCM0005		Trudy C. Matthews	7-Oct-1983
;		Only take out a lock on the device if the system is
;		currently actively participating in a cluster.
;
;	V03-013	TCM0004		Trudy C. Matthews	12-Sep-1983
;		Only take out a lock on the device if the system is a member
;		of a cluster.
;
;	V03-012	TCM0003		Trudy C. Matthews	16-Jun-1983
;		Return status from EXE$LOCK_DEV rather than overwriting it
;		with SS$_DEVALLOC when we fail to obtain the lock.  Also
;		use input register R1 to signal EXE$LOCK_DEV that we're
;		not interested in the lock value block.  Add ability to
;		request a generic device channel.  Change lock mode from
;		PR to CR.
;
;	V03-011	TCM0002		Trudy C. Matthews	26-May-1983
;		Allocate the UCB on the local system while taking out the
;		cluster-wide lock.  This is to disallow changes to the UCB
;		while the locking code executes (at IPL 0, and without the
;		I/O database mutex).
;
;	V03-010	TCM0001		Trudy C. Matthews	13-May-1983
;		If this is the first $ASSIGN to a cluster-wide device,
;		take out a cluster-wide lock showing that this device has active
;		channels.
;
;	V03-009 JLV0240		Jake VanNoy		11-APR-1983
;		Prevent user with SHARE privilege from becoming owner
;		of an already owned device.
;
;	V03-008	ROW0165		Ralph O. Weber		25-FEB-1983
;		Fix cloned UCB logic to debit BYTCNT before calling the 
;		driver's CLONEDUCB routine, and to credit BYTCNT if the 
;		CLONEDUCB routine vetos the cloning.  Change cloned UCB logic 
;		to not set put PCB$L_PID in UCB$L_PID if the DEV$M_SHR bit is 
;		set in UCB$L_DEVCHAR of the cloned UCB.
;
;	V03-007	JLV0230		Jake VanNoy		24-FEB-1983
;		Add use of new SHARE privilege to allow assignment of
;		channel to an allocated non-sharable device.
;
;	V03-006	DMW4009		DMWalp			17-Nov-1982
;		Recoded call internal call to $TRNLOG to be external.
;
;	V03-005	ROW0138		Ralph O. Weber		 8-NOV-1982
;		Add to UCB cloning a check for mailbox device characteristic 
;		with automatic setting of device status bit UCB$V_DELMBX when 
;		DEV$V_MBX is set in UCB$L_DEVCHAR.  This duplicates in source 
;		the patch made to the last two system images.  The source 
;		change is being made to allow NETDRIVER to track V3.x releases 
;		and still work on the base level systems.  Once this need is 
;		no longer present, this device dependent function can be 
;		removed.
;
;	V03-004	ROW0132		Ralph O. Weber		13-OCT-1982
;		Correct call to driver's CLONEDUCB routine to conform with 
;		specification.
;
;	V03-003	ROW0127		Ralph O. Weber		 4-OCT-1982
;		Make changes required to use new UCB creation routines in 
;		UCBCREDEL.  Change netork assignment to cloning assignment 
;		with test of NETMBX priviledge iff DEV$M_NET is set in 
;		UCB$L_DEVCHAR.  Rewrite and modernize cloning assignment.  
;		Eliminate second call to TEST_MAILBOX in cloning assignment 
;		code path since all that is really desired the R6 result of 
;		the previous call and R6 is preserved by the cloning 
;		assignment code.
;
;	V03-002	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DEVDEF and fixed comments.
;
;	V03-001	PHL0101		Peter H. Lipman	21-Jun-1982
;		$QIOW now synchronizes the EFN and IOSB parameters
;		correctly.  Eliminate the synchronization code here.
;
;
;--

;
; MACRO LIBRARY CALLS
;
 
	$CCBDEF				;DEFINE CCB OFFSETS
	$CLUBDEF			;DEFINE CLUSTER BLOCK OFFSETS
	$CRBDEF				;DEFINE CONTROLLER BLOCK OFFSETS
	$DDTDEF				;DRIVER DISPATCH TABLE
	$DEVDEF				;DEFINE DEVICE TYPE CODES
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IOCDEF				;DEFINE IOC FLAG BITS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LCKDEF				;DEFINE LOCK MANAGER SYMBOLS
	$LNMDEF				;DEFINE LOGICAL NAME BLOCK OFFSETS
	$LNMSTRDEF			;DEFINE LOGICAL NAME BLOCK OFFSETS
	$ORBDEF				;DEFINE OBJECT'S RIGHTS BLOCK OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$TTYUCBDEF			;DEFINE TERMINAL SPECIFIC UCB FIELDS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE VECTOR OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
DEVNAM=4				;ADDRESS OF DEVICE NAME STRING DESCRIPTOR
CHAN=8					;ADDRESS TO STORE ASSIGNED CHANNEL NUMBER
ACMODE=12				;ACCESS MODE
MBXNAM=16				;ADDRESS OF MAILBOX NAME STRING DESCRIPTOR
 
;
; STACK LOCAL STORAGE SYMBOL
;
	$OFFSET	0,NEGATIVE,<-
		MAXACMODE>		;MAXIMIZED ACCESS MODE

;
; LOCAL DATA
;
 
	.PSECT	Y$EXEPAGED


LNM_TBL:
	.ASCID	"LNM$FILE_DEV"		;LOGICAL NAME TABLE FOR DEVICES

NETNAM:	.ASCII	/_NET/			;NETWORK DEVICE NAME
NETEND:					;REFERENCE LABEL

	.SBTTL	ASSIGN I/O CHANNEL
;+
; EXE$ASSIGN - ASSIGN I/O CHANNEL
;
; THIS SERVICE PROVIDES THE CAPABILITY TO ASSIGN A DEVICE TO AN I/O CHANNEL
; AND ESTABLISH NECESSARY DEVICE LINKAGE AND CONTROL INFORMATION IN THE
; ASSOCIATED CHANNEL CONTROL BLOCK. OPTIONALLY A MAILBOX CAN ALSO BE
; SPECIFIED WHICH WILL RECEIVE UNSOLICITED INPUT SENT TO THE ASSIGNED
; DEVICE.
;
; INPUTS:
;
;	DEVNAM(AP) = ADDRESS OF DEVICE NAME STRING DESCRIPTOR.
;	CHAN(AP)   = ADDRESS TO STORE ASSIGNED CHANNEL NUMBER.
;	ACMODE(AP) = ACCESS MODE CHANNEL IS TO BE ASSIGNED TO.
;		     HIGH BIT OF ACMODE BYTE SET MEANS DON'T TRANSLATE
;		     LOGICAL NAME.
;	MBXNAM(AP) = ADDRESS OF MAILBOX NAME STRING DESCRIPTOR (ZERO IMPLIES
;		     NONE).
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO ASSIGN CHANNEL TO DEVICE.
;
;		R0 = SS$_ACCVIO - DEVICE NAME STRING, DEVICE NAME STRING
;			DESCRIPTOR, MAILBOX NAME STRING, OR MAILBOX NAME
;			STRING DESCRIPTOR CANNOT BE READ BY CALLING ACCESS
;			MODE, OR CHANNEL NUMBER CANNOT BE WRITTEN BY CALLING
;			ACCESS MODE.
;
;		R0 = SS$_DEVALLOC - DEVICE ALLOCATED TO ANOTHER PROCESS.
;
;		R0 = SS$_DEVNOTMBX - SPECIFIED MAILBOX DEVICE IS NOT A
;			MAILBOX.
;
;		R0 = SS$_EXQUOTA - PROCESS HAS INSUFFICIENT BUFFER QUOTA TO
;			ALLOCATE NETWORK UCB.
;
;		R0 = SS$_INSFMEM - SUFFICIENT SYSTEM DYNAMIC MEMORY DOES NOT
;			EXIST TO ALLOCATE NETWORK UCB.
;
;		R0 = SS$_IVDEVNAM - DEVICE OR MAILBOX NAME STRING CONTAINS
;			INVALID CHARACTERS, OR NO DEVICE NAME STRING
;			DESCRIPTOR SPECIFIED.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			DEVICE OR MAILBOX NAME STRING SPECIFIED.
;
;		R0 = SS$_TOOMANYLNAM - ITERATION LIMIT ON LOGICAL NAME
;		        TRANSLATION EXCEEDED.
;
;		R0 = SS$_NOIOCHAN - NO I/O CHANNEL IS AVAILABLE FOR ASSIGNMENT.
;
;		R0 = SS$_NOPRIV - PROCESS DOES NOT HAVE PRIVILEGE TO CREATE
;			NETWORK UCB OR DOES NOT HAVE PRIVILEGE TO ALLOCATE
;			THE DEVICE.
;
;		R0 = SS$_NOSUCHDEV - SPECIFIED DEVICE OR MAILBOX DOES NOT
;			EXIST ON HOST SYSTEM.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_REMOTE - NORMAL COMPLETION, ASSIGNMENT COMPLETED
;			ON REMOTE SYSTEM.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION, ASSIGNMENT COMPLETED
;			ON HOST SYSTEM.
;	
;		R0 = SS$_DEVACTIVE - MAILBOX ALREADY ASSOCIATED WITH DEVICE
;-
 
	.ENTRY	EXE$ASSIGN,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CLRL	-(SP)			;SPACE FOR STACK LOCAL
	MOVL	CHAN(AP),R11		;GET ADDRESS TO STORE CHANNEL NUMBER
	IFNOWRT	#2,(R11),30$		;CAN CHANNEL NUMBER BE WRITTEN?
	CLRW	(R11)			;CLEAR CHANNEL NUMBER IN CASE OF ERROR
	MOVL	MBXNAM(AP),R10		;GET ADDRESS OF MAILBOX NAME DESCRIPTOR
	BEQL	10$			;IF EQL NO MAILBOX SPECIFIED
	IFNORD	#8,(R10),30$		;CAN MAILBOX DESCRIPTOR BE READ?
	MOVQ	(R10),-(SP)		;COPY MAILBOX NAME DESCRIPTOR
	MOVL	SP,R10			;SET ADDRESS OF MAILBOX NAME DESCRIPTOR
10$:	MOVZWL	#SS$_IVDEVNAM,R0	;SET INVALID DEVICE NAME STATUS
	MOVL	DEVNAM(AP),R9		;GET ADDRESS OF DEVICE NAME DESCRIPTOR
	BEQL	20$			;IF EQL NO DEVICE SPECIFIED
	IFNORD	#8,(R9),30$		;CAN DEVICE NAME DESCRIPTOR BE READ?
	EXTZV	#0,#2,ACMODE(AP),R0	;GET SPECIFIED ACCESS MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE ACCESS MODE
	MOVL	R0,MAXACMODE(FP)	;SAVE MAXIMIZED ACCESS MODE
	BSBW	IOC$FFCHAN		;FIND FREE I/O CHANNEL
	BLBS	R0,FREECHAN		;IF LBS FREE I/O CHANNEL FOUND
20$:	RET				;
30$:	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION STATUS
	RET				;

;
; IF THE CALLER SETS THE HIGH BIT IN THE ACMODE BYTE, IT IS INTERPRETED HERE
; AS A FLAG INDICATING IT IS UNNECESSARY TO TRANSLATE THE LOGICAL NAME BECAUSE
; THE CALLER ALREADY HAS.
;

	.ENABL	LSB
0$:	BRW	90$			;UNLOCK DATABASE AND RETURN BRANCH AID
FREECHAN:				;FREE CHANNEL FOUND
	MOVQ	R1,R7			;SAVE CHANNEL AND CCB ADDRESS
	BSBW	SCH$IOLOCKW		;LOCK I/O DATA BASE FOR WRITE ACCESS
	BSBW	TEST_MAILBOX		;TEST IF MAILBOX SPECIFIED
	BLBC	R0,0$			;IF LBC SEARCH FAILURE
	MOVZBL	#IOC$M_PHY!IOC$M_ANY,R2	;PHYSICAL DEVICE, NO CHECKS, NO LNM MODE
	TSTB	ACMODE(AP)		;HIGH BIT SET INDICATES NO $TRNLNM TO DO
	BGEQ	3$			;BRANCH IF MUST TRANSLATE LOGICAL NAME
	BBSS	#IOC$V_NO_TRANS,R2,3$	;TELL IOC$TRANDEVNAM NOT TO DO $TRNLNM
3$:	MOVL	R9,R1			;SET ADDRESS OF DEVICE NAME DESCRIPTOR
 	CLRL	R3			;NO LOCK VALUE BLOCK
	BSBW	IOC$SEARCH		;SEARCH FOR DEVICE
	BLBC	R0,40$			;IF LBC SEARCH FAILURE
    	BBC	S^#DEV$V_RED,UCB$L_DEVCHAR2(R1),4$; SKIP IF NOT REDIRECTED
					; PHYSICAL TERMINAL UCB
	MOVL	UCB$L_TT_LOGUCB(R1),R1	; REDIRECT TO ASSOCIATED LOGICAL TTY UCB 
;
; DEVICE FOUND
;
 
4$:	MOVL	R1,R5			;SAVE ADDRESS OF DEVICE UCB
	BBS	S^#DEV$V_SPL,UCB$L_DEVCHAR(R5),5$ ;IF SET, SPOOLED DEVICE
    	BBS	S^#DEV$V_SSM,UCB$L_DEVCHAR2(R5),6$ ;If set, shadow set member
	BBC	S^#UCB$V_TEMPLATE, -	; Branch if this assignment is not
		UCB$L_STS(R5), LOCAL	; to a cloned device.
	BRW	CLONE_UCB		; Else, brach to clone the UCB.
5$:	BRW	80$			; spooled device 
6$:
    	IFPRIV	PHY_IO,LOCAL		; Must have phy_io priv, if shadow set member
    	MOVZWL	#SS$_NOPHY_IO,R0	; Exit with physical_io priv error
	BRW	90$			; Unlock I/O database

; LOCAL ASSIGNMENT
;
 
LOCAL:					;LOCAL ASSIGNMENT
	MOVL	UCB$L_PID(R5),R0	;GET PROCESS ID OF OWNER
	BEQL	50$			;IF EQL DEVICE NOT ALLOCATED
	MOVL	R4,R1			;COPY PROCESS PCB ADDRESS
10$:	CMPL	R0,PCB$L_PID(R1)	;PROCESS ID MATCH?
	BEQL	70$			;IF EQL YES
	MOVZWL	PCB$L_OWNER(R1),R1	;GET CREATOR PROCESS INDEX
	BEQL	20$			;IF EQL NO CREATOR
	MOVL	@L^SCH$GL_PCBVEC[R1],R1	;GET ADDRESS OF CREATOR PCB
	BRB	10$			;
20$:	IFPRIV	SHARE,50$		;BRANCH IF SHARE PRIV ENABLED
	MOVZWL	#SS$_DEVALLOC,R0	;SET DEVICE ALREADY ALLOCATED
30$:	BRW	90$			;
 
;
; DEVICE SEARCH FAILURE
;
 
40$:	CMPW	#SS$_NONLOCAL,R0	;REMOTE DEVICE?
	BNEQ	30$			;IF NEQ NO
	BRW	REMOTE			;
 
;
; DEVICE NOT SPOOLED OR ALLOCATED - IF IT'S ALSO NOT SHAREABLE, CHECK THAT
; PROCESS HAS PRIVILEGE TO ALLOCATE IT
;
 
50$:	BBS	S^#DEV$V_SHR,UCB$L_DEVCHAR(R5),70$ ;IF SET, DEVICE SHAREABLE
	BSBW	EXE$CHKRDACCES		;CHECK USER'S RIGHT TO ALLOCATE DEVICE
					; R4 = PCB ADDRESS
					; R5 = UCB ADDRESS
	BLBS	R0,60$			;CONTINUE IF SUCCESS
	BRW	90$			;IF LBC NO PRIVILEGE
;
; PERFORM IMPLICIT ALLOCATION IF DEVICE NOT SHARABLE.
; NOTE!! THIS CODE ASSUMES THAT NON-SHAREABLE DEVICES ARE NOT
; CLUSTER VISIBLE. IF THIS ASSUMPTION EVER CHANGES, SUITABLE TESTS
; AND A CALL TO IOC$LOCK_DEV MUST BE ADDED HERE.
;
 
60$:	TSTL	UCB$L_PID(R5)		;CHECK TO SEE IF OWNED
	BNEQ	70$			;BRANCH IF IT IS
	MOVL	PCB$L_PID(R4),UCB$L_PID(R5) ;SET CURRENT PROCESS AS OWNER
 
;
; ASSOCIATE MAILBOX IF:
;
;	1. NOT FILE DEVICE
;	2. NOT SHAREABLE DEVICE
;	3. MAILBOX NOT ALREADY ASSOCIATED
;	4. MAILBOX IS SPECIFIED
;
 
70$:	BBS	S^#DEV$V_FOD,UCB$L_DEVCHAR(R5),80$ ;IF SET, FILE DEVICE
	BBS	S^#DEV$V_SHR,UCB$L_DEVCHAR(R5),80$ ;IF SET, SHARED DEVICE
	TSTL	R6			;ARE WE ASSOCIATING A MBX
	BEQL	80$			;IF NOT JUST CONTINUE
	TSTL	UCB$L_AMB(R5)		;IS THERE ONE CURRENTLY ASSOC?
	BEQL	75$			;IF NOT ASSOC NEW ONE
	CMPL	R6,UCB$L_AMB(R5)	;TRYING TO ASSOC DIFFERENT MBX?
	BEQL	80$			;IF NOT JUST CONTINUE
	MOVZWL	#SS$_DEVACTIVE,R0	;DON'T DO THE ASSIGN
	BRB	90$			;RETURN THE ERROR

75$:	MOVL	R6,UCB$L_AMB(R5)	;SET ASSOCIATED MAILBOX UCB ADDRESS
	INCW	UCB$W_REFC(R6)		;INCREMENT MAILBOX UCB REFERENCE COUNT
	MOVZBL	#CCB$M_AMB,R6		;SET ASSOCIATED MAILBOX FLAG
;
; If this is the first $ASSIGN to a device that is available cluster-wide,
; take out a lock to show that this device is active.
;
80$:	TSTW	UCB$W_REFC(R5)		;IS THIS THE FIRST CHANNEL ASSIGNED?
	BNEQ	85$			;BRANCH IF NOT
	IFNOCLSTR	85$		;BRANCH IF WE'RE NOT IN A CLUSTER
	BBC	#DEV$V_CLU, -		;BRANCH IF DEVICE IS NOT AVAILABLE
		UCB$L_DEVCHAR2(R5),85$	;CLUSTER-WIDE
	MOVL	CLU$GL_CLUB,R0		;GET ADDRESS OF CLUSTER BLOCK
	BBC	#CLUB$V_CLUSTER, -	;BRANCH IF WE HAVEN'T JOINED THE
		CLUB$L_FLAGS(R0),85$	;CLUSTER YET
82$:	MOVL	#LCK$K_CRMODE,R0	;CR MODE FOR CHANNEL ASSIGNS
	CLRL	R1			;DON'T WANT VALUE BLOCK RETURNED
	BSBW	IOC$LOCK_DEV		;TAKE OUT A LOCK ON THE DEVICE
83$:	BLBC	R0,90$			;BRANCH IF WE DIDN'T GET THE LOCK

85$:	MOVL	R5,CCB$L_UCB(R8)	;STORE UCB ADDRESS IN CCB
	INCW	UCB$W_REFC(R5)		;INCREMENT UCB REFERENCE COUNT
	ADDB3	#1,MAXACMODE(FP),CCB$B_AMOD(R8)	;STORE ACCESS MODE OF CHANNEL
	MOVB	R6,CCB$B_STS(R8)	;SET CHANNEL STATUS FLAGS
	MOVW	R7,(R11)		;STORE ASSIGNED CHANNEL NUMBER
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
90$:	BRW	IOC$UNLOCK		;UNLOCK I/O DATA BASE AND RETURN
 
;
; ASSIGNMENT OF A CLONED UCB
;

CLONE_UCB:
	BBC	#DEV$V_NET, -		; Branch if this device is not a
		UCB$L_DEVCHAR(R5), 210$	; network device.
	MOVZWL	#SS$_NONETMBX, R0	; Else, the process must have NETMBX
	IFNPRIV	NETMBX, 90$		; privilege to perform this operation.
210$:	BSBW	IOC$CHKUCBQUOTA		; Does process have enough BYTLM quota?
	BLBC	R0, 90$			; Branch if insufficient BYTLM quota.
	BSBW	IOC$CLONE_UCB		; Make the clone UCB.
	BLBC	R0, 90$			; Branch if clone opeation failed.

	ASSUME ORB$L_OWNER EQ 0

	MOVL	PCB$L_UIC(R4), -	; Make the current UIC the owner of 
		@UCB$L_ORB(R2)		; the cloned UCB.
	BBSS	#UCB$V_DELETEUCB, -	; Mark the cloned UCB for automatic
		UCB$L_STS(R2),213$	; deletion when the ref. count reaches
					; zero.
213$:	BBC	#DEV$V_MBX, -		; Does this device behave like a
		UCB$L_DEVCHAR(R2),215$	; mailbox? Branch if not.
	BISW	#UCB$M_DELMBX, -	; Else, set mailbox-like delete bit.
		UCB$W_DEVSTS(R2)
215$:	CLRW	UCB$W_REFC(R2)		; Zero the cloned UCB reference count;
					; it will be incremented when the
					; channel assignment is completed.
	BSBW	IOC$DEBIT_UCB		; Debit process quota for cloned UCB.
	MOVL	UCB$L_DDT(R5), R3	; Get DDT address.
	MOVZWL	#SS$_NORMAL, R0		; Assume success return from driver.
	JSB	@DDT$L_CLONEDUCB(R3)	; Call the driver's cloned UCB routine.
	MOVL	R2, R5			; Make the cloned UCB the current UCB.
	BLBC	R0, 290$		; Branch if driver vetos cloning.
	BBS	#DEV$V_SHR, -		; Branch if cloning a sharable UCB.
		UCB$L_DEVCHAR(R5), 240$
	MOVL	PCB$L_PID(R4), UCB$L_PID(R5) ; Else, do implicit allocation.
240$:	BRW	70$			; Go complete normal channel assignment.

290$:	PUSHL	R0			; Save reason for aborting cloning oper.
	BSBW	IOC$CREDIT_UCB		; Credit process quota for cloned UCB.
	BSBW	IOC$DELETE_UCB		; Delete cloned UCB.
	POPL	R0			; Restore return status.
	BRB	90$			; Complete operation with error status.

	.DSABL	LSB
	.PAGE
	.SBTTL	REMOTE DEVICE SPECIFIED

NO_KRP:	BUG_CHECK	KRPEMPTY,FATAL 

;
; REMOTE DEVICE SPECIFIED
;
;	R9 STILL POINTS TO DEVNAM DESCRIPTOR
;	R10 STILL POINTS TO ASSOCIATED MAILBOX DESCRIPTOR
REMOTE:

;
; CASE_BLIND FLAG (R5 INPUT) FOR LNM$SEARCH_ONE, CONCATENATE "USER-MODE"
; FOR NOW
;
M_CASE_BLIND	= ^X0103

;
; KRP USAGE FOR REMOTE LNM TRANSLATION
;
LOGNAM		= 0			;LOGICAL NAME DESCRIPTOR
LNMX_OFFSET	= LOGNAM+8		;LOGICAL NAME DATA

;
; SINCE THE KRP CONTAINS THE LOGICAL NAME EQUIVALENCE STRING AND THE
; INPUTS TO THE $TRNLNM SERVICE, NEED TO MAKE SURE ONE KRP IS ENOUGH.
;
	ASSUME	<LNMX_OFFSET + <LNMX$T_XLATION+1> + LNM$C_NAMLENGTH> LE 512

	BSBW	SCH$IOUNLOCK		;UNLOCK I/O DATA BASE
	SETIPL	#0			;ALLOW INTERRUPTS
	MOVAB	G^CTL$GL_KRPFL,R3	;GET ADDRESS OF KRP LOOKASIDE LIST
	REMQUE	@4(R3),R8		;GET A KRP
	BVS	NO_KRP			;BUG_CHECK IF NO KRPS TO USE
	MOVZWL	(R9),R0			;GET LENGTH OF LOGICAL NAME STRING
	BEQL	60$			;BRANCH IF ILLEGAL LENGTH
	ASSUME	LNM$C_NAMLENGTH-1 LE 512 ;ASSUME ONE PROBE WILL DO
	CMPW	R0,#LNM$C_NAMLENGTH-1	;LOGICAL NAME STRING TOO LONG?
	BGTR	60$			;IF GTR, SIZE TOO LARGE
	MOVL	4(R9),R1		;GET ADDRESS OF LOGICAL NAME STRING
	IFNORD	R0,(R1),80$		;PROBE INPUT LOGICAL NAME
;
; TRANSLATE THE NET LOGICAL NAME
;
	MOVL	#LNM$C_MAXDEPTH,R7	;10 TRANSLATION LIMIT
	MOVAL	LNMX_OFFSET(R8),R6	;OUTPUT BUFFER
	CLRQ	(R6)			;INITIALIZE LNMX
	MOVB	R0,LNMX$T_XLATION(R6)	;INITIAL STRING LENGTH
	PUSHR	#^M<R4>			;SAVE PCB
	MOVC3	R0,(R1),-		;COPY INITIAL STRING TO LNMX
		<LNMX$T_XLATION+1>(R6)	;
	POPR	#^M<R4>			;RESTORE PCB
	BRW	30$			;TAKE FIRST STAB AT TRANSLATION
					;LOGICAL NAME DESCRIPTOR IN R0/R1
10$:	MOVZWL	LNM_TBL,R2		;GET TABLE NAME LENGTH
	MOVL	LNM_TBL+4,R3		;AND TABLE NAME ADDRESS
	MOVZWL	#M_CASE_BLIND,R5	;CASE-BLIND TRANSLATION, USER-MODE
20$:	JSB	LNM$SEARCH_ONE		;TRANSLATE LOGICAL NAME
	BLBS	R0,30$			;BRANCH IF TRANSLATION OCCURED
	CMPW	#SS$_NOLOGNAM,R0	;TRANSLATION FAILURE?
	BNEQ	70$			;NO, SOME SERIOUS PROBLEM
	BBCS	#LNMX$V_TERMINAL,-	;INDICATE NO MORE TRANSLATIONS
		LNMX$B_FLAGS(R6),30$	;
30$:	MOVAL	<LNMX$T_XLATION+1>(R6),-;RESET LOGICAL NAME DESCRIPTOR
		R1			; ADDRESS
	MOVZBL	LNMX$T_XLATION(R6),R0	; SIZE
40$:	CMPB	#^A/_/,(R1)		;TRANSLATED NAME START WITH UNDERSCORE?
	BNEQ	50$			;IF NEQ NO
	DECL	R0			;DECREMENT LENGTH OF TRANSLATED NAME
	BEQL	60$			;BRANCH IF LENGTH ILLEGAL
	INCL	R1			;INCREMENT STARTING ADDRESS OF NAME
	BBCS	#LNMX$V_TERMINAL,-	;TERMINAL DUE TO PRESENCE OF "_",
		LNMX$B_FLAGS(R6),40$	; LOOK FOR ANOTHER "_"
50$:	BBS	#LNMX$V_TERMINAL,-	;IF DONE, GO ASSIGN CHANNEL
		LNMX$B_FLAGS(R6),90$	;
	SOBGEQ	R7,10$			;KEEP ON TRANSLATING
	BRB	100$			;OOPS, TOO MANY TRANSLATIONS
60$:	MOVZWL	#SS$_IVLOGNAM,R0	;INPUT SIZE TO LARGE
70$:	BRB	120$			;
80$:	MOVZWL	#SS$_ACCVIO,R0		;CAN NOT READ WHERE DESC POINTS
	BRB	120$			;
90$:	MOVQ	R0,LOGNAM(R8)		;SAVE DESCRIPTOR IN A BETTER PLACE
	MOVAL	LOGNAM(R8),R9		;SET ADDRESS OF TRANSLATED NAME DESCRIPTOR
	PUSHAB	NETNAM			;BUILD NETWORK DEVICE NAME DESCRIPTOR
	PUSHL	#NETEND-NETNAM		;
	MOVL	SP,R6			;SAVE ADDRESS OF NAME STRING DESCRIPTOR
	MOVAL	-(SP),R7		;ALLOCATE SPACE TO STORE CHANNEL NUMBER
	$ASSIGN_S (R6),(R7),MAXACMODE(FP),(R10)	;ASSIGN CHANNEL TO NETWORK
	BLBC	R0,120$			;IF LBC ASSIGNMENT FAILURE
	$QIOW_S	S^#EXE$C_SYSEFN,(R7),#IO$_ACCESS!IO$M_ACCESS,(R6),,,,R9
					;CONNECT TO NETWORK
	BLBC	R0,110$			;IF LBC SERVICE FAILURE
	MOVZWL	(R6),R0			;GET I/O COMPLETION CODE
	BLBC	R0,110$			;IF LBC CONNECT FAILURE
	MOVW	(R7),(R11)		;STORE ASSIGNED DEVICE CHANNEL NUMBER
	MOVZWL	#SS$_REMOTE,R0		;SET COMPLETION STATUS
	BRB	120$			;
100$:	MOVZWL	#SS$_TOOMANYLNAM,R0	;TOO MANY EQUIVALENCE NAMES DEFINED
	BRB	120$			;
110$:	PUSHL	R0			;SAVE FINAL STATUS
	$DASSGN_S (R7)			;DEASSIGN CHANNEL
	POPL	R0			;RETRIEVE FINAL STATUS
120$:					;ONLY REMAINING WORK - RETURN KRP
					;R8 STILL POINTS TO KRP
	MOVAB	G^CTL$GL_KRPFL,R3	;GET ADDRESS OF KRP LOOKASIDE LIST
	INSQUE	(R8),@4(R3)		;RETURN KRP TO LIST
	RET				;

	.SBTTL	TEST IF MAILBOX SPECIFIED
;
; SUBROUTINE TO TEST IF A MAILBOX IS SPECIFIED
;
; INPUTS:
;
;	R10 = ADDRESS OF MAILBOX NAME DESCRIPTOR
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL IF SPECIFIED MAILBOX EXISTS
;	     SS$_NOSUCHDEV IF SPECIFIED MAILBOX DOES NOT EXIST
;	     SS$_DEVNOTMBX IF SPECIFIED DEVICE IS NOT A MAILBOX
;	R6 = ADDRESS OF MAILBOX UCB
;	     ZERO IF MAILBOX NOT SPECIFIED (USED AS CHANNEL STATUS FLAGS)
;
 
TEST_MAILBOX:				;
	MOVL	R10,R6			;SET ADDRESS OF MAILBOX NAME DESCRIPTOR
	BEQL	10$			;IF EQL NO NAME SPECIFIED
	MOVL	R6,R1			;COPY ADDRESS OF MAILBOX NAME DESCRIPTOR
	BSBW	IOC$SEARCHDEV		;SEARCH FOR DEVICE
	BLBC	R0,20$			;IF LBC SEARCH ERROR
	MOVZWL	#SS$_DEVNOTMBX,R0	;SET DEVICE NOT MAILBOX STATUS
	BBC	S^#DEV$V_MBX,UCB$L_DEVCHAR(R1),20$ ;IF CLR, DEVICE NOT MAILBOX
	BBS	S^#DEV$V_NET,UCB$L_DEVCHAR(R1),20$ ;IF SET, NETWORK DEVICE
	MOVL	R1,R6			;SAVE ADDRESS OF MAILBOX UCB
10$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
20$:	RSB				;
 
	.END
