	.TITLE	PAFPCALL
	.IDENT	'V04-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:  SCS ROUTINES AVAILABLE TO FORK PROCESSES WHICH
;	     ARE CI PORT-SPECIFIC.
;
; AUTHOR:  N. KRONENBERG,  MAY 1981
;
; MODIFIED BY:
;
;	V04-001	NPK3066		N. Kronenberg		 9-Sep-1984
;		Upon deallocation of a message buffer that results
;		in the decision to extend more credit, bypass call
;		to SCS$REQ_SCSSEND to extend credit if the CDT state
;		shows that the SYSAP has done a DISCONNECT.  (Formerly
;		the SCS$REQ_SCSSEND call was bypassed iff the CDT was
;		actually queued for SCS sending already.  This is
;		incorrect since it would allow a credit to be extended
;		after the DISCONNECT_REQUEST was sent.)
;		RSPID mismatch on completion of a block transfer 
;		(RD_SEQ_ERR) corrected to back msg pointer up by 
;		PPD header length prior to crashing port.
;
;	V03-025	NPK3054		N. Kronenberg		24-Jun-1984
;		Since SCS$REQ_SCSSEND will now ensure that a CDT
;		will not be queued on the SCS send buffer wait queue
;		if it is already waiting, change DISCONNECT from the
;		open state not to check for this condition.  The
;		check is being moved to SCS$REQ_SCSSEND because there
;		were several other conditions that required the check
;		that were not making it and that could corrupt the
;		wait queue.
;
;	V03-024	NPK3047		N. Kronenberg		22-Mar-1984
;		Add FPC$STOP_VCS entry to send host shutdowns to
;		to all vcs on shutdown or bugcheck.
;
;	V03-023	NPK3048		N. Kronenberg		16-Mar-1984
;		Fix FPC$SNDCNTMSG to set retflag=true by putting
;		1 in R0 instead of SYSAP$C_DISPPO.
;
;	V03-022	NPK3046		N. Kronenberg		 7-Mar-1984
;		Improve comments for FPC$READCOUNT.
;
;	V03-021	TMK0002		Todd M. Katz		21-Feb-1984
;		Change FPC$INITIAL so that the buffer descriptors are allocated
;		by calling EXE$ALONONPAGED instead of INI$HIPALC. This can be
;		done because this routine is now being called at fork IPL 
;		instead of at IPL$_POWER.
;
;	V03-020	TMK0001		Todd M. Katz		29-Jan-1984
;		Fix an error path for the MRESET and MSTART fork process
;		calls. In both cases when the appropriate PPD action routine
;	  	returns an error, the error path that is taken does a PUSHR of
;		R0 (instead of a PUSHL) to save the return status over the 
;		datagram buffer deallocation. This PUSHR results in the stack 
;		being corrupted in a variety of interesting fashions depending 
;		upon the error code that is residing in R0.
;
;	V03-019	NPK3039		N. Kronenberg		11-Jan-1984
;		On receipt of DATREC, CNFREC return the response msg
;		to pool unconditionally.  Previously it was returned
;		to the msg free queue if that queue was not up to
;		the initial receive credit and this could cause credits
;		to build without bound.
;		Fix RD_SEQ_ERR and SC_SEQ_ERR to first look up the
;		PB (if any) associated with the response in hand, and
;		then branch to INT$/RSP_CRASH_PORT which expects R1
;		to have the PB address or 0 if no PB.
;
;	V03-018	NPK3037		N. Kronenberg		11-Nov-1983
;		Add $DEBUGCHECK on block xfer XCTID sequence number
;		error and source conid sequence number error.
;		Fix source connection id check to not delete a sent 
;		message twice.
;
;	V03-017	NPK3036		N. Kronenberg		21-Oct-1983
;		Correct bug in stack management in FPC$MSTART.
;
;	V03-016	NPK3034		N. Kronenberg		13-Sep-1983
;		Fix stepping count of number of bytes mapped to add
;		from byte count pointed to by R1 rather than IRP.
;
;	V03-015	NPK3029		N. Kronenberg		14-Jul-1983
;		Enhancements for V4.0.
;		Set local/remote process names in scs msg attached to
;		CDT when connect is issued rather than waiting for accept.
;		Add per connection performance counters.
;		Correct benign bug in msg deallocation in deciding
;		whether to return buffer to pool or free queue.
;		In FPC$SNDCNTMSG with no rspid decide if port should
;		put sent buffer on free queue before sending it.
;		Add new entry FPC$SNDRGDG to send a dg without a CDRP.
;		Remove NPK3026 since it is taken care of by zeroing
;		CDRP$L_MSG_BUF at the time the block xfer is started.
;
;	V03-014 NPK3026		N. Kronenberg		18-May-1983
;		Fix FPC$REC_CNFREC/DATREC to zero CDRP$L_MSG_BUF.
;
;		NPK3025		N. Kronenberg		18-May-1983
;		Fix the fix to insufficient memory on ACCEPT call.
;
;	V03-013	KTA3046		Kerbey T. Altmann	28-Mar-1983
;		Redo for SCS/PPD split.
;
;	V03-012	NPK3017		N. Kronenberg		28-Feb-1983
;		Fix R0 destroyed on READ counters busy.
;
;	V03-011	NPK3016		N. Kronenberg		28-Feb-1983
;		Fix insufficient dg/msg buffers on ACCEPT call.
;
;	V03-010	NPK3010		N. Kronenberg		11-Nov-1982
;		Invoke $SYSAPDEF.  Add dg disposal flag value assumes.
;		Fix insfmem path in FPC$MSTART.
;
;	V03-009	NPK3009		N. Kronenberg		 2-Nov-1982
;		Zero application dg credit field.
;
;	V03-008	NPK3008		N. Kronenberg		 6-Oct-1982
;		Change disconnect on CDT in illegal state to crash
;		the VC instead of returning error status to caller
;		and doing nothing.  Change disconnect on CDT in
;		disc_ack state to crash VC instead of simple unilateral
;		break of connection.
;
;	V03-007	NPK3007		N. Kronenberg		 5-Oct-1982
;		Fixed bug in MAP which incorrectly saved the context
;		of multiple buffer descriptor waiters.
;
;	V03-006	NPK3006		N. Kronenberg		 9-Sep-1982
;		Fixed bug in waiting for buffer descriptor.
;
;	V03-005	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DYNDEF, $DCDEF, $PRDEF, and $SSDEF.
;
;	V03-004	NPK3002		N. Kronenberg		1-Jul-1982
;		Fix ACCEPT to return correct status in R0 on 
;		insufficient memory and to preserve addr of listen
;		CDT.
;
;
;--

	.SBTTL	DEFINITIONS

;
; Set PSECT to driver code:
;

	.PSECT	$$$115_DRIVER,LONG

;
; System definitions (LIB.MLB):
;

	.nocross
	$CDLDEF				; Connection descriptor list
	$CDRPDEF			; Class driver request packet format
	$CDTDEF				; Connection descriptor format
	$CIBDDEF			; CI buffer descriptor format
	$CIBDTDEF			; CI buffer desc table format
	$CIBHANDEF			; CI buffer handle format
	$DYNDEF				; Dynamic block codes
	$IRPDEF				; Define IRP offsets and bits
	$PBDEF				; Path Block format
	$PDTDEF				; Port descriptor format
	$PRDEF				; Define processor register definitions
	$RDDEF				; Response descriptor format
	$RDTDEF				; Response descriptor list
	$SCSDEF				; SCS message format
	$SSDEF				; System-wide status codes
	$SYSAPDEF			; Send/recv dg flags
	.cross

	.SBTTL	UNIMPLEMENTED FORK PROCESS CALLS

FPC$MAINTFCN::

	MOVZWL	#SS$_ILLIOFUNC,R0	; Set error status for caller
	RSB				; Return to caller

	.SBTTL	CONNECTION MANAGEMENT CALLS
	.SBTTL	-	FPC$CONNECT,	COMPLETE PROCESSING A CONNECT

;+
; This routine is JMP'ed to from SCS$CONNECT with a CDT allocated
; (and in the closed state) and initialized with the SYSAP's
; connect parameters or 0's for fields not yet used.  FPC$CONNECT
; does port-specific processing:  allocates SCS control message
; receive buffer, initial credit worth of receive message buffers,
; and initial datagram buffers.  FPC$CONNECT then sets the CDT
; state to connect sent and queues the CDT to send a CONNECT_REQ 
; message to the remote system.  Finally, FPC$CONNECT suspends the
; SYSAP.
;
; Inputs:
;
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
;	CDT initialized as follows:
;
;	CDT$L_LCONID		-Local conid
;	      MSGINPUT		-Addr to call in SYSAP for rec'd msgs
;	      DGINPUT		-Addr to call in SYSAP for rec'd dgs
;	      ERRADDR		-Addr to call in SYSAP for connection errors
;	      RSTATION		-Remote station addr
;	      PDT		-Addr of PDT
;	      MINSEND		-Minimum send credit req'd by SYSAP
;	      INITLREC		-Initial credit extended by SYSAP
;	      DGREC		-Initial # of dg's queued 
;	      STATE		-CLOSED
;	      PB		-Addr of selected PB to remote system
;	      WAITQFL/BL	-Set to show no entries
;	      RPROCNAM		-Addr of dest process name
;	      LPROCNAM		-Addr of local process name
;	      CONDAT		-Addr of connect data
;
;	other CDT fields	-0
;
;
;	(SP)			-Return PC in SYSAP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_FAILRSP,
;					  SS$_REJECT, SS$_INSFMEM
;	R1			-Reject reason or fail response reason
;				 if R0 = REJECT or FAILRSP
;	R2			-Addr of ACCEPT_REQ if R0 = success
;	other registers		-Preserved
;-

	.ENABL	LSB

FPC$CONNECT::

	$CHK_CDTSTATE -			; Verify that CDT state 
		CLOSED,-		;  is closed;  if not,
		ERROR=STATE_ERR		;  caller made error
	BSBW	SCS$ALL_ALLBUF		; Allocate all buffers needed
	BLBC	R0,CON_MEM_FAIL		; Branch if failed
	MOVL	CDT$L_SCSMSG(R3),R2	; Get addr of SCS receive buffer
	MOVL	CDT$L_LPROCNAM(R3),R0	; Copy local process name
	MOVQ	(R0)+,SCS$T_DST_PROC(R2);  into SCS recv buffer as destination
	MOVQ	(R0)+,SCS$T_DST_PROC+8(R2)  
	MOVL	CDT$L_RPROCNAM(R3),R0	;  process and remote process name
	MOVQ	(R0)+,SCS$T_SRC_PROC(R2);  as source process.  Allows SHOW
	MOVQ	(R0)+,SCS$T_SRC_PROC+8(R2)
					;  CLUSTER to report process names
					;  for incomplete connect calls
	MOVL	CDT$L_PB(R3),R0		; Get path block addr for CDT
	MOVL	PB$L_CDTLST(R0),-	; Link this new CDT onto
		CDT$L_CDTLST(R3)	;  the head of the CDT list
	MOVL	R3,PB$L_CDTLST(R0)	;  for this path
	MOVW	#CDT$C_CON_SENT,-	; Move CDT state to
		CDT$W_STATE(R3)		;  connect sent
	MOVZWL	#CDT$C_CON_PEND,R0	; Get block state
	BRB	SCSSEND			; Ask to send CONNECT_REQ & suspend

CON_MEM_FAIL:

	PUSHL	R0			; Save error status

CON_MEM_FAIL1:

	JSB	G^SCS$DEALL_CDT		; Deallocate CDT
	POPL	R0			; Retreive status
	RSB				; Return error to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$ACCEPT,	COMPLETE PROCESSING AN ACCEPT

;+
; This routine is JMP'ed to by SCS$ACCEPT which allocates and inits
; a CDT on which the connection is to be completed.  FPC$ACCEPT
; allocates the SCS receive buffer, message buffers, and datagram
; buffers the new connection will need and requests the SCS send 
; process to send an ACCEPT_REQ message to the remote system.  
; Finally, the SYSAP is suspended until the ACCEPT_RSP is received.
;
; Inputs:
;
;	R2			-Addr of listening CDT
;	R3			-Addr of accepting CDT
;	R4			-Addr of PDT
;
;	Listening CDT:
;
;	CDT$W_STATE		-Connect received state
;	CDT$L_SCSMSG		-Addr of message buffer containing CONNECT_REQ
;	CDT$L_PB		-Path Blk of connect request
;	CDT$B_RSTATION		-Remote station addr of connect req
;	CDT$L_PDT		-PDT of connect request
;
;	Accepting CDT:		-All fields zeroed except:
;				 MSGINPUT,DGINPUT,ERRADDR,MINSENT,
;				 INITLREC, and DGREC as specified
;				 by SYSAP;
;				 LCONID, SIZE, TYPE, SUBTYP, WAITQFL
;				 and WAITQBL
;
; Outputs (upon resumption of SYSAP):
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM
;	R1			-Destroyed
;	R2			-Preserved if R0/SS$_INSFMEM; Else destroyed
;	Other registers		-Preserved
;
;	Listening CDT:
;
;	CDT$W_STATE		-LISTEN state
;
;	Accepting CDT:		-All fields initialized
;
;-

;
; CDT adjacency assumptions:
;

ASSUME	CDT$L_PB+4  EQ CDT$B_RSTATION

	.ENABL	LSB

FPC$ACCEPT::

	$CHK_CDTSTATE -			; Verify that accepting CDT
		CLOSED,-		;  state is closed;  if not,
		ERROR=STATE_ERR		;  caller made error
	MOVL	R4,CDT$L_PDT(R3)	; Set PDT addr in accepting CDT
	MOVQ	CDT$L_PB(R2),-		; Copy from listener CDT to accepting:
		CDT$L_PB(R3)		;  PB addr, remote station, l.o.,
	MOVW	CDT$B_RSTATION+4(R2),-	;  remote station, h.o. 2 bytes
		CDT$B_RSTATION+4(R3)	;
	MOVL	CDT$L_PB(R2),R0		; Get path blk addr of connect
					;  request that was saved in listener
	MOVL	PB$L_CDTLST(R0),-	; Link the new CDT to the
		CDT$L_CDTLST(R3)	;  head of the CDT list
	MOVL	R3,PB$L_CDTLST(R0)	;  for this path
	MOVL	R2,R0			; Save listening CDT addr temporarily
	MOVL	CDT$L_SCSMSG(R2),R2	; Get addr of CONNECT_REQ msg
	CLRL	CDT$L_SCSMSG(R0)	; Zero listener scs recv buffer addr
	MOVL	R0,SCS$L_DST_CONID(R2)	; Save listening CDT addr in msg
	PUSHL	R0			;  and save on stack also
	MOVL	R2,CDT$L_SCSMSG(R3)	; Put msg addr in accepting CDT
	BSBW	SCS$COPY_ACCP		; Copy credit, RCONID info from
					;  CONNECT_REQ  to accepting CDT
	MOVAL	SCS$T_SRC_PROC(R2),-	; Set addr of remote proc name
		CDT$L_RPROCNAM(R3)	;
	MOVAL	SCS$T_DST_PROC(R2),-	;  and local proc name in CDT
		CDT$L_LPROCNAM(R3)	;  for later xmit of ACCEPT_REQ
	BSBW	SCS$ALL_ALLBUF2		; Allocate all msg and dg buffers
	POPL	R2			; Retreive listener CDT address
	BLBS	R0,10$			; Branch if got them
	PUSHL	R0			; Else save error status
	BSBW	SCS$DEAL_SCSREC		; Deallocate extra SCS recv buffer
	BRW	CON_MEM_FAIL1		; Clean up accepting CDT (status on stack)

10$:	MOVW	#CDT$C_ACCP_SENT,-	; Move state to accept sent
		CDT$W_STATE(R3)		;
	MOVZWL	#CDT$C_ACCP_PEND,R0	; Set block state to accept pending

SCSSEND:
	BSBW	SCS$REQ_SCSSEND		; Ask to send ACCEPT_REQ
	BRW	SUSP_CONCALL		; Suspend SYSAP connection call

	.DSABL	LSB

	.SBTTL	-	FPC$REJECT,	PROCESS A REJECT CALL

;+
; FPC$REJECT is called directly from the SYSAP.  It requests
; the SCS send process to send a REJECT_REQ message with SYSAP-
; specified reject reason.  FPC$REJECT then suspends the SYSAP 
; until the reject response arrives.
;
; Inputs:
;
;	R0			-Reject reason (l.o. 16 bits)
;	R3			-Addr of CDT (listening CDT)
;	R4			-Addr of PDT
;
;	CDT$L_SCSMSG		-Addr of msg buffer containing CONNECT_REQ
;
; Outputs (upon resumption of SYSAP):
;
; 	R0			-SS$_NORMAL, SS$_ILLCDTST
;	R1,R2			-Destroyed
;	other registers		-Preserved
;
;	CDT$W_STATE(R3)		-Connect rec'd --> listen
;-

	.ENABL	LSB

FPC$REJECT::

	$CHK_CDTSTATE -			; Verify CDT state is 
		CON_REC,-		;  connect received;  if not,
		ERROR=STATE_ERR		;  caller made error
	BSBW	SCS$MAP_VMSSTS		; Map VMS status to SCS
	MOVW	R0,CDT$W_REASON(R3)	; Save reject reason
	MOVW	#CDT$C_REJ_SENT,-	; Move CDT state to reject sent
		CDT$W_STATE(R3)		;
	MOVZWL	#CDT$C_REJ_PEND,R0	; Set block state = reject pending
	BRB	SCSSEND			; Ask to send REJECT_REQ & suspend

	.DSABL	LSB

	.SBTTL	-	FPC$DCONNECT,	PROCESS A DISCONNECT CALL

;+
; FPC$DCONNECT is called by the SYSAP.  It may be called from 
; three states.  Depending upon the state, the following actions
; are taken:
;
;	STATE		ACTIONS			NEW STATE
;
;	CLOSED		No action; return success to the SYSAP,
;			SS$ALRDYCLOSED.
;
;	OPEN		Trade DISCONNECT's with the remote SYSAP.
;			When the trade is done, return success to 
;			the SYSAP.  The state changes seen by the
;			side initiating the DISCONNECT are:
;			OPEN-->DISC_SENT-->DISC_ACK-->CLOSED.
;			The state changes seen by the passive side are:
;			OPEN-->DISC_REC-->DISC_MTCH-->CLOSED.
;			If both sides initiate a DISCONNECT 
;			simultaneously, so that the requests cross
;			in the mail, then each side sees the
;			following state transitions:
;			OPEN-->DISC_SENT-->DISC_MTCH-->CLOSED.
;
;	CON_ACK,	Unilaterally deallocate CDT and associated
;	DISC_ACK	receive buffers.  Complete original
;			outstanding CONNECT/DISCONNECT with abort
;			status, SS$_ABORT.  Return success on the
;			DISCONNECT call.
;
;	CON_REC		Do a REJECT.
;
;	DISC_REC	Send out a DISCONNECT (part of the normal
;			handshake discussed for OPEN.)  The 
;			DISCONNECT request is sent on the lowest
;			priority queue to delay it till all other
;			pending traffic, including block transfers,
;			is done.  A credit message is forced out
;			first in order to make sure the remote
;			knows about all the credits we have to extend.
;
;	Other states	All other states represent the window 
;			between sending an SCS request and getting 
;			the response.  During this window the CDT
;			cannot be unilaterally destroyed and so
;			error status SS$_ILLCDTST is returned to
;			the SYSAP.
;
;	Inputs:
;
;		R0			-Disconnect reason
;		R3			-Addr of CDT being disconnected
;		R4			-Addr of PDT
;
; 	Outputs:
;
;		R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;		R1,R2,R3		-Destroyed
;		Other registers		-Preserved
;-

	.ENABL	LSB

FPC$DCONNECT::

	MOVL	CDT$L_PB(R3),R1		; Get PB addr
	CMPW	PB$W_STATE(R1),-	; Is path in either
		#PB$C_VC_FAIL		;  virtual circuit fail or
	BNEQ	2$			; 
	BRW	SCS$DISC_VCFAIL		;

2$:	CMPW	PB$W_STATE(R1),-	;  power fail state?  
		#PB$C_PWR_FAIL		;
	BNEQ	3$			;
	BRW	ERR$DISC_PWFAIL		; If so, call different DISCONNECT

3$:	$DISPATCH -
		CDT$W_STATE(R3),-		; Dispatch on CDT state:
		<-				;  (CLOSED/LISTEN handled by SCSLOA)
		<CDT$C_OPEN,	DISC_OPEN>,-	;  OPEN,
		<CDT$C_CON_ACK,	DISC_CON_ACK>,-	;  CON_ACK,
		<CDT$C_DISC_ACK,DISC_ILLSTATE>,-;  DISC_ACK,
		<CDT$C_CON_REC,	FPC$REJECT>,-	;  CON_REC,
		<CDT$C_DISC_REC,DISC_DISC_REC>,-;  DISC_REC,
		<CDT$C_CON_SENT,DISC_ILLSTATE>,-;  CON_SENT,
		<CDT$C_DISC_SENT,DISC_ILLSTATE>,- ;  DISC_SENT,
		<CDT$C_REJ_SENT,DISC_ILLSTATE>,-;  REJ_SENT,
		<CDT$C_ACCP_SENT,DISC_ILLSTATE>,- ;  ACCP_SENT
		<CDT$C_DISC_MTCH,DISC_ILLSTATE>,- ;  Matching DISC sent
		 >				  ;  (CDT$C_VC_FAIL went to SCS$DISC_x

	BUGCHECK  CIPORT,NONFATAL	; If none of the above
					;  states, system error,
					;  possibly recoverable
	MOVZWL	#SS$_NORMAL,R0		; If bugcheck nonfatal, return
	RSB				;  success to SYSAP

;
; Connection can't be closed right now without violating SCS protocol.
; Therefore close unilaterally and crash VC.
;

DISC_ILLSTATE:

	PUSHL	CDT$L_PB(R3)		; Save PB addr
	BSBB	DISC_CON_ACK		; Cleanup CDT and pending 
					;  CONNECT/DISCONNECT
	POPL	R1			; Retreive PB address 
	BSBW	ERR$CRASHVC		; Initiate VC crash
	MOVZWL	#SS$_NORMAL,R0		; Set status to return to caller
					;  on latest DISCONNECT call
	RSB				; Return error to SYSAP

;
; CDT has a CONNECT or DISCONNECT request already pending.  Unilaterally
; clean up the CDT.  Complete pending request with abort status. 
; Complete this DISCONNECT with success.
;

DISC_CON_ACK:

	MOVQ	R4,-(SP)		; Save R4, R5
	MOVL	CDT$L_FR5(R3),R5	; Restore context from pending
	PUSHL	CDT$L_FPC(R3)		;  connx mgmt call
	BSBW	SCS$DEAL_ALLBUF		; Clean up all receive buffers
	JSB	G^SCS$DEALL_CDT		; Deallocate CDT (close status)
	MOVZWL	#SS$_ABORT,R0		; Set status to abort
	JSB	@(SP)+			; Restore pending call thread
	MOVQ	(SP)+,R4		; Restore R4, R5
	MOVZWL	#SS$_NORMAL,R0		; Set DISCONNECT status to ok
	RSB				; Return from DISCONNECT

;
; SYSAP has received an unsolicited DISCONNECT request from the
; remote SYSAP and now wishes to issue the matching DISCONNECT.
;

DISC_DISC_REC:

	BSBW	SCS$MAP_VMSSTS		; Convert reason from VMS to SCS
	MOVW	R0,CDT$W_REASON(R3)	; Save DISCONNECT reason
	MOVW	#CDT$C_DISC_MTCH,-	; Move CDT state to
		CDT$W_STATE(R3)		;  matching DISCONNECT sent
	MOVZWL	#CDT$C_DISC_PEND,R0	; Set block state to send DISCONNECT
10$:	BSBW	SCS$REQ_SCSSEND		; Send out the DISCONNECT
20$:	BRW	SUSP_CONCALL		; Suspend SYSAP till done

;
; Connection is OPEN.  Force sending of any unextended credits (may
; send 0 credits).  Send out a DISCONNECT on the lowest priority queue.
; Move CDT state from OPEN to DISC_SENT.
;

DISC_OPEN:

	BSBW	SCS$MAP_VMSSTS		; Convert status to SCS
	MOVW	R0,CDT$W_REASON(R3)	; Save DISCONNECT reason
	MOVW	#CDT$C_DISC_SENT,-	; Set CDT state to 
		CDT$W_STATE(R3)		;  show DISCONNECT sent
	MOVW	#CDT$C_DCR_PEND,R0	; Block state will be disconnect
					;  + credit pending
	BRB	10$			; Request SCS send and suspend 
					;  SYSAP till DISCONNECT complete

	.DSABL	LSB

	.SBTTL	SEQUENCED MESSAGE CALLS
	.SBTTL	-	FPC$ALLOCMSG,	ALLOCATE A MESSAGE BUFFER

;+
; FPC$ALLOCMSG checks if there is at least one send credit.  If not, the
; SYSAP is suspended behind other waiting SYSAP's until there is.  The
; message buffer is allocated from nonpaged pool.  If insufficient pool
; is available, then the SYSAP is suspended until pool is available.
; The destination connection ID is then copied to the SCS header
; at this time so that the message can be sent harmlessly even if
; a power failure should occur.  (It will be discarded at the receiving
; end upon detection of connect ID sequence number mismatch.)  Finally,
; the address of the start of the application data within the buffer is 
; computed and returned to the SYSAP.
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1			-Destroyed
;	R2			-Addr of message buffer, if status=success
;	Other registers		-Preserved
;
;	CDRP$L_MSG_BUF		-Addr of message buffer, if status=success
;-

	.ENABL	LSB

FPC$ALLOCMSG::

	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr
	$CHK_CDTSTATE	-		; Verify connection state
		OPEN,-			;  is open.
		ERROR=STATE_ERR,-	; Else report error to SYSAP
		CDT=R1			;
	POPL	CDRP$L_SAVD_RTN(R5)	; Save 1st level return
	TSTW	CDT$W_SEND(R1)		; Got any credit for send?
	BGTRU	10$			; Branch if so
	INCW	CDT$W_QCR_CNT(R1)	; Step count of # credit waits
	$SUSP_SCS	-		; Else suspend SCS routine
		@CDT$L_CRWAITQBL(R1)	;  on credit wait queue
	
10$:	BSBW	INT$ALLOC_MSG		; Allocate a message buffer
	BLBS	R0,20$			; Branch if got it
	$SUSP_SCS	-		; Else suspend this routine
		@PDT$L_WAITQBL(R4)	;  on pool wait queue
	BRB	10$			; Try to allocate now
	
20$:	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr again
	MOVL	CDT$L_RCONID(R1),-	; Set destination connect
		SCS$L_DST_CONID(R2)	;  ID in SCS header
	MOVL	R2,CDRP$L_MSG_BUF(R5)	;  data and save in CDRP
	BRB	50$			; Join common exit code

	.SBTTL	-	FPC$RCHMSGBUF,	RECYCLE MESSAGE BUFFER
	.SBTTL	-			AT HIGH PRIORITY
	.SBTTL	-	FPC$RCLMSGBUF,	RECYCLE MESSAGE BUFFER
	.SBTTL	-			AT LOW PRIORITY

;+
; FPC$RCxMSGBUF checks if there is at least one send credit.  If
; not, the SYSAP is suspended until there is.  FPC$RCxMSGBUF then
; decrements the send credit.  The wait, if required, places the 
; SYSAP CDRP at the end of the wait queue for low priority and at
; the head of the queue for high priority.  The address of the
; buffer being recycled is returned in both R2 and CDRP$L_MSG_BUF.
; The remote connection ID s set in the SCS header so that the
; message can be sent harmlessly even if a power failure should occur.
; (It will be discarded by the receiving SCS.)
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT
;	CDRP$L_MSG_BUF		-Addr of msg buffer
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R2			-Addr of message buffer
;	R1			-Destroyed
;	Other registers		-Preserved
;	CDRP$L_MSG_BUF(R5)	-Addr of message buffer
;-


FPC$RCHMSGBUF::

	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr
	MOVAL	CDT$L_CRWAITQFL(R1),R0	; Get addr of head of wait queue
	BRB	30$			; Join common processing

FPC$RCLMSGBUF::

	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr
	MOVL	CDT$L_CRWAITQBL(R1),R0	; Get addr of end of wait queue
	
30$:	$CHK_CDTSTATE	-		; Verify connection state
		OPEN,-			;  is open
		ERROR=STATE_ERR,-		; Else report error to SYSAP
		CDT=R1			;
	POPL	CDRP$L_SAVD_RTN(R5)	; Copy return to SYSAP from stack
					;  to CDRP
	TSTW	CDT$W_SEND(R1)		; Got a send credit?
	BGTRU	40$			; Branch if so
	MOVL	R0,R1			; Get queue hdr in less volatile
					;  register
	$SUSP_SCS (R1)			; Else suspend this routine
	MOVL	CDRP$L_CDT(R5),R1	; Retreive CDT addr

40$:	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get msg addr in register
	MOVL	CDT$L_RCONID(R1),-	; Set remote CONID in SCS header
		SCS$L_DST_CONID(R2)
50$:	DECW	CDT$W_SEND(R1)		; Mark one credit used
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$DEALLOMSG,	DEALLOCATE A MESSAGE BUFFER
	.SBTTL	-	FPC$DEALRGMSG,	DEALLOCATE A MESSAGE BUFFER,
	.SBTTL	-			ARGUMENTS PASSED IN REGISTERS

;+
; FPC$DEALLOMSG resets the message address specified by the caller to
; the top of the message buffer and compares the current number of 
; receive message buffers with the initial count specified at the 
; time of the connect.  If the current receive count is not less than
; the initial, then the message buffer is deallocated to nonpaged
; pool.  If the current receive count is less than the initial,
; then the buffer is added to the free message queue and the pending
; receive count is incremented.  If the receive count was also less
; than the minimum required by the remote SYSAP plus the flow control
; cushion (SCS$GW_FLOWCUSH), then the CDT is queued for sending a
; CREDIT message to the remote.
;
; Entry FPC$DEALRGMSG is called with the same arguments as DEALLOMSG,
; but in registers instead of the CDRP.
;
; Inputs:
;
;	R2			-Addr of message buffer (FPC$DEALRGMSG)
;	R3			-Addr of CDT (FPC$DEALRGMSG)
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT (FPC$DEALLOMSG)
;	CDRP$L_MSG_BUF		-Addr of msg buffer (FPC$DEALLOMSG)
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;	CDRP$L_MSG_BUF(R5)	-0 (FPC$DEALLOMSG only)
;-

	.ENABL	LSB

FPC$DEALLOMSG::

	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get addr of message buffer
	MOVL	CDRP$L_CDT(R5),R3	; Get addr of CDT
	BSBB	FPC$DEALRGMSG		; Call routine to deallocate
	POPL	R3			; Restore caller's R3
	CLRL	CDRP$L_MSG_BUF(R5)	; Zero msg addr in CDRP
	RSB				; Return
	
FPC$DEALRGMSG::				; Entry for appl data pointer in R2
					;  and CDT addr in R3
	ADDW3	CDT$W_REC(R3),-		; Compute total receive credits now
		CDT$W_PENDREC(R3),R0	;  = extended + not yet extended
	CMPW	R0,CDT$W_INITLREC(R3)	; Total receive less than initial?
	BLSSU	10$			; Branch if so
	BSBW	INT$DEAL_MSG		; Deallocate message buffer
					;  to nonpaged pool
	CLRL	R2			;***Debug code
	RSB				; Return to SYSAP

10$:	BSBW	INT$INS_MFREEQ		; Insert buffer on free queue
	INCW	CDT$W_PENDREC(R3)	; Reflect insert in credit
	ADDW3	G^SCS$GW_FLOWCUSH,-	; Compute cushion + minimum #
		CDT$W_MINREC(R3),R0	;  send credits req'd by remote
	CMPW	CDT$W_REC(R3),R0	; Is current # recv buffers less
					;  cushion + minimum?
	BGTRU	30$			; Branch if not
	MOVZWL	#CDT$C_CR_PEND,R0	; Get credit block state code
	$DISPATCH -			; 
		CDT$W_STATE(R3),-	; If connection is in any of the
		<-			;  states that indicate
		<CDT$C_DISC_ACK,30$>,-	;  that the local SYSAP has
		<CDT$C_DISC_SENT,30$>,-	;  issued a DISCONNECT request,
		<CDT$C_DISC_MTCH,30$>,-	;  then don't ask to send a credit
		>			;  request -- if we are already 
					;  queued to send the final credit
					;  that preceeds the DISCONNECT, then
					;  the latest credit will be included,
					;  otherwise it won't

20$:	BSBW	SCS$REQ_SCSSEND		; Request xmit of credit message

30$:	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$SENDMSG,	SEND A SEQUENCED MESSAGE

;+
; The SCS header of the specified message buffer is filled in.
; If the response ID is 0, then the message is queued for transmission
; with RETFLAG = 1(TRUE) thus channeling the sent buffer to the response
; queue for reclaim.  If the response ID is non-zero, then a
; responsed is expected from the remote SYSAP and the messag is sent
; with RETFLAG = 0(FALSE).  RETFLAG = FALSE channels the sent buffer to
; the message free queue in anticipation of the response.  In this
; case the receive credit is also incremented to account for the
; buffer being added to the free queue.  All messages are sent
; on the high priority queue.
;
; Inputs:
;
;	R1			-# bytes application data (FPC$SENDCNTMSG)
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT(R5)		-Addr of CDT
;	CDRP$L_MSG_BUF(R5)	-Addr of message 
;	CDRP$L_RSPID(R5)	-RSPID (to set RETFLG)
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1,R2			-Destroyed
;	Other registers		-Preserved
;
;	CDRP$L_MSG_BUF(R5)	-Zeroed to show msg buffer gone
;-

	.ENABL	LSB

FPC$SENDMSG::

	MOVZWL	G^SCS$GW_MAXMSG,R1	; Set for default

FPC$SNDCNTMSG::

	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_CDT(R5),R3	; Get CDT addr in R3
	$CHK_CDTSTATE	-		; Verify connection is
		OPEN,-			;  open
		ERROR=STATE_ERR_R3,-	; Else report error to SYSAP
		CDT=R3			;
	CLRL	R0			; Assume RETFLAG will be false
					;  and we will put msg on free queue
	TSTL	CDRP$L_RSPID(R5)	; Is there a rspid?
	BNEQ	10$			; Branch if there is 
	ADDW3	CDT$W_REC(R3),-		; Else compute total receive credits
		CDT$W_PENDREC(R3),R2	;  queued now 
	CMPW	R2,CDT$W_INITLREC(R3)	; Current recv less than initial?
	BLSSU	10$			; Branch if so
	MOVL	#SYSAP$C_DISPRET,R0	; Else set RETFLAG true
	BRB	20$			; Join common processing

10$:	INCW	CDT$W_PENDREC(R3)	; Step pending receive to reflect
					;  msg port will put on free queue


20$:	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get message buffer addr
	ADDW3	#SCS$C_OVHD,R1,-	; Set SCS length
		SCS$W_LENGTH(R2)	;
	MOVW	#SCS$C_APPL_MSG,-	; Set SCS type to application
		SCS$W_MTYPE(R2)		;  message
	MOVW	CDT$W_PENDREC(R3),-	; Extend any pending receive
		SCS$W_CREDIT(R2)	;  credits to the remote
	ADDW	CDT$W_PENDREC(R3),-	; Move pending receives to
		CDT$W_REC(R3)		;  actual receives (real send
					;  credits extended)
	CLRW	CDT$W_PENDREC(R3)	; No more pending credit
	MOVL	CDT$L_LCONID(R3),-	; Put local connection ID
		SCS$L_SRC_CONID(R2)	;  into header
	MOVL	CDT$L_PB(R3),R1		; Get address of PB in R1
	INCL	CDT$L_MSGSENT(R3)	; Step count of msgs sent
	BSBW	INT$SNDMSG		; Send the message with RETFLAG in R0
	POPL	R3			; Restore SYSAP's R3
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark msg as no longer held by CDRP
	TSTL	CDRP$L_RSPID(R5)	; Was RETFLAG true?
	BEQL	FPC_SUCCESS		; Branch if yes
	$SUSP_FP			; Save fork process' context

	.DSABL	LSB

	.SBTTL	DATAGRAM SERVICE CALLS
	.SBTTL	-	FPC$ALLOCDG,	ALLOCATE A DATAGRAM BUFFER

;+
; FPC$ALLOCDG allocates one datagram buffer from nonpaged pool.  If
; none is available, error status is returned to the caller.  Otherwise,
; the address of space for application data within the buffer
; is computed and returned to the caller.
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;
; Outputs:
;	
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM
;	R2			-Addr of dg, start of application data
;	CDRP$L_MSG_BUF		-Copy of R2
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$ALLOCDG::

	BSBW	INT$ALLOC_DG		; Allocate 1 dg buffer from pool
	BLBC	R0,DG_ALC_FAIL		; Branch if failed
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Save addr in CDRP

FPC_SUCCESS:

	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return

DG_ALC_FAIL:

	MOVZWL	#SS$_INSFMEM,R0		; Set status to failure
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	FPC$DEALLOCDG,	DEALLOCATE A DATAGRAM BUFFER
	.SBTTL	-			TO NONPAGED POOL

;+
; FPC$DEALLOCDG simply converts the datagram aaddress to the address
; of the start of the buffer containing the datagram and calls
; COM$DRVDEALMEM.
;
; Inputs:
;
;	R2			-Addr of datagram
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	R2			-0
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$DEALLOCDG::

	BSBW	INT$DEAL_DG		; Deallocate buffer
	CLRL	R2			; Mark dg addr as gone
	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$QUEUEDG,	QUEUE A SYSAP SUPPLIED BUFFER
	.SBTTL	-			TO THE DATAGRAM FREE QUEUE

;+
; FPC$QUEUE allows a SYSAP to supply the port with a buffer to insert
; on the datagram free queue.  The SYSAP must correctly set the type
; and size field before calling this routine.  The datagram receive
; count in the SYSAP's CDT is incremented.
;
; INPUTS:
;
;	R2			-Addr of start of buffer (NOT appl data)
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;	CDT$W_DGREC(R3)		-Current DG receive count
;
; OUTPUTS:
;
;	R0			-Status:  SS$_NORMAL
;	R1			-Preserved
;	R2			-Zeroed
;	CDT$W_DGREC(R3)		-Incremented
;-

FPC$QUEUEDG::

	BSBW	INT$INS_DFREEQX		; Insert buffer on port queue
	INCW	CDT$W_DGREC(R3)		; Step SYSAP's receive count
	BRB	Q_SUCCESS		; Finish up

	.SBTTL	-	FPC$QUEUEMDGS,	ALLOCATE DG'S AND QUEUE FOR
	.SBTTL	-			RECEIVES OR
	.SBTTL	-			DEQUEUE DG'S AND RETURN TO
	.SBTTL	-			NONPAGED POOL

;+
; FPC$QUEUEMDGS is used by SYSAP's to alter the number of datagram buffers
; they have queued for receives.  The datagram count is positive if
; datagrams are to be allocated from pool and queued for receives.  The
; count agrument is negative if datagrams are to be removed from the queue
; and returned to nonpaged pool.
;
; If datagrams are being added, then for each one allocated and queued,
; the datagram receive count in the SYSAP's CDT is incremented.  If there
; is insufficient pool for all to be allocated, then the number actually
; queued is returned to the SYSAP with a warning status.
;
; If datagrams are being withdrawn from the queue, then for each
; one dequeued and returned to pool, the datagram receive count in the
; SYSAP's CDT is decremented. If the datagram receive count reaches 
; 0 before all that the SYSAP requested have been dequeued, then the
; number actually dequeued is returned to the caller with warning
; status.
;
; Inputs:
;
; 	R1			-# of dg's to add (+) or
;				 to withdraw (-)
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;	CDT$W_DGREC(R3)		-Current dg receive count
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_DGQINCOMP
;				 (Datagram queuing incomplete)
;	R1			-# actually added (+) or withdrawn (-)
;	R2			-Destroyed
;	Other registers		-Preserved
;	CDT$W_DGREC(R3)		-Updated
;-

	.ENABL	LSB

FPC$QUEUEMDGS::

	CLRL	-(SP)			; Set running dg count = 0
	TSTL	R1			; Check dg count requested
	BEQL	Q_SUCCESS		; Branch if nothing to do
	BLSS	DQUEUE_DG		; Branch if withdrawing

QUEUE_DG:

	PUSHL	R1			; Save count argument
	BSBW	INT$ALLOC_DG		; Allocate a dg buffer
	POPL	R1			; Restore argument
	BLBC	R0,Q_INCOMPLETE		; Branch if allocate failed
	BSBW	INT$INS_DFREEQ		; Else insert buffer on port queue
	INCW	CDT$W_DGREC(R3)		; Step SYSAP's receive count
	AOBLSS	R1,(SP),QUEUE_DG	; Step running tally and branch 
					;  if less than requested
	POPL	R1			; Retreive total tally from stack

Q_SUCCESS:

	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return to SYSAP

DQUEUE_DG:

	MNEGL	R1,R1			; Trun request count positive

20$:	TSTW	CDT$W_DGREC(R3)		; SYSAP have more dg's queued?
	BLEQ	DQ_INCOMPLETE		; Branch if not
	BSBW	INT$DFQ2POOL		; Remove a dg from free queue
	BVS	Q_INCOMPLETE		; Branch if none
	DECW	CDT$W_DGREC(R3)		; Decrement SYSAP's recv count
	AOBLSS	R1,(SP),20$		; Step running tally, branch
					;  if more to do
	MNEGL	(SP)+,R1		; Retreive total tally and negate
	BRB	Q_SUCCESS		; Join common success exit

DQ_INCOMPLETE:

	MNEGL	(SP),(SP)		; Turn tally into negative #

Q_INCOMPLETE:

	POPL	R1			; Retreive tally from stack
	MOVZWL	#SS$_DGQINCOMP,R0	; Set status to error
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	FPC$SENDDG,	SEND DATAGRAM
	.SBTTL	-	FPC$SENDRGDG,	SEND DG, NO CDRP

;+
; FPC$SENDDG formats and sends the caller-specified datagram.  The
; SYSAP can specify via the flags input argument what happens to the
; buffer once it has been sent:
;
;	flags	= SYSAP$C_DISPQ implies that the buffer is placed
;		  on the datagram free queue for a future receive.
;		  The SYSAP's datagram receive count is incremented
;		  in the CDT in anticipation of the buffer going on
;		  the free queue.
;
;		= SYSAP$C_DISPRET says that the SYSAP wants the sent
;		  buffer back, so RETFLAG is set to 1 (true) and
;		  DISPOSAL is 1.
;		
;		= SYSAP$C_DISPPO says that the SYSAP wants SCS to 
;		  put the sent buffer in nonpaged pool, so RETFLAG
;		  is set to 1 (true) and DISPOSAL = 0.
;
; This data is all expressed in table DG_SENT_FLGS.
;
; Inputs:
;
;	R0			-Input flag described above
;	R1			-Length of application data in dg
;	R2			-Addr of dg, application data (FPC$SENDRGDG)
;	R3			-Addr of CDT (FPC$SENDRGDG)
;	R4			-Addr of PDT
;	R5			-Addr of CDRP (FPC$SENDDG)
;	CDRP$L_CDT		-Addr of CDT (FPC$SENDDG)
;	CDRP$L_MSG_BUF		-Addr of datagram
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R2			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$SENDRGDG::

	PUSHL	R3			; Save caller's R3
	$CHK_CDTSTATE	-		; Verify that connection state
		OPEN,-			;  is open
		ERROR=STATE_ERR_R3,-	;
		CDT=R3			;
	BRB	10$			; Join common code

FPC$SENDDG::

	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_CDT(R5),R3	; Get addr of CDT
	$CHK_CDTSTATE	-		; Verify that connection state
		OPEN,-			;  is open
		ERROR=STATE_ERR_R3,-	; Else report error to SYSAP
		CDT=R3			;
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get addr of dg buff, appl data
	CLRL	CDRP$L_MSG_BUF(R5)	; Show dg is gone

10$:	TSTB	R0			; Dg going on to free queue?
	BNEQ	20$			; Branch if not
	INCW	CDT$W_DGREC(R3)		; Else step recv count in anticipation
	
20$:	ADDW3	#SCS$C_OVHD,R1,-	; Dg length = SCS header size +
		SCS$W_LENGTH(R2)	;   application data
	MOVZWL	#SCS$C_APPL_DG,-	; Set SCS type to application
		SCS$W_MTYPE(R2)		;  datagram
	MOVL	CDT$L_RCONID(R3),-	; Set destination connection
		SCS$L_DST_CONID(R2)	;  ID in SCS header
	MOVL	CDT$L_LCONID(R3),-	; Put local connection ID
		SCS$L_SRC_CONID(R2)	;  into header
	MOVL	CDT$L_PB(R3),R1		; Get address of PB in R1
	INCL	CDT$L_DGSENT(R3)	; Step count of application dgs sent
	BSBW	INT$SNDDG		; Send datagram
	POPL	R3			; Restore caller's R3
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	BLOCK TRANSFER CALLS
	.SBTTL	-	FPC$MAP,	MAP A BUFFER
	.SBTTL	-	FPC$MAPBYPASS,	MAP A BUFFER W/
	.SBTTL	-			NO ACCESS CHECKING
	.SBTTL	-	FPC$MAPIRP,	MAP A BUFFER W/
	.SBTTL	-			ARGUMENTS IN IRP
	.SBTTL	-	FPC$MAPIRPBYP,	MAP A BUFFER W/
	.SBTTL	-			ARGUMENTS IN IRP AND NO
	.SBTTL	-			ACCESS CHECKING

;+
; Each of the entries converts its inputs to a set of common inputs:
;
;	R1			-Addr of 3 longwd array containing
;				 SVAPTE, BOFF, and BCNT (size) of
;				 buffer to map.
;	R2			-Buffer descriptor flags consisting of 
;				 valid (bit 15), access mode = 0/1/2/3
;				 (bits 13,14), and access checking = 0/1
;				 for disabled/enabled (bit 12).
;
; Common map processing then consists of allocating a buffer descriptor
; from the pool (common to all CI ports), filling in the buffer descriptor
; and then filling in the SYSAP's buffer handle.
;
; If no buffer descriptor is available, then the common inputs are
; saved temporarily in the buffer handle provided by the SYSAP.  The
; SCS MAP routine is suspended until resumed by the deallocation of a buffer 
; descriptor.  Upon resumption, all context is retreived including R1
; and R2 and a buffer descriptor allocated.
;
; Inputs to all MAP calls:
;
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	CDRP$L_CDT		-Addr of CDT
;	CDRP$L_LBUFH_AD		-Addr of SYSAP's buffer handle
;
;	CDT$L_RCONID		-Remote connection ID
;
; Inputs to MAP, MAPBYPASS:
;
;	R1			-Addr of SVAPTE/BOFF/BCNT array
;	R2			-Access mode = 0/1/2/3 for kernel/
;				 exec/super/user
;
; Inputs to MAPIRP, MAPIRPBYP:
;
;	CDRP$L_SVAPTE(R5)	= Addr of SVAPTE in IRP
;	CDRP$B_RMOD(R5)		= Addr of access mode
;
; Outputs for all map routines:
;
;	@CDRP$L_LBUFH_AD(R5)	-Filled in with byte offset of buffer,
;				 buffer name, local connection ID
;-

	.ENABL	LSB

FPC$MAPIRPBYP::

	MOVAL	CDRP$L_SVAPTE(R5),R1	; Get addr in IRP of SVAPTE
	MOVZBL	CDRP$B_RMOD(R5),R2	;  and access mode

FPC$MAPBYPASS::

	ASSUME	CIBD$V_V EQ 15

	BISW	#4,R2			; Set valid bit to left of access mode
	ASHL	#CIBD$V_ACMOD,R2,R2	; Position valid, access mode
	BRB	MAP_COMMON		; Join common code

FPC$MAPIRP::

	BITW	#<IRP$M_PAGIO!IRP$M_SWAPIO>,-
		CDRP$W_STS(R5)		; Is this page/swap I/O?
	BNEQ	FPC$MAPIRPBYP		; Branch if so to bypass 
	MOVAL	CDRP$L_SVAPTE(R5),R1	; Get addr in IRP of SVAPTE
	MOVZBL	CDRP$B_RMOD(R5),R2	;  and access mode

FPC$MAP::

	ASHL	#CIBD$V_ACMOD,R2,R2	; Position access mode
	BISW	#CIBD$M_V!CIBD$M_AC,R2	; Set valid and access check

MAP_COMMON:

	POPL	CDRP$L_SAVD_RTN(R5)	; Pop return from stack to CDRP
	
ALLOC_BD:

	PUSHL	R3			; Save SYSAP register
	MOVL	G^SCS$GL_BDT,R0		; Get addr of buffer desc table
	MOVL	CIBDT$L_FREEBD(R0),R3	; Get addr of 1st free desc
	BEQL	WAIT_BD			; Branch if none
	MOVL	CIBD$L_LINK(R3),-	; Remove BD from linked 
		CIBDT$L_FREEBD(R0)	;  List

	ASSUME	CDRP$L_SVAPTE+4 EQ CDRP$W_BOFF
	ASSUME	CDRP$W_BOFF+2   EQ CDRP$L_BCNT

					; Fill in buffer descriptor:
	MOVL	(R1)+,CIBD$L_SVAPTE(R3)	;  Addr of PTE mapping buff
	ADDW3	R2,(R1)+,CIBD$W_FLAGS(R3) ;  Byte offset, access, valid
	MOVL	(R1),CIBD$L_BLEN(R3)	;  Size of buffer
	MOVL	R5,CIBD$L_CDRP(R3)	;  CDRP

	SUBL3	G^SCS$GL_BDT,R3,R0	; Compute index
	ASHL	#-4,R0,R0		;  to buffer descriptor
	INSV	CIBD$W_KEY(R3),#16,#16,R0  ; Put seq # in h.o. bits
					   ;  to make buffer name
	MOVL	CDRP$L_LBUFH_AD(R5),R3	; Get buffer handle to fill in

	ASSUME	CIBHAN$L_BOFF+4 EQ CIBHAN$L_BNAME
	ASSUME	CIBHAN$L_BNAME+4 EQ CIBHAN$L_RCONID

	CLRL	(R3)+			; Clear transfer offset
	MOVL	R0,(R3)+		; Copy buffer name
	MOVL	CDRP$L_CDT(R5),R0	; Get CDT addr
	MOVL	CDT$L_RCONID(R0),(R3)	; Put CONID into handle
	ADDL	(R1),CDT$L_BYTMAPD(R0)	; Incr count of total bytes mapped
					;  by the # bytes just mapped
	POPL	R3			; Restore SYSAP's R3
	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to SYSAP

WAIT_BD:

	PUSHL	R1			; Save SVAPTE arg temporarily
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get buffer handle addr
	POPL	CIBHAN$L_BOFF(R1)	; Copy SVAPTE and access mode to
	MOVL	R2,CIBHAN$L_RCONID(R1)	;  handle for duration of suspend
	CLRL	CIBHAN$L_BNAME(R1)	; Zero buffer name to show
					;  that none is allocated
	POPL	R3			; Restore SYSAP's R3
	MOVL	R0,R1			; Copy BDT addr to register not
					;  used by $SUSP_SCS macro
	MOVL	CDRP$L_CDT(R5),R0	; Get addr of CDT
	INCW	CDT$W_QBDT_CNT(R0)	; Incr count of # times suspended
					;  waiting for BDT
	$SUSP_SCS	-		; Suspend this routine
		@CIBDT$L_WAITBL(R1)	;  on availability of BD
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get addr of thread's buffer handle
	MOVL	CIBHAN$L_RCONID(R1),R2	; Retreive access mode and SVAPTE
	MOVL	CIBHAN$L_BOFF(R1),R1	;  saved over the suspend
	BRW	ALLOC_BD		; Try to allocate now

	.DSABL	LSB

	.SBTTL	-	FPC$REQDATA,	BLOCK XFER READ
	.SBTTL	-	FPC$SENDDATA,	BLOCK XFER WRITE

;+
; These two calls are the same except for the direction of
; the block transfer.  FPC$REQDATA runs as follows:
;
; 1.	Using the CDT address specified in the SYSAP's remote buffer
;	handle, fill in the allcoated message buffer with the REQDAT
;	opcode, remote station, and all frills set to 0. (512 byte
;	data pkt, response bit off, path select auto.)  The response
;	bit = 0 will cause the REQDAT buffer to be put on the free
;	queue once  it has been sent where it will wait to receive the
;	DATRET/DATREC notification of transfer completion.
;
; 2.	Fill in the sender buffer name and byte offset with info
;	from the remote buffer handle.  Note that the net buffer offset
;	is the sum of the offset in the buffer handle and the offset
;	specified by the SYSAP in the CDRP.  The buffer handle offset
;	is normally 0.  for third party transfers, it may be transformed
;	by the SYSAP acting as the manager of the third party transaction
;	in the case where that SYSAP discovers that it must break a
;	transfer into transfers from different sources.  The CDRP byte
;	offset is intended for use by a SYSAP doing segmented transfers.
;
; 3.	Fill in the receiver buffer name and byte offset with info
;	from the local buffer handle.
;
; 4.	Set the XCT_ID to the local CONID (from the local buffer handle)
;	followed by the RSPID from the CDRP.  Set the XCT_LEN to the
;	value specified in the CDRP.
;
; 5.	Map the RSPID to the CDRP, save the SYSAP's context in the CDRP;
;	send the REQDAT message, and return to the caller's caller.
;	The SYSAP remains suspended until the transfer completes at which
;	time the SYSAP is resumed at the instruction following the call
;	to request data.
;
; FPC$SENDDATA has its own version of steps 1-3.  In this case the
; send buffer information is in the local buffer handle and the receive 
; buffer information is in the remote buffer handle.
;
; Inputs:
;
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	CDRP$L_RSPID		-RSPID to use to correlate tramsfer
;				 completion with initiation thread
;	CDRP$L_MSG_BUF		-Message buffer to use for xfer command
;	CDRP$L_XCT_LEN		-# bytes to xfer
;	CDRP$L_LBUFH_AD		-Addr of local buffer handle
;	CDRP$L_LBOFF		-Local byte offset for segmentation
;	CDRP$L_RBUFH_AD		-Addr of remote buffer handle
;	CDRP$L_RBOFF		-Remote byte offset for segmentation
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLPORTOPR
;	R1, R2			-Destroyed
;	R3			-Preserved
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	RSPID, msg buffer	-Deallocated
;
;	CDRP$L_MSG_BUF(R5)	;Zeroed to show msg buffer gone
;-

	.ENABL	LSB

FPC$REQDATA::

	PUSHL	R3			; Save SYSAP's R3
	MOVL	CDRP$L_RBUFH_AD(R5),R1	; Get addr of remote buffer handle
	MOVZWL	CIBHAN$L_RCONID(R1),R3	; COmpute addr of CDT
	MOVL	G^SCS$GL_CDL,R0		;  specified by local 
	MOVL	(R0)[R3],R3		;  buffer handle
	INCL	CDT$L_REQDATS(R3)	; Incr number of request datas issued
	ADDL	CDRP$L_XCT_LEN(R5),-	; Step count of # bytes xferred via
		CDT$L_BYTREQD(R3)	;  all request datas
	MOVL	CDRP$L_RBUFH_AD(R5),R1	; Get addr of remote buffer handle
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Set pointer to SCS area
	MOVL	CIBHAN$L_BNAME(R1),-	; Set send buffer name
		SCS$L_SND_NAME(R2)	;  to remote
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set send byte offset to
		CDRP$L_RBOFF(R5),-	;  xfer offset +
		SCS$L_SND_BOFF(R2)	;  segmentation
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get local buffer handle
	MOVL	CIBHAN$L_BNAME(R1),-	; Set receive buffer name
		SCS$L_REC_NAME(R2)	;  to local
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set receive byte offset to
		CDRP$L_LBOFF(R5),-	;  xfer offset
		SCS$L_REC_BOFF(R2)	;  + segmentation
	MOVAB	W^INT$REQDAT,R0		; Addr of PPD action routine
	BRB	COMMON_XFER		; Join common code

FPC$SENDDATA::

	PUSHL	R3			; Save SYSAP's R3
	MOVL	CDRP$L_RBUFH_AD(R5),R1	; Get addr of remote buffer handle
	MOVZWL	CIBHAN$L_RCONID(R1),R3	; COmpute addr of CDT
	MOVL	G^SCS$GL_CDL,R0		;  specified by local 
	MOVL	(R0)[R3],R3		;  buffer handle
	INCL	CDT$L_SNDDATS(R3)	; Incr total # send datas issued
	ADDL	CDRP$L_XCT_LEN(R5),-	; Step count of total bytes xferred via
		CDT$L_BYTSENT(R3)	;  send datas
	MOVL	CDRP$L_RBUFH_AD(R5),R1	; Get addr of remote buffer handle
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get base of buffer
	MOVL	CIBHAN$L_BNAME(R1),-	; Set receive buffer name
		SCS$L_REC_NAME(R2)	;  to remote
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set receive byte offset to
		CDRP$L_RBOFF(R5),-	;  xfer offset +
		SCS$L_REC_BOFF(R2)	;  segmentation
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get local buffer handle
	MOVL	CIBHAN$L_BNAME(R1),-	; Set send buffer name 
		SCS$L_SND_NAME(R2)	;  to local
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set send byte offset to
		CDRP$L_LBOFF(R5),-	;  xfer offset +
		SCS$L_SND_BOFF(R2)	;  segmentation
	MOVAB	W^INT$SNDDAT,R0		; Addr of PPD action routine

COMMON_XFER:

	$CHK_CDTSTATE	-		; Verify connection state is
		OPEN,-			;  open.
		ERROR=STATE_ERR_R3,-	; Else notify caller
		CDT=R3
	MOVL	CDT$L_LCONID(R3),-	; Set transaction ID =
		SCS$L_LCONID(R2)	;  local CONID followed
	MOVL	CDRP$L_RSPID(R5),-	;  by RSPID
		SCS$L_RSPID(R2)
	MOVL	CDRP$L_XCT_LEN(R5),-	; Set transfer size
		SCS$L_XCT_LEN(R2)
	MOVL	CDT$L_PB(R3),R1		; Get address of PB in R1
	JSB	(R0)			; Call the PPD layer
	CLRL	CDRP$L_MSG_BUF(R5)	; Zero msg buffer addr
	POPL	R3			; Restore SYSAP's R3
	$SUSP_FP			; Suspend caller

	.DSABL	LSB

	.SBTTL	-	UNMAP,		UNMAP A BUFFER

;+
; UNMAP converts the buffer name specified in the local buffer handle
; to a buffer descriptor address.  If the buffer descriptor is not 
; good (sequence number check), then the routine bugchecks.  Otherwise,
; the descriptor valid bit is cleared, the sequence number incremented,
; and the descriptor is linked to the free list.  Any CDRP waiting for 
; a buffer descriptor is resumed.
;
; Inputs:
;
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	CDRP$L_LBUFH_AD		-Addr of local buffer handle
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;
;	CIBHAN$L_BNAME		-Zeroed
;-

	.ENABL	LSB

FPC$UNMAP::

	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get addr of local buff handle
	MOVL	CIBHAN$L_BNAME(R1),R2	; Get buffer name
	BEQL	30$			; Branch if none allocated
	MOVZWL	R2,R2			; Isolate BD index
	MOVL	G^SCS$GL_BDT,R0		; Get addr of BDT
	CMPL	R2,CIBDT$L_MAXIDX(R0)	; Index greater than maximum?
	BGTR	BD_SEQ_ERROR		; Branch if so, same as bad seq number

	ASSUME	CIBD$C_LENGTH EQ 16	
	
	ADDL	R2,R2			; Prepare for net 16 byte index
	MOVAQ	(R0)[R2],R2		; Get addr of BD
	CMPW	CIBD$W_KEY(R2),-	; Sequence # in BD =
		CIBHAN$L_BNAME+2(R1)	;  that in buffer handle?
	BNEQ	BD_SEQ_ERROR		; Branch if not
	INCW	CIBD$W_KEY(R2)		; Step sequence number
	BNEQ	10$			; Branch if nonzero
	INCW	CIBD$W_KEY(R2)		; Else step again

10$:	BBCC	#CIBD$V_V,-		; Clear valid bit
		CIBD$W_FLAGS(R2),20$	;

20$:	MOVL	CIBDT$L_FREEBD(R0),-	; Link this BD to
		CIBD$L_LINK(R2)		;  free list
	MOVL	R2,CIBDT$L_FREEBD(R0)	;
	CLRL	CIBHAN$L_BNAME(R1)	; Zero buffer name to show
					;  none mapped
	$RESUME_FP	-		; Resume waiter, if nay
		@CIBDT$L_WAITFL(R0)	;

30$:	RSB				; Return to caller

BD_SEQ_ERROR:				; SYSAP tried to unmap buffer
					;
	BUGCHECK  CIPORT,NONFATAL	;  without right key -- leave
					;  buffer descriptor permanently
					;  allocated and do nothing to it.

40$:	RSB				;  return to caller

	.DSABL	LSB

	.SBTTL	-	SUSP_CONCALL,	SUSPEND CONNECTION
	.SBTTL	-			MANAGEMENT CALL

;+
; Connection management calls assume that the SYSAP's fork process
; consists of R3 = CDT address, R4 = PDT address, R5, and (SP) =
; return from the connection management call.  R3 is automatically 
; restored by the event (response) triggering call completion;  R4
; is restorable from the CDT.  Therefore, the only context saved is
; R5 and return from call.
;
; Inputs:
;
;	R3			-CDT addr
;	R4			-PDT addr
;	R5			-SYSAP's R5
;	(SP)			-SYSAP PC
;
; Outputs:
;
;	R5, (SP)+		-Saved in CDT
;	Return to caller's caller
;-

	.ENABL	LSB

SUSP_CONCALL:

	MOVL	R5,CDT$L_FR5(R3)	; Save SYSAP R5
	POPL	CDT$L_FPC(R3)		; Save SYSAP PC and remove it from stack
	RSB				; Return to caller's caller

	.DSABL	LSB

	.SBTTL	-	STATE_ERR,	RETURN CDT STATE ERROR
	.SBTTL	-			TO SYSAP

;+
; Set error status code and return to caller.
;-

STATE_ERR_R3:				; Entry if caller's R3 is saved on stack
	
	POPL	R3			; Restore R3 for caller

STATE_ERR:

	MOVZWL	#SS$_ILLCDTST,R0	; Status = illegal CDT state
	RSB				; Return to SYSAP

	.SBTTL	MAINTENANCE FUNCTION CALLS
	.SBTTL	-	FPC$READCOUNT,	READ AND LOCK
	.SBTTL	-			PORT COUNTERS

;+
; This routine is called by a SYSAP to reset the port counters to begin
; counting ACKS/NAKS/NO_RESPONSES on each path and total datagrams discarded
; from a particular port or all ports.  The SYSAP 'owns' the counters until it
; does a RLS_COUNTERS call.  If another SYSAP owns the counters, then
; error status is returned to the SYSAP.
;
; Note that this is an unusual fork process call in that the SYSAP hands
; FPC$READCOUNT the base of the PPD  layer of the dg pkt, and receives
; back the PPD layer address of the counters read response.  The reason
; is that in this one case the application data is entirely port specific.
; The mechanism for managing counter ownership is all that is assumed to
; be port independent and hence can be handled in this module (which must
; be port independent.)  The packet address is simply passed through this
; layer to the PPD layer without being used in any way.  Future port
; implementations may have different counter management and, in that
; case counter ownership book keeping would also have to migrate into
; the PPD layer.
;
; Inputs:
;
;	R0			-Addr of remote station to count for;
;				 0 addr means count for all stations
;	R1			-Addr of local process name
;	R2			-Addr of base of datagram sized buffer
;				 (PPD layer)
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INTERLOCK,
; 				 SS$_NOSUCHNODE
;	R2			-Addr of datagram buffer, current counters
;				 to all ports since last release
;	R1			-Destroyed
;
;	Other registers		-Preserved
;
;	PDT$B_FLAGS(R4)		-Counters busy flag set
;	PDT$T_CNTOWNER(R4)	-Name of owning SYSAP
;	
;	PPD$L_P0_ACK(R2)	-ACKS on path 0
;	PPD$L_P0_NAK(R2)	-NAKS on path 0
;	PPD$L_P0_NRSP(R2)	-No responses on path 0
;	PPD$L_P1_ACK(R2)	-ACKS on path 1
;	PPD$L_P1_NAK(R2)	-NAKS on path 1
;	PPD$L_P1_NRSP(R2)	-No responses on path 1
;	PPD$L_DG_DISC(R2)	-Datagrams discarded
;-

	.ENABL	LSB

FPC$READCOUNT::

	BBSS	#PDT$V_CNTBSY,-		; Branch if counters busy; else
		PDT$W_FLAGS(R4),BSY_ERR	;  set busy and continue
	MOVQ	(R1)+,PDT$T_CNTOWNER(R4); Save new owner's name
	MOVQ	(R1),PDT$T_CNTOWNER+8(R4)

10$:	BICW	#PDT$M_CNTRLS,-		; Clear release pending
		PDT$W_FLAGS(R4)		;

ISSUE_RDCNT:
	
	BSBW	INT$READCNT		; Issue command to port
	BLBC	R0,30$			; If error, leave now
	MOVL	R5,PDT$L_CNTCDRP(R4)	; Save caller's CDRP addr
	$SUSP_FP			; Save fork process' context
					;  till response arrives

BSY_ERR:
	
	PUSHR	#^M<R0,R2,R3>		; Save registers for CMPC
	CMPC3	#16,(R1),-		; Is current owner = requestor?
		PDT$T_CNTOWNER(R4)	;
	TSTL	R0			; Check compare result
	BNEQ	20$			; Branch if requestor not owner
	POPR	#^M<R0,R2,R3>		; Restore registers
	BRB	10$			; Continue with request

20$:	POPR	#^M<R0,R2,R3>		; Restore registers
	MOVZWL	#SS$_INTERLOCK,R0	; Else set error status
30$:	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$RLSCOUNT,	READ AND RELEASE
	.SBTTL	-			PORT COUNTERS

;+
; FPC$RLSCOUNT has the same function as FPC$READCOUNT except that the
; caller is asusmed to already own the counters so no check is done, and
; the port is reset to count all ports again.  (Count all is the default
; while the counters are unowned.)
;
; Inputs:
;
;	R2			-Addr of base of dg sized buffer
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL
;	R2			-Addr of datagram buffer filled
;				 as specified in FPC$READCOUNT
;	R1			-Destroyed
;	
;	Other registers 	-Preserved
;-

	.ENABL	LSB

FPC$RLSCOUNT::

	BISW	#PDT$M_CNTRLS,-		; Set count release pending
		PDT$W_FLAGS(R4)		;
	CLRL	R0			; Set port to count all ports
	BRB	ISSUE_RDCNT		; Go give read count command

	.DSABL	LSB

	.SBTTL	-	FPC$MRESET,	RESET REMOTE PORT/SYSTEM

;+
; FPC$MRESET allocates a datagram buffer and uses it to send
; a maintenacne reset to the specified remote port.
;
; Inputs:
;
;	R0			-0/1 for dont/do force reset
;	R1			-Addr of remote station to reset
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM,
;				 SS$_NOSUCHNODE
;	R1,R2			-Destroyed
;	
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$MRESET::

	PUSHL	R3			; Save SYSAP register
	PUSHAB	W^INT$MRESET		; PPD action routine
	BRB	10$			; Join commond code	

	.SBTTL	-	FPC$MSTART,	SEND START TO REMOTE
	.SBTTL	-			SYSTEM

;+
; FPC$MSTART allocates a datagram buffer and sends a start command
; to the specified remote port/system.
;
; Inputs:
;
;	R0			-1/0 for use default start addr/
;				 specified start addr
;	R1			-Addr of remote station addr
;	R2			-Start addr to send if R0 = 0
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM,
;				 SS$_NOSUCHNODE
;	R1,R2			-Destroyed
;
;	Other registers		-Preserved
;-


FPC$MSTART::

	PUSHL	R3			; Save SYSAP register
	PUSHAB	W^INT$MSTART		; PPD action routine

10$:	PUSHR	#^M<R0,R1,R2>		; Save input arguments
	BSBW	INT$ALLOC_DG		; Get a dg buffer
	BLBC	R0,MEM_ERR		; Branch if none
	POPR	#^M<R0,R1,R3>		; Retreive two input arguments
	JSB	@(SP)+			; Issue command
	POPL	R3			; Restore register
	BLBC	R0,PORT_ERR		; Bad port status
	RSB				; Return to SYSAP

MEM_ERR:

	POPR	#^M<R0,R1,R2>		; Clear input arguments
	TSTL	(SP)+			; Clear PPD routine address
	POPL	R3			; Restore SYSAP's R3
	MOVZWL	#SS$_INSFMEM,R0		; Set error status
	RSB				;  and return to SYSAP

PORT_ERR:

	PUSHL	R0			; Save status
	BSBW	INT$DEAL_DG		; Get rid of the buffer
	POPL	R0			; Restore status
	RSB

	.DSABL	LSB

	.SBTTL	-	FPC$STOP_VCS,	SEND SHUTDOWN ON ALL VCS

;+
; FPC$STOP_VCS is very port specific.  All we do here is call the port
; dependent routine, CNF$STOP_VCS which attempts to send a datagram
; to each known port.  The datagram notifies the remote system that the
; host is shutting down, so it can notify its SYSAPs promptly of the event. 
;
; Inputs:
;
;	R4			-PDT address
;	
; Outputs:
;	
;	R0-R3			-Destroyed
;
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$STOP_VCS::

	BSBW	CNF$STOP_VCS		; Call routine that executes function
	RSB

	.DSABL	LSB

	.SBTTL	RECEIVED PACKET ROUTINES
	.SBTTL	-	FPC$REC_DGREC,	PROCESS RECEIVED DG

;+
; FPC$REC_DGREC verifies the destination connection ID and checks that
; the connection has at least one datagram queued for receive.  If the
; connection has no datagrams queued for receive, then the datagram is
; discarded to the free queue and not given to the SYSAP.  Otherwise,
; the SYSAP's datagram input address is called.  Upon return from the
; SYSAP, control is returned to the INTR module to get the next response.
;
; Inputs:
;
;	R2			-Addr of message buffer (user portion)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R4			-Preserved
;	Other registers		-Destroyed
;
;-

ASSUME	SYSAP$C_DGREC EQ 0

	.ENABL 	LSB

FPC$REC_DGREC::

	BSBW	FPC$CHK_DCONID		; Verify destination CONID in
					;  SCS header
	BLBC	R0,20$			; Branch if bad CONID
	CLRL	R0			; Set flag to show DGREC
	DECW	CDT$W_DGREC(R3)		; Decrement DG receive count
	BGEQ	30$			; Branch if recv dg's available
	INCW	CDT$W_DGREC(R3)		; Restore correct count
	BSBW	INT$INS_DFREEQ		; Get rid of dg
	INCL	CDT$L_DGDISCARD(R3)	; Step dg discard count
20$:	RSB

30$:	INCL	CDT$L_DGRCVD(R3)	; Step count of total bytes of
					;  application data received
	BRB	DGCOM			; Join common code

	.DSABL	LSB

	.SBTTL	-	FPC$REC_SNDDG,	PROCESS SENT DG

;+
; FPC$REC_SNDDG verfies the source connection ID.  If correct, R0 is
; set to SYSAP$C_DGSNT to indicate that the datagram is a sent DG
; rather than a new received DG.  The correct length is set in R1.
;
; Inputs:
;
;	R2			-Addr of dg buffer (user portion)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R4			-Preserved
;	Other registers		-Destroyed
;
;-

	.ENABL	LSB

FPC$REC_SNDDG::

	BSBW	FPC$CHK_SCONID		; Verify sending connection ID
	BLBC	R0,10$			; Branch if invalid
	MOVZBL	#SYSAP$C_DGSNT,R0	; Set flag to indicate DGSNT

DGCOM:

	SUBW3	#SCS$C_OVHD,-		; Application data = DG length -
		SCS$W_LENGTH(R2),R1	;  SCS header size
	MOVZWL	R1,R1			; Expand to longword
	PUSHL	R4			; Save R4(PDT) for REM_NEXT_RSP
	JSB	@CDT$L_DGINPUT(R3)	; Call SYSAP  to dispose of dg buffer
	POPL	R4			; Restore
	RSB				; Return

10$:	BRW	INT$INS_DFREEQ		; Return dg to free queue and
					;  RSB
	.DSABL	LSB

	.SBTTL	-	FPC$REC_DATREC,	PROCESS RECEIVED RETDAT
	.SBTTL	-	FPC$REC_CNFREC,	PROCESS RECEIVED RETCNF

;+
; These routines perform the same steps.
;
; First, the CONID portion of the XCT_ID is verified and converted to
; a CDT address.  The RSPID portion of the XCT_ID is converted to the
; response descriptor address and the CDRP address extracted from the
; RD.  The RSPID and message buffer containing the CNFREC/DATREC are
; then deallocated.  Finally, the context of the suspended SYSAP is
; restored and the SYSAP called back at the PC following the call to
; send/request data.
;
; Inputs:
;
;	R2			-Addr of message buffer (user portion)
;	R4			-Addr of PDT

; Outputs:
;
;	R4			-Preserved
;	Other registers		-Destroyed
;
;-

	.ENABL	LSB

FPC$REC_DATREC::

FPC$REC_CNFREC::

	BSBW	FPC$CHK_LCONID		; Verify transaction ID/CONID
					;  and get CDT addr
	BLBC	R0,STALE_CDT		; Branch if stale CDT
	INCW	CDT$W_SEND(R3)		; Add implied credit of 1
	MOVZWL	SCS$L_RSPID(R2),R1	; Get RSPID index
	MOVL	G^SCS$GL_RDT,R0		; Get base of RD table
	MOVAQ	(R0)[R1],R1		; Get RD address
	CMPW	RD$W_SEQNUM(R1),-	; Verify 
		SCS$L_RSPID+2(R2)	;  sequence number
	BNEQ	RD_SEQ_ERR		; Branch if bad sequence number
	MOVL	RD$L_CDRP(R1),R5	; Get CDRP addr
	PUSHL	R2			; Save volatile register
	DEALLOC_RSPID			; Deallocate RSPID
	POPL	R2			; Restore register
	BSBW	INT$DEAL_MSG		; Deallocate msg buffer to
					;  pool since it is always allocated
					;  from pool.
	MOVQ	R3,-(SP)		; Save CDT & PDT addr
	MOVQ	CDRP$L_FR3(R5),R3	; Restore SYSAP's R3,R4
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	JSB	@CDRP$L_FPC(R5)		; Call SYSAP back
	MOVQ	(SP)+,R3		; Restore CDT & PDT addr
	BRB	CHK_CRWAIT		; Join common code in REC_MSGREC
					;  to start anyone waiting for
					;  send credit, then go for next
					;  response
RD_SEQ_ERR:

	$DEBUGCHECK #ERR$V_DEB_XCTER	; Optionally, bugcheck on this error
	SUBL	PDT$L_MSGHDRSZ(R4),R2	; Back up msg pointer to start of buffer
	BSBW	CNF$LKP_PB_MSG		; Given msg, look up PB if any
	BRW	INT$CRASH_PORT		; Crash the port & restart

STALE_CDT:
	
	RSB				; All cleaned up, just return
	
	.DSABL	LSB

	.SBTTL	-	FPC$REC_MSGREC,	PROCESS RECEIVED MSG

;+
; FPC$REC_MSGREC checks the SCS message type field.  If the type code
; is SCS$C_APPL_MSG, then processing continues.  Otherwise the message
; is an SCS control message and routine SCS$REC_SCSMSG in called.
;
; For application messages, it checks that the destination connection
; ID is legal.  If not, the message buffer is discarded (returned to
; the free queue) and processing ends.  Otherwise, the connection credit
; bookkeeping is done and the SYSAP's message input address is called.
; The SYSAP is responsible for disposing of the message buffer.  Upon 
; return from the SYSAP, REC_MSGREC branches to REM_NEXT_RSP.
;
; Inputs:
;
;	R2			-Addr of message buffer (user portion)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R4			-Preserved
;	Other registers		-Destroyed
;
;-

	.ENABL	LSB

FPC$REC_MSGREC::

	CMPW	SCS$W_MTYPE(R2),-	; Is this an application
		#SCS$C_APPL_MSG		;  message?
	BEQL	10$			; Branch if yes
	PUSHL	R4			; Save R4(PDT) for REM_NEXT_RSP
	BSBW	SCS$REC_SCSMSG		; Message is SCS control- go handle
	POPL	R4			; Restore
	RSB				; Get next response

10$:	BSBW	FPC$CHK_DCONID		; Verify destination CONID
	BLBC	R0,20$			; Branch if invalid
	DECW	CDT$W_REC(R3)		; Decrement send credit held
					;  by remote
	ADDW	SCS$W_CREDIT(R2),-	; Add credit extended by remote to
		CDT$W_SEND(R3)		;  to send credit
	INCL	CDT$L_MSGRCVD(R3)	; Incr count of # appl msgs received
	SUBW3	#SCS$C_OVHD,-
		SCS$W_LENGTH(R2),R1	; Set size of applicaton data
	MOVZWL	R1,R1			;  for SYSAP
	MOVQ	R3,-(SP)		; Save CDT & PDT address
	JSB	@CDT$L_MSGINPUT(R3)	; Call SYSAP message input address
	MOVQ	(SP)+,R3		; Retreive CDT & PDT address

CHK_CRWAIT:

	TSTW	CDT$W_SEND(R3)		; Any send credit?
	BEQL	20$			; Branch if not
	$RESUME_FP	-		; Else, resume next waiter,
		@CDT$L_CRWAITQFL(R3),-	;
		QEMPTY=20$		;  branching if none.
	BRB	CHK_CRWAIT		; Check for more credit

20$:	RSB

	.DSABL	LSB

	.SBTTL	-	FPC$REC_SNDMSG,	PROCESS SEND MSG

;+
; FPC$REC_SNDMSG simply calls FPC$DEALRGMSG to deallocate the sent
; message.  The deallocate takes care of flow control and may
; deallocate the buffer to the free queue if the free queue is
; low, or to pool.
;
; Inputs:
;
;	R2			-Addr of message buffer (user portion)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R4			-Preserved
;	Other registers		-Destroyed
;
;-

	.ENABL	LSB

FPC$REC_SNDMSG::

	BSBB	FPC$CHK_SCONID		; Verify source 
	BLBC	R0,SC_SEQ_ERR		;  connect ID
	BRW	FPC$DEALRGMSG		; Deallocate buffer

SC_SEQ_ERR:

	SUBL	PDT$L_MSGHDRSZ(R4),R2	; Back up message addr to top
					;  of buffer from user data
	BSBW	CNF$LKP_PB_MSG		; Given msg, look up PB, if any
	BRW	INT$CRASH_PORT

	.DSABL	LSB

	.SBTTL	-	FPC$REC_RDCNT,	PROCESS RECEIVED RDCNT

;+
; FPC$REC_RDCNT returns the received buffer of port counters to the
; SYSAP that owns the port counters currently.  If the SYSAP specified
; a release of the counters, then the counters busy flag is cleared.
;
; Inputs:
;
;	R2			-Addr of message buffer
;	R4			-Addr of PDT
;	PDT$L_CNTCDRP(R4)	-CDRP holding suspended SYSAP context
;
; Outputs:
;
;	R4			-Preserved
;	Other registers		-Destroyed
;	PDT$W_FLAGS(R4)		-If PDT$M_CNTRLS is set then PDT$M_CNTRLS
;				 and PDT$M_CNTBSY are both cleared
;-

	.ENABL	LSB
	
FPC$REC_RDCNT::

	BBCC	#PDT$V_CNTRLS,-		; Branch if no release of
		PDT$W_FLAGS(R4),10$	;  counters is pending
	BICW	#PDT$M_CNTBSY,-		; Else this is a release --
		PDT$W_FLAGS(R4)		;  clear counters busy

10$:	MOVL	PDT$L_CNTCDRP(R4),R5	; Get SYSAP's CDRP
	MOVZWL	#SS$_NORMAL,R0		; Set success status for SYSAP
	PUSHL	R4			; Save PDT addr
	MOVQ	CDRP$L_FR3(R5),R3	; Get SYSAP's saved R3, R4
	JSB	@CDRP$L_FPC(R5)		; Call SYSAP back with results
	POPL	R4			; Retreive PDT addr
	RSB

	.DSABL	LSB

	.SBTTL	MISC. ROUTINES
	.SBTTL	-	FPC$CHK_SCONID,	CHECK SENDER CONID
	.SBTTL	-	FPC$CHK_DCONID,	CHECK DESTINATION CONID
	.SBTTL	-	FPC$CHK_LCONID,	CHECK CONID IN LCONID

;+
; FPC$CHK_SCONID -- Verifies the sender connection ID in the SCS
;		    header and returns the address of the CDT
; FPC$CHK_DCONID -- Verifies the destination connection ID in the SCS
;		    header and returns the address of the CDT
; FPC$CHK_LCONID -- Verifies the connection ID in the CONID portion
;		    of an XCT_ID in a block xfer message. (First
;		    longword of XCT_ID)
;
; The connection ID index (l.o. word) is extracted and compared
; with the maximum index number.  If it exceeds the maximum index,
; return error.  Else, compute the CDT address from the index.  
; Check the sequence # in the CDT.  If they agree, return success. 
; Else return error.
;
; Inputs:
;
;	R2			-Addr of message/datagram buffer
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-1/0 for success/fail
;	R1			-Destroyed
;	R2			-Addr of msg/dg (CHK_SCONID)
;				 Addr of msg/dg iff success (CHK_D/LCONID)
;	R3			-Addr of CDT if success
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$CHK_SCONID:

	MOVZWL	SCS$L_SRC_CONID(R2),R1	; Get source connection ID index
	MOVL	G^SCS$GL_CDL,R3		; Get addr of connx descriptor list
	CMPW	R1,CDL$W_MAXCONIDX(R3)	; Compare index with maximum
	BGTRU	BAD_SCONID		; Branch if index is too big
	MOVL	(R3)[R1],R3		; Turn index to CDT address
	CMPL	CDT$L_LCONID(R3),-	; ID in msg/dg matches ID in CDT?
		SCS$L_SRC_CONID(R2)	;
	BNEQ	BAD_SCONID		; Branch if not
	MOVZWL	#SS$_NORMAL,R0		; Else success status
	RSB

FPC$CHK_LCONID:

	MOVL	SCS$L_LCONID(R2),R0	; Extract CONID from message
	BRB	10$			; Join common code

FPC$CHK_DCONID::

	MOVL	SCS$L_DST_CONID(R2),R0	; Get destination connection ID

10$:	MOVZWL	R0,R1			; Extract index
	MOVL	G^SCS$GL_CDL,R3		; Get addr of connx descriptor list
	CMPW	R1,CDL$W_MAXCONIDX(R3)	; Compare index with maximum
	BGTRU	BAD_CONID		; Branch if index is too big
	MOVL	(R3)[R1],R3		; Turn index to CDT address
	CMPL	CDT$L_LCONID(R3),R0	; ID in msg/dg matches ID in CDT?
	BNEQ	BAD_CONID		; Branch if not
	MOVZWL	#SS$_NORMAL,R0		; Else success status
	RSB				; Return

BAD_CONID:

	CMPW	SCS$W_MTYPE(R2),-	; Is this an application datagram?
		#SCS$C_APPL_DG		;
	BEQL	20$			; Branch if so
	BSBW	INT$INS_MFREEQ		; Return message buffer to free queue
	BRB	30$			; Join common exit

20$:	BSBW	INT$INS_DFREEQ		; Return dg buffer to free queue

30$:	CLRL	R0			; Set status to failure
	RSB				; Return
	
BAD_SCONID:

	$DEBUGCHECK #ERR$V_DEB_SCERR	; Optionally, bugcheck on this error
	BRB	30$			; To recover, go return error to caller

	.DSABL LSB

	.SBTTL	FPC$INITIAL,	INITIALIZE AT THIS LAYER
	.SBTTL	-	BUILD BDT

;+
; The buffer descriptor table is shared among CI ports.  If it does
; not already exist, allocate and initialize it.
;-

ASSUME	CIBDT$L_WAITFL+4  EQ 	CIBDT$L_WAITBL
ASSUME	CIBDT$L_WAITBL+4  EQ	CIBDT$W_SIZE
ASSUME	CIBDT$W_SIZE+2    EQ	CIBDT$B_TYPE
ASSUME  CIBDT$B_TYPE+1	  EQ	CIBDT$B_SUBTYP
ASSUME	CIBDT$B_SUBTYP+1  EQ	CIBDT$L_FREEBD
ASSUME	CIBDT$L_FREEBD+4  EQ	CIBDT$L_MAXIDX
ASSUME	CIBDT$L_MAXIDX+8  EQ	CIBDT$C_BDLIST

	.ENABL	LSB

FPC$INITIAL::

	TSTL	G^SCS$GL_BDT		; Got buffer descriptors already?
	BNEQ	40$			; Branch if so
	MOVZWL	G^SCS$GW_BDTCNT,R1	; Get # of buffer descriptors
	PUSHL	R1			; Save it
	ASHL	#4,R1,R1		; Get # bytes of descriptors
	ADDL	#CIBDT$C_LENGTH,R1	;  + BDT header length
	JSB	G^EXE$ALONONPAGED	; Allocate pool for descriptors
	BLBC	R0,50$			; Branch if failure
	PUSHL	R2			; Save addr of BDT
	MOVL	R2,(R2)+		; Set BD wait queue
	MOVAL	-4(R2),(R2)+		;  listhead emptyp
	MOVW	R1,(R2)+		; Set structure size,
	MOVW	#<DYN$C_CI_BDT@8 + DYN$C_CI>,(R2)+  ;  type, and subtype
	CLRL	(R2)+			; Clear ptr for later
	MOVL	4(SP),(R2)		; Set # buffer descriptors
	DECL	(R2)+			; Max index = # BD's-1
	CLRL	(R2)+			; Clear reserved longwd
	MOVL	R2,G^SCS$GL_BDT		; Save addr in system wide data base
	POPL	R1			; Get BDT address again
	MOVL	G^SCS$GL_CDL,R0		; Get addr of connx descriptor list
	MOVL	(R0),R0			;  and addr of first CDT.
	MOVZWL	CDT$L_LCONID+2(R0),R0	; Get that CDT's sequence number
	XORB2	#^X5A,R0		; Make it unique
	TSTL	(SP)			; Get # buffer descriptors
	BEQL	30$			; Branch if zero

;
; Loop to initialize buffer descriptors links all BD's onto the
; free list rooted at CIBDT$L_FREEBD, marks each BD invalid, and
; initializes the BD sequence number
;

20$:	CLRW	CIBD$W_FLAGS(R2)	; Clear valid bit
	MOVW	R0,CIBD$W_KEY(R2)	  ; Init sequence #
	MOVL	R2,CIBD$L_LINK(R1)	; Link this BD to previous
	MOVL	R2,R1			; Set this BD to previous
	MOVAL	CIBD$C_LENGTH(R2),R2	; Step to next BD
	SOBGTR	(SP),20$		; Branch if more BD's to do

30$:	CLRL	CIBD$L_LINK(R1)		; Zero last fwd link
	TSTL	(SP)+			; Clear stack
40$:	MOVL	#SS$_NORMAL,R0		; Set for succes
50$:	RSB

	.DSABL	LSB

	.END
