	.TITLE	DEVICEDAT - VAX/VMS SYSTEM PERMANENT DEVICE DATABASE
	.IDENT	'V04-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS I/O SUBSYSTEM
;
; ABSTRACT:
;
;	SYSTEM PERMANENT DEVICE DATABASE
;
; AUTHOR:
;	R.HEINEN 3-AUG-76
;
; MODIFIED BY:
;
;	V04-001	BLS0351		Benn Schreiber		 6-SEP-1984
;		Must dpt_store fields for cloneable opa ucb.
;
;	V03-023	WHM0003		Bill Matthews		19-Jul-1984
;		Make OPA$IDB global for use by OPDRVWS1.
;
;	V03-022	LMP0275		L. Mark Pilant,		12-Jul-1984  19:51
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-021	CDS0003		Christian D. Saether	 1-May-1984
;		Reflect change of wcb size in net$wcb.
;
;	V03-020 EMD0092		Ellen M. Dusseault	30-Apr-1984
;		Add DEV$M_NNM characteristic to DEVCHAR2 for the 
;		console and mailbox devices so that they will have
;		the prefix "node$".
;
;	V03-019	LMP0221		L. Mark Pilant,		30-Mar-1984  12:35
;		Move UCB protection information to the Object's Rights Block.
;
;	V03-018	PRD0072		Paul R. DeStefano	27-Feb-1984
;		Add SB$L_CSB (link to newest Cluster System Block)
;		to permanent local system block.
;
;	V03-017	WHM0002		Bill Matthews		27-Feb-1984
;		Add support for 4 units in the OPA IDB for VENUS.
;
;	V03-016	WHM0001		Bill Matthews		6-Feb-1984
;		Add support for new IDB fields for combo style devices.
;
;	V03-015	LMP0185		L. Mark Pilant,		1-Feb-1984  9:08
;		Add support for device ACLs.
;
;	V03-014	MMD0224		Meg Dumont,	23-Jan-1984  10:15
;		Add longword to store the Asynch DDCMP driver DPT
;
;	V03-013	JLV0319		Jake VanNoy		16-DEC-1983
;		Add TTY$GL_JOBCTLMB, SYS$GL_UIS, UIS$GL_USB, and
;		SYS$GL_FALLBACK.
;
;	V03-012	TCM0001		Trudy C. Matthews	12-Sep-1983
;		Initialize the boot device's UCB$W_REFC field to 1.  This
;		prevents $ASSIGN from trying to take out a lock on the
;		system disk before locking is enabled.
;
;	V03-011	CWH3001		CW Hobbs		5-Jul-1983
;		Increase size of operator mailbox (MBA2:) to 2560
;		byte maximum messages.  This will support the security
;		message of 2048 bytes + various headers rounded up to
;		nearest page.
;
;	V03-010	RLRDPORT	Robert L. Rappaport	25-May-1983
;		Increase size of Boot Device UCB.
;
;	V03-009	ROW0187		Ralph O. Weber		30-APR-1983
;		Increase default buffer size of null device from 132 
;		to 512 bytes.
;
;	V03-008	ROW0172		Ralph O. Weber		10-APR-1983
;		Change null device UCB device type to DT$_NULL.
;
;	V03-007	DWT0066		David W. Thiel		20-Jan-1983
;		Update definition of the local system block.
;
;	V03-006	MIR0022		Michael I. Rosenblum	19-Jan-1983
;		Change Console terminal port vector table to use the
;		new vector creation macros.
;
;	V03-005	KTA3022		Kerbey T. Altmann	29-Dec-1982
;		Add permanent local system block.
;
;	V03-004	CDS0002		Christian D. Saether	27-Dec-1982
;		Reflect move of WCB cells in NET$WCB::.
;
;	V03-003	CDS0001		Christian D. Saether	13-Dec-1982
;		Fix problems with WCB growing a longword.
;
;	V03-002	ROW0123		Ralph O. Weber		12-SEP-1982
;		Fix UCB macro so that it needs no ASSUMEs.  Have it use 
;		$UCBDEF constants an .BLKBs to define fill space rather than 
;		numeric constants.
;
;	V03-001	BLS0183		Benn Schreiber		25-Aug-1982
;		Reorganize OPA0: data structures for loadable console
;		terminal support.
;--
;
; SYMBOL DEFINITIONS
;
 
	$CRBDEF				; DEFINE CRB
	$DCDEF				; DEFINE DEVICE CLASSES
	$DDBDEF				; DEFINE DDB
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$DYNDEF				; STRUCTURE TYPE CODE DEFINITIONS
	$IDBDEF				; DEFINE IDB
	$IPLDEF				; DEFINE IPL LEVELS
	$IRPDEF				; DEFINE IRP OFFSETS
	$ORBDEF				; OBJECT'S RIGHTS BLOCK OFFSETS
	$SBDEF
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$UCBDEF				; DEFINE UCB
	$TTYDEFS			; TTY UCB extension (must FOLLOW $UCBDEF)
	$TTYMACS			; THE TERMINAL DRIVER MACRO DEFINITIONS
	$VECDEF				; DEFINE CRB VECTOR
	$WCBDEF				; Define WCB
 
;
; LOCAL MACROS
;
	.MACRO	ORB	LABEL,?EN,?ACL
ORBASE=.
LABEL::
	.LONG	0
	.WORD	-1,0			; ACL MUTEX INITIALIZATION
	.WORD	EN-LABEL
	.BYTE	DYN$C_ORB
	.BYTE	ORB$M_PROT_16
	.BLKB	ORB$K_LENGTH - <. - LABEL>
EN:
	.ENDM
;
	.MACRO	STO_ORB	OFFSET,SIZE,VALUE
	X=.
	.=ORBASE+ORB$'OFFSET
	.'SIZE	'VALUE
	.=X
	.ENDM
;
	.MACRO	UCB	LABEL,EXPAND=0,ORB_ADDR,?IOL,?EN,?ACL
UCBASE=.
LABEL::
	.LONG	0,0
	.WORD	EN-LABEL
	.BYTE	DYN$C_UCB
	.BYTE	0
	.BLKB	UCB$L_ORB - <. - LABEL>
	.LONG	ORB_ADDR
	.BLKB	UCB$L_IOQFL - <. - LABEL>
IOL:	.LONG	IOL,IOL
	.BLKB	UCB$K_LENGTH - <. - LABEL>
	.BLKL	EXPAND
EN:
	.ENDM
;
	.MACRO	STO_UCB	OFFSET,SIZE,VALUE
	X=.
	.=UCBASE+UCB$'OFFSET
	.'SIZE	'VALUE
	.=X
	.ENDM
 
	ASSUME	DDB$L_LINK	EQ  0
	ASSUME	DDB$L_UCB	EQ  4
	ASSUME	DDB$W_SIZE	EQ  8
	ASSUME	DDB$B_TYPE	EQ  10
	ASSUME	DDB$L_DDT	EQ  12
	ASSUME	DDB$L_ACPD	EQ  16

	.MACRO DDB NAME,NEXT,FUCB,DDT,ACP,ATYPE,DEVNAM,DRVNAM,?EN
NAME::	.LONG	NEXT
	.LONG	FUCB
	.WORD	EN-'NAME
	.BYTE	DYN$C_DDB,0
	.LONG	DDT
	.LONG	^A/'ACP/+<'ATYPE@24>
	.ASCIC	/'DEVNAM/
	.='NAME+DDB$T_DRVNAME
	.ASCIC	/'DRVNAM/
	.='NAME+DDB$L_SB
	.LONG	SCS$GA_LOCALSB
	.='NAME+DDB$C_LENGTH
EN:
	.ENDM
 
	.PSECT	$$$100,QUAD,WRT

	.SBTTL	SYSTEM DEVICE DATABASE LIST HEADS
;
; SYSTEM ADAPTER CONTROL BLOCK (ADP) LIST HEAD
;
IOC$GL_ADPLIST::			;
	.LONG	0			;
;
; SYSTEM DRIVER PROLOGUE LIST HEAD
;
IOC$GL_DPTLIST::			;
	.LONG	IOC$GL_DPTLIST		;
	.LONG	IOC$GL_DPTLIST		;
;
; TERMINAL CLASS DRIVER DPT POINTER
;
TTY$GL_DPT::				;
	.LONG	0			;
;
; Asynch Class driver DPT pointer
;
NO$GL_DPT::				;
	.LONG 	0			;
;
; ADDRESS OF JOB CONTROLLER MAILBOX
;
TTY$GL_JOBCTLMB::			;
	.ADDRESS SYS$GL_JOBCTLMB	;
;
; ADDRESS OF LOADED UIS CODE
;
SYS$GL_UIS::
	.LONG	0
;
; ADDRESS OF UIS CONTEXT BLOCK
;
UIS$GL_USB::
	.LONG	0
;
; ADDRESS OF SYSTEM WIDE FALLBACK TABLE
;
SYS$GL_FALLBACK::
	.LONG	0

	.SBTTL	PERMANENT LOCAL SCS SYSTEM BLOCK
;
; LOCAL SB
;
SCS$GA_LOCALSB::
	.LONG	SCS$GQ_CONFIG		; SB$L_FLINK
	.LONG	SCS$GQ_CONFIG		; SB$L_BLINK
	.WORD	SB$K_LENGTH		; SB$W_SIZE
	.BYTE	DYN$C_SCS		; SB$B_TYPE
	.BYTE	DYN$C_SCS_SB		; SB$B_SUBTYP
	ASSUME	SB$L_PBFL EQ 12
10$:	.LONG	10$			; SB$L_PBFL
	.LONG	10$			; SB$L_PBBL
	ASSUME	SB$L_PBCONNX EQ 20
	.LONG	0			; SB$L_PBCONNX
	ASSUME SB$B_SYSTEMID EQ	24
	.QUAD	0			; SB$B_SYSTEMID
	ASSUME SB$W_MAXDG EQ 32
	.LONG	0			; SB$W_MAXDG
					; SB$W_MAXMSG
	ASSUME SB$T_SWTYPE EQ 36
	.LONG	0			; SB$T_SWTYPE
	ASSUME SB$T_SWVERS EQ 40
	.LONG	0			; SB$T_SWVERS
	ASSUME SB$Q_SWINCARN EQ 44
	.QUAD	0			; SB$Q_SWINCARN
	ASSUME SB$T_HWTYPE EQ 52
	.LONG	0			; SB$T_HWTYPE
	ASSUME SB$B_HWVERS EQ 56
	.BLKB	12			; SB$B_HWVERS
	ASSUME SB$T_NODENAME EQ	68
	.BLKB	16			; SB$T_NODENAME
	ASSUME SB$L_DDB EQ 84
;
; SYSTEM DEVICE DATA BLOCK (DDB) LIST HEAD (NOTE: PART OF THE SB!!!)
;
IOC$GL_DEVLIST::
	.LONG	SYS$GL_BOOTDDB		; START DEVICE LIST AT BOOT DEVICE
					; SB$L_DDB

	ASSUME	SB$W_TIMEOUT EQ 88
	.WORD	-2			; LOOKS LIKE TIMEOUT IS IN PROGRESS
	ASSUME	SB$B_ENBMSK EQ 90
	.BLKB	SB$S_ENBMSK		; PROCESS POLL ENABLE MASK

	ASSUME	SB$L_CSB EQ 92
	.LONG	0			; SB$L_CSB

	.BLKB	SB$K_LENGTH-<.-SCS$GA_LOCALSB>	; SPACE FOR REMAINING FIELDS

	.BLKB	8			; Future expansion

	.SBTTL	SYSTEM BOOT DEVICE DATABASE
;
; BOOT DEVICE DDB
;
	DDB	SYS$GL_BOOTDDB,OPA$GL_DDB,SYS$GL_BOOTUCB,0,<F11>,1
;
; UCB FOR SYSTEM BOOT DEVICE
;

;
; NOTE - THE UCB FOR THE BOOT DEVICE IS CREATED WITH A REFERENCE COUNT OF 1
; TO AVOID HAVING THE FIRST $ASSIGN TRY TO TAKE OUT A LOCK ON IT BEFORE
; LOCKING IS ENABLED.
;
	ORB	SYS$GL_BOOTORB
		STO_ORB	L_OWNER,LONG,<^X010001>
	UCB	SYS$GL_BOOTUCB,40,SYS$GL_BOOTORB
		STO_UCB	B_FIPL,BYTE,8
		STO_UCB	B_DIPL,BYTE,21
		STO_UCB	L_DDB,LONG,SYS$GL_BOOTDDB
		STO_UCB	L_DEVCHAR,LONG,<<DEV$M_FOD!-
			DEV$M_DIR!-
			DEV$M_AVL!-
			DEV$M_ELG!-
			DEV$M_SHR!-
			DEV$M_IDV!-
			DEV$M_ODV!-
			DEV$M_RND>>
		STO_UCB	B_DEVCLASS,BYTE,DC$_DISK
		STO_UCB	W_DEVBUFSIZ,WORD,512
		STO_UCB	B_ERTCNT,BYTE,8
		STO_UCB	B_ERTMAX,BYTE,8
		STO_UCB	W_REFC,WORD,1
	

	.SBTTL	SYSTEM CONSOLE DEVICE DATABASE
;
; CONSOLE TERMINAL DDB
;
	DDB	OPA$GL_DDB,MB$GL_DDB,OPA$UCB0,,,0,<OPA>,<OPERATOR>
;
; CONSOLE DPT
;
;
; THE UCB SIZE INCLUDES 3 BYTES FOR ROUNDUP, AND 64 BYTES OF EXTRA
; SPACE TO ALLOW INCREASING UCB SIZE WITHOUT NEEDING TO BUILD A NEW
; SYS.
;
	.PSECT	$$$105_PROLOGUE,RD,WRT,BYTE	; Ensure OP$DPT label points to DPT
OP$DPT::
	.PSECT	$$$100,QUAD,WRT			; (DPTAB macro puts DPTAB in $$$105_prologue)
	DPTAB	-
		END=OP_DPTEND,-
		ADAPTER=UBA,-		;FAKE ADAPTER
		UCBSIZE=<<<UCB$C_TT_LENGTH+3+64>/4>*4>,-
		NAME=OPERATOR,-
		VECTOR=OPA$VECTOR

	DPT_STORE INIT
	DPT_STORE UCB,UCB$L_TT_DECHAR,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERISTICS
	DPT_STORE UCB,UCB$L_TT_DECHA1,@L,TTY$GL_DEFCHAR2
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR
	DPT_STORE UCB,UCB$L_TT_DEVDP1,@L,TTY$GL_DEFCHAR2
	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
	DPT_STORE UCB,UCB$B_DIPL,B,20			; DEVICE IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-; CHARACTERISTICS
			DEV$M_REC!-	;
			DEV$M_AVL!-	;
			DEV$M_IDV!-	;
			DEV$M_ODV!-	;
			DEV$M_TRM!-	;
			DEV$M_CCL>
    	DPT_STORE UCB,UCB$L_DEVCHAR2,L,-; DEVICE CHARACTERISTICS
    			<DEV$M_NNM>	; PREFIX WITH "NODE$"
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,132		; BUFFER SIZE
	DPT_STORE UCB,UCB$W_STS,W,UCB$M_ONLINE		; Device comes up online
	DPT_STORE UCB,UCB$W_TT_DESIZE,W,132		; BUFFER SIZE
	DPT_STORE UCB,UCB$W_TT_SPEED,W,TT$C_BAUD_300	; DEFAULT SPEED
	DPT_STORE UCB,UCB$B_TT_DETYPE,B,TT$_LA36	; TYPE
	DPT_STORE UCB,UCB$W_TT_DESPEE,W,TT$C_BAUD_300	;
	DPT_STORE ORB,ORB$B_FLAGS,B,-
				<ORB$M_PROT_16>		; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,@W,TTY$GW_PROT    	; Default protection
	DPT_STORE UCB,UCB$W_STS,W,UCB$M_ONLINE		; Device comes up online

	DPT_STORE REINIT				; Is this needed?
	DPT_STORE END

	.PSECT	$$$105_PROLOGUE,RD,WRT,BYTE		; Put OP_DPTEND label in correct psect
OP_DPTEND:

;
; CONSOLE PORT DISPATCH VECTOR.  THIS VECTOR IS USED BY THE TERMINAL CLASS
; DRIVER TO ACCESS PORT FUNCTIONS.  EACH ELEMENT IN THIS VECTOR POINTS
; TO A LOCATION IN SYSLOAVEC.  THIS MUST BE IN SAME PSECT AS OP$DPT TO
; GUARANTEE THAT A POSITIVE VECTOR OFFSET IS STORED IN DPT
;
OPA$VECTOR::
	$VECINI	OPA,CON$NULL
	$VEC	STARTIO,CON$STARTIO		; START ROUTINE
	$VEC	DISCONNECT,CON$DISCONNECT		; DISCONNECT ROUTINE
	$VEC	SET_LINE,CON$SET_LINE		; SET LINE ROUTINE
	$VEC	DS_SET,CON$DS_SET		; DATA SET ROUTINE
	$VEC	XON,CON$XON			; XON ROUTINE
	$VEC	XOFF,CON$XOFF		; XOFF ROUTINE
	$VEC	STOP,CON$STOP		; STOP ROUTINE
	$VEC	STOP2,CON$STOP2		; STOP2 ROUTINE
	$VEC	ABORT,CON$ABORT		; ABORT ROUTINE
	$VEC	RESUME,CON$RESUME		; RESUME ROUTINE
	$VEC	SET_MODEM,CON$SET_MODEM		; SET MODEM ROUTINE
	$VECEND

	.PSECT	$$$100,QUAD,WRT
;
; CONSOLE UCB
;
	ORB	OPA$ORB0
		STO_ORB	L_OWNER,LONG,<^X010001>
	UCB	OPA$UCB0,<<UCB$C_TT_LENGTH - UCB$C_LENGTH + 3 + 64> / 4>,OPA$ORB0
		STO_UCB	B_FIPL,BYTE,8
		STO_UCB	B_DIPL,BYTE,20
		STO_UCB	L_CRB,LONG,OPA$CRB
		STO_UCB	L_DDB,LONG,OPA$GL_DDB
		STO_UCB	L_DEVCHAR,LONG,<<DEV$M_REC!-
			DEV$M_AVL!-
			DEV$M_CCL!-
			DEV$M_TRM!-
			DEV$M_IDV!-
			DEV$M_ODV>>
    		STO_UCB L_DEVCHAR2,LONG,<<DEV$M_NNM>>
		STO_UCB	B_DEVCLASS,BYTE,DC$_TERM
		STO_UCB	B_DEVTYPE,BYTE,DT$_LA36
		STO_UCB	W_DEVBUFSIZ,WORD,132
		STO_UCB	W_STS,WORD,UCB$M_ONLINE
		STO_UCB	L_DEVDEPEND,LONG,<<TT$M_LOWER!TT$M_TTSYNC!TT$M_WRAP>>
		STO_UCB	L_DEVDEPEND+3,BYTE,24
		STO_UCB	W_TT_DESIZE,WORD,132
		STO_UCB	L_TT_DECHAR,LONG,<<TT$M_LOWER!TT$M_TTSYNC!TT$M_WRAP>>
		STO_UCB	L_TT_DECHAR+3,BYTE,24
		STO_UCB	W_TT_SPEED,WORD,TT$C_BAUD_300
		STO_UCB	B_TT_DETYPE,BYTE,TT$_LA36
		STO_UCB W_TT_DESPEE,WORD,TT$C_BAUD_300
;
; CONSOLE CRB
;
OPA$CRB::
	.LONG	0,0			;
	.WORD	CD-OPA$CRB		; SIZE
	.BYTE	DYN$C_CRB		; TYPE IS CRB
	.BYTE	0			; UNUSED
	.LONG	1			; REF COUNT=1 AND NEVER BUSY
	ASSUME	CRB$L_AUXSTRUC	EQ  16
	.LONG	0			; Auxiliary structure ptr.

	ASSUME	CRB$L_TIMELINK	EQ  20
	.LONG	0			; CRB thread for periodic wakeups.

	ASSUME	CRB$L_DUETIME	EQ  24
	.LONG	0			; Time when to periodically awaken

	ASSUME	CRB$L_TOUTROUT	EQ  28
	.LONG	0			; Routine to call at periodic awakening

	ASSUME	CRB$L_LINK	EQ  32
	.LONG	0			; NO NEXT CRB
CON$INTDISI::				;
	ASSUME	CON$INTDISI-OPA$CRB	EQ  CRB$L_INTD

	ASSUME	VEC$Q_DISPATCH	EQ  0
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	JSB	G^CON$INTINP		; INPUT INTERRUPT SERVICE

	ASSUME	VEC$L_IDB	EQ  8
	.LONG	OPA$IDB			; POINTER TO IDB

	ASSUME	VEC$L_INITIAL	EQ  12
	.LONG	CON$INITIAL		; INITIALIZE CONTROLLER ENTRY POINT

	ASSUME	VEC$W_MAPREG	EQ  16
	ASSUME	VEC$B_NUMREG	EQ  18
	ASSUME	VEC$B_DATAPATH	EQ  19
	.LONG	0			; MAP AND DATA PATH ALLOCATION CONTROL

	ASSUME	VEC$L_ADP	EQ  20
	.LONG	0			; ADDRESS OF ADP

	ASSUME	VEC$L_UNITINIT	EQ  24
	.LONG	CON$INITLINE		; INITIALIZE UNIT

	ASSUME	VEC$L_START	EQ  28
	.LONG	0			; UNUSED LONGWORD

	ASSUME	VEC$L_UNITDISC	EQ  32
	.LONG	0			; UNUSED LONGWORD
	ASSUME	VEC$K_LENGTH	EQ  36

CON$INTDISO::				;
	ASSUME	CON$INTDISO-OPA$CRB	EQ  CRB$L_INTD2

	ASSUME	VEC$Q_DISPATCH	EQ  0
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	JSB	G^CON$INTOUT		; OUTPUT INTERRUPT SERVICE
	.LONG	OPA$IDB			; POINTER TO IDB

	ASSUME	VEC$L_IDB	EQ  8
CD:
 
;
; CONSOLE IDB
;
OPA$IDB::
	ASSUME	IDB$L_CSR	EQ  0
	.LONG	0			; CSR ADDRESS

	ASSUME	IDB$L_OWNER	EQ  4
	.LONG	0			; OWNER UCB ADDRESS
	.WORD	ID-OPA$IDB		; SIZE OF IDB
	.BYTE	DYN$C_IDB		; TYPE OF STRUCTURE
	.BYTE	0			; UNUSED

	ASSUME	IDB$W_UNITS	EQ  12
	.WORD	5			; NUMBER OF UNITS
	.BYTE	0			; TT ENABLE
	.BYTE	0			; CSR OFFSET TO MAIN CSR FOR COMBO STYLE DEVICE

	ASSUME	IDB$B_COMBO_VECTOR_OFFSET EQ 16
	.BYTE	0			; VECTOR OFFSET TO MAIN VECTOR FOR COMBO STYLE DEVICE
	.BYTE	0			; UNUSED
	.WORD	0			; UNUSED

	ASSUME	IDB$L_ADP	EQ  20
	.LONG	0			; ADAPTER ADDRESS

	ASSUME	IDB$L_UCBLST	EQ  24
	.LONG	OPA$UCB0		; UNIT 0 UCB ADDRESS
	.LONG	0			; UNIT 1 UCB ADDRESS (FLOPPY)
	.LONG	0			; UNIT 1 INPUT UCB ADDRESS (FLOPPY)
	.LONG	0			; UNIT 3 USED BY VENUS ONLY
	.LONG	0			; UNIT 4 (RESERVED)
	.LONG	0			; UNIT 5 (RESERVED)
ID:

	.SBTTL	SYSTEM PERMANENT MAILBOX DATABASE
 
;
; MAILBOX DDB
;
	DDB	MB$GL_DDB,NL$GL_DDB,MB$GL_UCB1,MB$DDT,,0,<MBA>,<MBDRIVER>
;
; CLONE MAILBOX UCB
;
;
; NOTE THAT THIS UCB IS NOT IN THE DDB'S UCB LIST
;
	ORB	 MB$ORB0
		STO_ORB	L_OWNER,LONG,<^X010001>
	UCB	 MB$UCB0,0, MB$ORB0
		STO_UCB	W_MB_SEED,WORD,0
		STO_UCB	B_FIPL,BYTE,IPL$_MAILBOX
		STO_UCB	B_DIPL,BYTE,IPL$_MAILBOX
		STO_UCB	W_MSGMAX,WORD,20
		STO_UCB	W_BUFQUO,WORD,-1
		STO_UCB	L_CRB,LONG,SYS_CRB
		STO_UCB	L_DDB,LONG,MB$GL_DDB
		STO_UCB	L_LINK,LONG,MB$GL_UCB1
		STO_UCB	L_DEVCHAR,LONG,<<DEV$M_REC!-
			DEV$M_AVL!-
			DEV$M_IDV!-
			DEV$M_MBX!-
			DEV$M_ODV!-
			DEV$M_SHR>>
    		STO_UCB L_DEVCHAR2,LONG,<<DEV$M_NNM>>
		STO_UCB	B_DEVCLASS,BYTE,DC$_MAILBOX
		STO_UCB	B_DEVTYPE,BYTE,DT$_MBX
		STO_UCB	W_DEVBUFSIZ,WORD,256
		STO_UCB	W_REFC,WORD,1
		STO_UCB	W_UNIT,WORD,0
		STO_UCB	W_STS,WORD,UCB$M_ONLINE
		STO_UCB	W_DEVSTS,WORD,UCB$M_PRMMBX
		STO_UCB L_DDT,LONG,MB$DDT
MB$MB0_END:
SYS$C_MBXUCBSIZ	==	<MB$MB0_END - MB$UCB0>

;
; SYSTEM JOB CONTROLLER MAILBOX
;
SYS$GL_JOBCTLMB::			
SYS$C_JOBCTLMB==^A/MBA1/
	UCB	 MB$GL_UCB1,0, MB$GL_ORB1
		STO_UCB L_FQFL,LONG,MB$GL_UCB1
		STO_UCB L_FQFL+4,LONG,MB$GL_UCB1
		STO_UCB	B_FIPL,BYTE,IPL$_MAILBOX
		STO_UCB	B_DIPL,BYTE,IPL$_MAILBOX
		STO_UCB	W_MSGMAX,WORD,60
		STO_UCB	W_BUFQUO,WORD,-1
		STO_UCB	L_CRB,LONG,SYS_CRB
		STO_UCB	L_DDB,LONG,MB$GL_DDB
		STO_UCB	L_LINK,LONG,MB$GL_UCB2
		STO_UCB	L_DEVCHAR,LONG,<<DEV$M_REC!-
			DEV$M_AVL!-
			DEV$M_MBX!-
			DEV$M_IDV!-
			DEV$M_ODV!-
			DEV$M_SHR>>
    		STO_UCB L_DEVCHAR2,LONG,<<DEV$M_NNM>>
		STO_UCB	B_DEVCLASS,BYTE,DC$_MAILBOX
		STO_UCB	W_DEVBUFSIZ,WORD,1024
		STO_UCB	W_REFC,WORD,1
		STO_UCB	W_UNIT,WORD,1
		STO_UCB	W_STS,WORD,UCB$M_ONLINE
		STO_UCB	W_DEVSTS,WORD,<UCB$M_PRMMBX+^X08000>
		STO_UCB L_DDT,LONG,MB$DDT
	ORB	 MB$GL_ORB1
		STO_ORB	L_OWNER,LONG,<^X010004>
		STO_ORB	W_PROT,WORD,<^X0FF0F>
;
; SYSTEM OPERATOR MAILBOX
;
SYS$GL_OPRMBX::
SYS$C_OPRMBX==^A/MBA2/
	UCB	 MB$GL_UCB2,0, MB$GL_ORB2
		STO_UCB L_FQFL,LONG,MB$GL_UCB2
		STO_UCB L_FQFL+4,LONG,MB$GL_UCB2
		STO_UCB	B_FIPL,BYTE,IPL$_MAILBOX
		STO_UCB	B_DIPL,BYTE,IPL$_MAILBOX
		STO_UCB	W_MSGMAX,WORD,20
		STO_UCB	W_BUFQUO,WORD,-1
		STO_UCB	L_CRB,LONG,SYS_CRB
		STO_UCB	L_DDB,LONG,MB$GL_DDB
		STO_UCB	L_DEVCHAR,LONG,<<DEV$M_REC!-
			DEV$M_AVL!-
			DEV$M_MBX!-
			DEV$M_IDV!-
			DEV$M_ODV!-
			DEV$M_SHR>>
    		STO_UCB L_DEVCHAR2,LONG,<<DEV$M_NNM>>
		STO_UCB	B_DEVCLASS,BYTE,DC$_MAILBOX
		STO_UCB	W_DEVBUFSIZ,WORD,2560
		STO_UCB	W_REFC,WORD,1
		STO_UCB	W_UNIT,WORD,2
		STO_UCB	W_STS,WORD,UCB$M_ONLINE
		STO_UCB	W_DEVSTS,WORD,UCB$M_PRMMBX
		STO_UCB L_DDT,LONG,MB$DDT
	ORB	 MB$GL_ORB2
		STO_ORB	L_OWNER,LONG,<^X010004>
		STO_ORB	W_PROT,WORD,<^X0FF0F>

	.SBTTL	NULL DEVICE (NLA) DATABASE
;
; NLA DDB
;
	DDB	NL$GL_DDB,0,NL$GL_UCB0,NL$DDT,,0,<NLA>,<NLDRIVER>
 
;
; NL UCB FOR UNIT 0
;
	ORB	 NL$GL_ORB0
		STO_ORB	L_OWNER,LONG,<^X010001>
	UCB	 NL$GL_UCB0,0, NL$GL_ORB0
		STO_UCB	B_FIPL,BYTE,8
		STO_UCB	B_DIPL,BYTE,8
		STO_UCB	L_CRB,LONG,SYS_CRB
		STO_UCB	L_DDB,LONG,NL$GL_DDB
		STO_UCB	L_DEVCHAR,LONG,<<DEV$M_REC!-
			DEV$M_AVL!-
			DEV$M_MBX!-
			DEV$M_IDV!-
			DEV$M_ODV!-
			DEV$M_SHR>>
		STO_UCB	B_DEVCLASS,BYTE,DC$_MAILBOX
		STO_UCB	B_DEVTYPE,BYTE,DT$_NULL
		STO_UCB	W_DEVBUFSIZ,WORD,512
		STO_UCB	W_REFC,WORD,1
		STO_UCB	W_UNIT,WORD,0
		STO_UCB	W_STS,WORD,UCB$M_ONLINE
		STO_UCB L_DDT,LONG,NL$DDT

	.SBTTL	NETWORK DEVICE DATABASE
;
; NETWORK DEVICE DATA BLOCK
;
;
; NETWORK WINDOW CONTROL BLOCK - SHARED BY ALL UCB'S
;
NET$WCB::
	.LONG	0			; WLFL
	.LONG	0			; WLBL
	.WORD	10$-NET$WCB		; SIZE
	.BYTE	DYN$C_WCB		; CALL IT A WCB

	ASSUME	WCB$B_ACCESS	EQ  11
	.BYTE	0			; ACCESS BITS

	ASSUME	WCB$L_PID	EQ  12
	.LONG	0			; PID

	ASSUME	WCB$L_ORGUCB	EQ  16
	.LONG	0			; ORGUCB

	ASSUME	WCB$W_ACON	EQ  20
	ASSUME	WCB$W_NMAP	EQ  22
	.LONG	0			; ACON AND NMAP

	ASSUME	WCB$L_FCB	EQ  24
	.LONG	0			; FCB

	ASSUME	WCB$L_RVT	EQ  28
	.LONG	0			; RVT

	ASSUME	WCB$L_LINK	EQ  32
	.LONG	0			; LINK

	ASSUME	WCB$L_READS	EQ  36
	.LONG	0			; READS EXECUTED

	ASSUME	WCB$L_WRITES	EQ  40
	.LONG	0			; WRITES EXECUTED

	ASSUME	WCB$L_STVBN	EQ  44
	.LONG	0			; ACCESS LOCK ID
	ASSUME	WCB$K_LENGTH	EQ  48
10$:
 
;
; COMMON CRB FOR MAILBOX TYPE DEVICES
;
SYS_CRB:				;
	.LONG	0,0			; CRB LIST HEAD
	.WORD	10$-SYS_CRB		; SIZE
	.BYTE	DYN$C_CRB		; TYPE
	.BYTE	0			; SPARE BYTE
	.LONG	0			; REF COUNT
	ASSUME	CRB$L_AUXSTRUC	EQ  16
	.LONG	0			; Auxiliary structure ptr.

	ASSUME	CRB$L_TIMELINK	EQ  20
	.LONG	0			; CRB thread for periodic wakeups.

	ASSUME	CRB$L_DUETIME	EQ  24
	.LONG	0			; Time when to periodically awaken

	ASSUME	CRB$L_TOUTROUT	EQ  28
	.LONG	0			; Routine to call at periodic awakening

	ASSUME	CRB$L_LINK	EQ  32
	.LONG	0			; NO NEXT CRB

	ASSUME	.-SYS_CRB	EQ  CRB$L_INTD
	ASSUME	VEC$Q_DISPATCH	EQ  0
	.LONG	0,0			; NO INTERRUPT VECTOR

	ASSUME	VEC$L_IDB	EQ  8
	.LONG	SYS_CRB			; POINTER TO FAKE IDB

	ASSUME	VEC$L_INITIAL	EQ  12
	ASSUME	VEC$W_MAPREG	EQ  16
	ASSUME	VEC$B_NUMREG	EQ  18
	ASSUME	VEC$B_DATAPATH	EQ  19
	ASSUME	VEC$L_ADP	EQ  20
	ASSUME	VEC$L_UNITINIT	EQ  24
	ASSUME	VEC$L_START	EQ  28
	ASSUME	VEC$L_UNITDISC	EQ  32
	.LONG	0,0,0,0,0,0		; NO INITIALIZATION FOR CONTROLLER OR UNIT

	ASSUME	VEC$K_LENGTH	EQ  36

10$:
	ASSUME	10$-SYS_CRB	EQ  CRB$L_INTD2
	.END
