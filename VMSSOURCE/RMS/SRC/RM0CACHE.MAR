	$BEGIN	RM0CACHE,000,RM$RMS0,<IO CACHE ROUTINE>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
;
; Facility: rms32
;
; Abstract:
;
;	This module provides a block cache and access control
;	to the buckets of the relative and indexed file organizations
;
; Environment:
;	VAX/VMS
;
; Author: E.H. Marison	15-SEP-1977
;
; Modified By:
;
;	V03-023	JEJ0044		J E Johnson		21-Jun-1984
;		Tweak the instructions a little for a performance boost.
;
;	V03-022	SHZ0011		Stephen H. Zalewski,	30-Apr-1984
;		If we stall in CACHE, do not set the event flag unless it
;		is nonzero.  In async I/O case it will be zero.
;
;	V03-021	JEJ0007		J E Johnson		16-Mar-1984
;		Add global buffer quota accounting to limit the number of
;		system-wide locks taken out by the users.
;
;	V03-020	SHZ0010		Stephen H. Zalewski,	13-Mar-1984
;		Make sure we are record locking before we try to scan
;		the BLB list in RM$FREE_LCL.  Thus, in the case of
;		the local buffer count being wrong, we will not
;		try to scan the BLB list to try and free up a BDB.
;
;	V03-019	JWT0160		Jim Teague		29-Feb-1984
;		Remove call to RM$DEALLEFN.
;
;	V03-018	SHZ0009		Stephen H. Zalewski	26-Jan-1984
;		If we must stall waiting for a writeback to occur on
;		a blb we want to throw out of cache, we must set the
;		event flag after the stall, or we wait forever on the flag.
;
;	V03-017	SHZ0008		Stephen H. Zalewski	5-Dec-1983
;		If we stall waiting for a writeback to occur, set the
;		event flag after the stall has completed, or we will
;		wait forever on the event flag to be set.
;
;	V03-016	KPL0001		Peter Lieberwirth	28-Oct-1983
;		Fix problem with BI journaling.  Before-image copy of
;		the buffer was only made if the buffer was read in with
;		intent to write.  However, if the buffer was cached for
;		read, and is found in the cache to write out, no before
;		image copy was made.
;
;		This fix unconditionally copies the before-image of the
;		bucket to the before-image buffer - read or write.  While
;		this is good enough for FT1, it should be changed for FT2
;		such that the copy is only made when the bucket is to be
;		dirtied.  The CPU performance consequences of failing to
;		do so would be high.
;
;	V03-015	SHZ0007		Stephen H. Zalewski	17-Oct-1983
;		After finding or obtaining a buffer in a global buffer
;		cache, do not lower lock on section until the user count
;		in the GBD has been incremented.  This prevents a window
;		where 2 accessors point to the same GBD, but each thinks it
;		contains a different VBN.
;
;		After finding a buffer to throw out of a global buffer cache,
;		mark the sequence number invalid to prevent a second process
;		from thinking the buffer valid while first process does the io.
;
;	V03-014	DAS0001		David Solomon		18-Oct-1983
;		Restore lost BI journaling code.
;
;	V03-013	SHZ0006		Stephen H. Zalewski	28-Jul-1983
;		Modify to allow cluster global buffers.
;
;	V03-012	SHZ0005		Stephen H. Zalewski	17-Apr-1983
;		Add cluster failover capability for bucket locking.
;
;	V03-011	TMK0001		Todd M. Katz		02-Apr-1983
;		Add support for BI Journalling of ISAM files. Whenever, an
;		ISAM file is marked for BI Journalling, and an EXclusive lock
;		has been requested on a bucket, then move the contents of the
;		bucket (before they are potentially modified) into the buffer 
;		controlled by the BI BDB associated with the BDB that is about
;		to be returned. Also modify the routines within this module
;		so that the cache flags within R3 are not destroyed. This is 
;		because they will be needed to decide whether to save the
;		bucket or not.
;
;	V03-010	SHZ0004		Stephan H. Zalewski,	11-Feb-1983
;		Update the VBN sequence number of a buffer if the NOREAD
;		flag is set in the BLB.
;
;	V03-009	KBT0446		Keith B. Thompson	5-Dec-1982
;		Fix a case where the gbsb lock was not being released
;
;	V03-008	SHZ0003		Stephen H. Zalewski,	22-Sep-1982  13:49
;		Take EXCLUSIVE lock on Global buffer cache when searching
;		for a buffer, or updating the position of a buffer in the
;		cache.
;
;	V03-007	SHZ0002		Stephen H. Zalewski,	6-Sep-1982  20:18
;		Use the interlocked self-relative queue instructions when
;		placing and removing GBDs.
;
;	V03-006	KBT0200		Keith B. Thompson	23-Aug-1982
;		Reorganize psects
;
;	V03-005	SHZ0001		Stephen H. Zalewski,	29-Jun-1982  15:38
;		When forcing the writeback of a BLB, make sure the IFAB is
;		not one from a $OPEN command.  If it is, do not attempt to
;		write the BLB back.
;
;	V03-004	CDS0028		C Saether		13-Apr-1982
;		Modify lock_bkt routine to attempt to toss something
;		out of the local cache when the enq results in
;		either an exenqlm or nolockid error.  Hopefully this
;		frees up a lock so the operation can continue.
;
;	V03-003	CDS0027		C Saether		30-Mar-1982
;		Correct problem when LOCK, NOREAD, NOBUFFER is
;		specified for a bucket which is already accessed
;		with a buffer.  This was causing the new flags to
;		overwrite those from the initial access and not
;		store the value block on release.
;
;		Set default error in R1 before call to MAPERR.
;		Increment use count in GBD only after GBPB accessed.
;
;		Check if BDB was present before looking at it.
;
;	V03-002	CDS0026		C Saether		22-Mar-1982
;		Modify SCAN_GBL routine to avoid end test and speed
;		up by looping in line.
;
;	V03-001	CDS0025		C Saether		 1-Mar-1982
;		Count hits and misses for global buffers.
;		Fix incorrect register use in SCAN_LOCKS checking
;		for GBPB.
;							26-Feb-1982
;		Don't bother trying to get read locks on buckets in
;		a compatible mode.  It causes conversion deadlock
;		problems when other streams (processes) are attempting
;		to modify the same bucket simultaneously.  This is
;		the same problem only partially corrected in V02-036.
;		Also have LOCK_BKT routine call RM$MAPERR to map
;		enqueue failures to RMS errors if appropriate.
;							16-Feb-1982
;		Changes to allow modification of global buffers.
;		FREE_LCL and GET_LCL_BUFF become RM$FREE_LCL and
;		RM$GET_LCL_BUFF.
;		SCAN_LOCKS changed to not return GBPB address unless
;		caller already owns it (don't want more than one
;		accessor on a GBPB at once).
;		Don't try to use global buffers if stream didn't
;		connect for them.
;							 7-Feb-1982
;		Shorten scan_local_cache to scan_lcl_cache.
;
;--
;


	.SBTTL	DECLARATIONS

;
; Include Files:
;

	$BDBDEF				; bucket descriptor blocks
	$BKTDEF				; bucket definitions
	$BLBDEF				; bucket lock blocks
	$CSHDEF				; rm$cache flag definitions
	$ENQDEF				; enq sys service definitions
	$GBDDEF				; global buffer descriptor defs
	$GBHDEF				; global buffer header
	$GBPBDEF			; global buffer pointer block defs
	$IFBDEF				; ifab defs
	$IMPDEF				; impure area definitions
	$IRBDEF				; irab defs
	$LCKDEF				; lock manager flags, constant defs
	$PIODEF				; process i/o definitions
	$RABDEF				; record access block
	$RJRDEF				; RMS Journalling Record definitions
	$RLSDEF				; rm$release flags
	$RMSDEF				; rms error code defs
	$SFSBDEF			; shared file lock block defs
	$SSDEF				; System service error codes

;
; Macros:
;
;
; Equated Symbols:
;

CSH_MASK_ALL	=	CSH$M_LOCK!CSH$M_NOWAIT!CSH$M_NOREAD!CSH$M_NOBUFFER

;
; Own Storage:
;


	.SBTTL	RM$CACHE ROUTINE

;++
;
; RM$CACHE - access and read bucket if necessary
;
;    1.	obtains access to requested block/bucket and waits for the access 
;	unless csh$v_nowait is set in the control flags.
;
;    2. obtains a buffer for the block unless csh$v_nobuffer
;	is set in the control flags.
;
;    3.	if there is a buffer read the block into it if required, and the 
;	csh$v_noread bit is off in the control flags.
;
;    4.	waits for io completion
;
;    5.	if the csh$v_lock bit is set in the flags then exclusive access to the 
;	block is obtained.
;
; Calling sequence:
;
;	BSBW	RM$CACHE
;
; Input Parameters:
;
;	r11	impure area address
;	r10	ifab address
;	r9	irab/ifab address
;	r8	rab/fab address
;	r3	cache control flags
;	r2	transfer/buffer size in bytes
;	r1	requested vbn
;
; Output Parameters:
;
;	r0	internal rms status code
;	r4	bdb address
;	r5	buffer address unless a nobuffer call
;		in which case r5 is destroyed
;	r1,r2,r3,ap destroyed
;
; ****	bdb and buffer not accessed on errors
;
; Completion Codes:
;
;	standard internal rms, including:
;
;		suc	normal success
;		rlk	block was accessed or locked and nowait
;		dme	could not get a buffer
;		exenqlm	the enq limit for this process was exceeded
;			while attempting to lock a bucket.
;		various errors writing a deferred write buffer or reading
;		in the new buffer.
;
; Side Effects:
;
; 	May have switched to running at ast level if not already there as
;	a result of stalling for i/o to complete or waiting for a
;	resource to be granted.
;
;--

TRACE:
	JSB	RM$CACH_IN
	BSBB	CACHE
	JSB	RM$CACH_OUT
	RSB

BUFF_ONLY_BR:
	BRW	BUFF_ONLY		; No lock - only want scratch buffer.

RM$CACHE::
	NOP				; Patch this for tracing.
	NOP

CACHE:	TSTL	R1			; Is this VBN 0 call?
	BEQL	BUFF_ONLY_BR		; EQL then only want buffer, no lock.

	BBC	#CSH$V_NOBUFFER, R3,-	; Branch if buffer is desired.
		NEED_BUFFER
	BBC	#CSH$V_NOREAD, R3, 17$	; Expectation is that NOREAD is set.


;
; If here, this is a nobuffer request, meaning that a lock only on the
; bucket is desired.  This type of lock will be requested to interlock
; an extend type operation with other processes sharing the file.  If
; the file is open for exclusive access, nothing further is required.
;

10$:	BBC	#IFB$V_NORECLK, (R10), 20$ ; Branch if locking req'd.
	BSBW	SCAN_LCL_CACHE		; Is it already in cache?
	MOVL	R5, R4			; See if it is.
	BEQL	15$			; Nope.  Just return.
	MOVW	#1, BDB$W_USERS(R4)	; Make it look accessed.
15$:	RMSSUC				; Success.
	RSB				; Return.

17$:	RMSPBUG	FTL$_NORDNOTSET		; NOREAD is not set and no buff wanted.

20$:	BSBW	SCAN_LOCKS		; See if lock is already held.
	BLBC	R0, 30$			; Branch if lock not found.
	TSTL	R5			; Is there a BDB also?
	BEQL	15$			; Already have lock.  All done then.

;
; Note that finding a buffer in the cache on a nobuffer call and simply
; accessing the buffer along with the lock violates the assumptions about
; the worst case condition where two buffers plus a lock only on another
; bucket are required.  However, given the current use of the nobuffer call
; for vbn 1, and the sequence of operations used, it would not be possible
; for vbn 1 to be in the cache at the time of the nobuffer call because
; the two buffers would be occupied by the bucket being split and the area
; descriptor already.  With two streams, it is difficult to construct a
; sequence of events where block 1 could happen to be in the cache at the
; time two streams were extending separate areas during separate splits
; such that the problem would actually arise.
;
; The logic which initializes an index will call CACHE for a lock, nobuffer
; on VBN 1 when VBN 1 is already accessed with a buffer.  In that case,
; the owner will be the current stream.  The address of the BDB (as opposed
; to the BLB) must be returned in that case because the routine compares
; the original BDB address from the first call (saved in IRB$L_LOCK_BDB)
; with the return from this call to determine whether to release the lock.
; Pretty tacky, but that's the way it is.  No checks are made to determine
; if the bucket is LOCKed when one is found, as it is not believed any routines
; would do that and follow it with a LOCK, NOBUFFER call.
;

	CMPL	BLB$L_OWNER(R4), R9	; This stream already have it accessed?
	BNEQ	25$			; NEQ, then go access it normally.
	MOVL	R5, R4			; Get BDB addr into R4.
	BRB	15$			; And exit with success.
25$:	BICL2	#CSH$M_NOBUFFER!CSH$M_NOREAD, R3 ; There already is a buffer.
	BRW	LOCK_IT			; Raise mode if req'd.

30$:	BSBW	GET_BLB			; Get a BLB for this lock.
	BSBW	LOCK_BKT		; Go lock it.
	RSB				; Return.

;
; Got the bucket locked, but no buffer with it.
;

NEED_BUFFONLY:
	DECW	IFB$W_AVLCL(R10)	; Decrement available count.
	BGEQ	GET_BUFF		; Enough buffers, go get BDB.
	BSBW	RM$FREE_LCL		; Free up a local buffer.
	BLBS	R0, GET_BUFF		; Branch and go use it on success.
	INCW	IFB$W_AVLCL(R10)	; Restore count.
	RSB				; Return with error in R0.

NEED_BUFFER:
	BBS	#IFB$V_NORECLK, (R10),-	; Branch if no locking.
		NOLOCKING

;
; Locking is being done.  Scan list of buffer lock blocks (BLB's) to
; determine if bucket already has lock.  Normally locating a bucket in
; the BLB list means that either a NL or PW lock is held on a buffer
; currently present in the local cache.
;
; Under some conditions a request is made for a lock with buffer on a
; bucket which was previously locked with the NOBUFFER flag, in which
; case a lock will be found with no BDB.
;
; Lastly, a BDB for the desired bucket may be found, but no BLB.
; This will occur when multi-streaming and another stream has the
; desired bucket accessed.  Only a BLB must be acquired in this case.
;

CHECK_LOCKS:
	BSBW	SCAN_LOCKS		; See if lock already held.
	BLBC	R0, NEED_BLB		; No - go to get BLB.
	TSTL	R5			; Was there a BDB also with the BLB?
	BEQL	NEED_BUFFONLY		; Go get a buffer for the BLB.
	BRW	CHKWBK			; Have BDB, BLB, so access them.
NEED_BLB:
	TSTL	IFB$L_GBH_PTR(R10)	; Global buffer cache present?
	BEQL	LOCAL			; EQL then there is none.

;
; Global buffer cache is present.  If a BDB has already been found, though,
; always use it.  It didn't have a BLB if here, meaning another stream
; must currently have it accessed, therefore it has a much better chance
; of being valid.
;

	TSTL	R5			; Is BDB already present?
	BNEQ	LOCAL			; NEQ then use it.

	ASSUME	IRB$B_BID	EQ	IFB$B_BID
	ASSUME	<IRB$C_BID & 1>	EQ	0
	ASSUME	<IFB$C_BID & 1>	EQ	1

	BLBS	IFB$B_BID(R9), LOCAL	; Use local if ifab operation.
	BBC	#IRB$V_GBLBUFF, (R9), LOCAL ; Use local if stream did not
					; want global buffs when connecting.

;
; Search global cache, if failure the gbsb lock is not released since it may
; be needed shortly in find_free_gbl.  If success the lock is released.
;

	BSBW	SCAN_GBL		; Search global cache
	BLBS	R0, 10$			; Branch if got a match and use it.

;
; Did not find the desired bucket in the global cache.
; If a lock is not requested, attempt to get a global buffer and use it.
; If a lock is requested, use a local buffer.  The belief is that if
; the bucket wasn't already in the global cache, this must be a new
; insert, therefore the chance of another process potentially having
; an interest in it is very low.  In addition, if deferred write is
; enabled, modified global buffers must be copied to a local buffer
; when they are released.  The extra cpu overhead to do that would
; outweigh the rare instances where an i/o would be saved because
; another process was interested in the same bucket.
;

	ASSUME	CSH$V_LOCK	EQ	0

	BLBC	R3, 10$			; Br to use gbl if not locking.
	BSBW	RM$LOWER_GBS_LOCK	; Release lock on gbsb (taken in scan_gbl)
	CLRL	R5			; Note that no buffer is present.
	BRB	LOCAL			; Go use local buffer.

;
; We wish to use global buffers.  R0 contains the status from the global
; cache scan above.   Whether or not the requested bucket was found, we
; will need a blb.  In the rare case where a global buffer cannot be freed
; when the desired bucket was not located, reset the owner and vbn fields of
; the blb just obtained, and drop through to use a local buffer instead.
;

10$:	BSBW	GET_BLB			; Get a free BLB for the lock.
	BLBS	R0, GOT_BUFF		; Branch if match found in gbl cache -
					; R0 is the result from SCAN_GBL here.
	BSBW	FIND_FREE_GBL		; Attempt to find a free global buffer.
	BLBS	R0, NEED_READ		; Br to force read if one found.
	ASSUME	<BLB$L_OWNER + 4> EQ BLB$L_VBN
	CLRQ	BLB$L_OWNER(R4)		; Free up BLB.  Drop thru to use local.

;
; A local buffer is to be used.
; If R5 is non-zero, it contains the address of the BDB for the requested
; bucket even though a BLB must be obtained.
;

LOCAL:
	DECW	IFB$W_AVLCL(R10)	; Decrement available count.
	BGEQ	10$			; Got enough - go get BLB.
	INCW	IFB$W_AVLCL(R10)	; Put count back - will go round again.
	BSBW	RM$FREE_LCL		; Free up a buffer.
	BLBC	R0, EXBR		; Exit on error.
	BBS	#IFB$V_MSE, (R10),-	; If multi-streaming, need to scan
		CHECK_LOCKS		; locks again (may have changed).
	DECW	IFB$W_AVLCL(R10)	; Dec count.  One is available now.
10$:	BSBW	GET_BLB			; Get a free BLB.
	TSTL	R5			; Is there a BDB already?
	BNEQ	GOT_BUFF		; NEQ already have one.
GET_BUFF:
	BSBW	RM$GET_LCL_BUFF		; Get a free BDB.
	BBS	#IFB$V_NORECLK, (R10),-	; Branch if not locking.
		READ_NOLOCKING
NEED_READ:
	BISB2	#BLB$M_IOLOCK,-		; Know that I/O will be req'd.
		BLB$B_BLBFLGS(R4)
GOT_BUFF:
	MOVL	R5, BLB$L_BDB_ADDR(R4)	; Store BDB address in BLB.
	BRB	LOCK_IT			; Go to lock code.

;
; Branch here when using local buffers in exclusive mode, i.e., no locking
; is being performed.
;

NOLOCKING:
	BSBW	SCAN_LCL_CACHE		; Look in local cache.
	MOVL	R5, R4			; Anticipate suc - load R4 with BDB.
	BNEQ	10$			; NEQ we have a buffer.
	BRW	NEED_BUFFONLY		; Need to go get a buffer.

;
; We have found the desired bucket in the local cache when no locking
; is required.  The bucket must be valid, therefore simply return
; with success.
;

10$:	RMSSUC				; Set success.
	INCW	BDB$W_USERS(R4)		; Note in use.
	BRB	SETR5			; Branch to set R5 and exit.

;
; Branch here after getting buffer when no locking.
;

READ_NOLOCKING:
	INCW	BDB$W_USERS(R5)		; Note in use.
	BRB	READ_BKT		; Go read bucket - no lock req'd.

EXBR:	BRW	EXIT

;
; Check for possible writeback errors.  This is only branched to after
; finding a lock with bdb (i.e., cached).  A similar check is made in
; the RM$FREE_LCL routine.
;

WBKERR:	MOVZWL	BDB$L_IOSB(R5), RAB$L_STV(R8) ; Store i/o error code.
	RMSERR	WER			; Note error with RMS code.
	RSB				; And return.
CHKWBK:	BBCC	#BDB$V_AST_DCL,-	; Branch if no writeback has been done.
		BDB$B_FLGS(R5), LOCK_IT
	BLBC	BDB$L_IOSB(R5), WBKERR	; Branch if error occured.

;
; At this point:
;	R3 = CSH flags
;	R4 = BLB
;	R5 = BDB
;

LOCK_IT:
	INCW	BDB$W_USERS(R5)		; Bump user count.
	MOVL	BDB$L_BLB_PTR(R5), R0	; Other BLB's already?
	BNEQ	10$			; NEQ there are others.
	MOVL	R4, BDB$L_BLB_PTR(R5)	; Point from BDB to our BLB.
	BRB	20$			; Branch to lock bucket.
10$:	CMPL	R0, R4			; Is this us?
	BEQL	20$			; EQL then yes it is.
	REMQUE	(R4), R4		; Remove from current position in list.
	INSQUE	(R4), (R0)		; Insert after BLB pointed to.
20$:	BSBW	LOCK_BKT		; Acquire bucket lock
	BLBC	R0, ERREX1		; Exit on error

	BBC	#BLB$V_NOREAD,BLB$B_BLBFLGS(R4),30$ ; All done if read not req'd
	MOVL	BLB$L_VALSEQNO(R4),-	; It is valid, so update sequence
		BDB$L_VBNSEQNO(R5)	; number from value block.
	BRB	40$			; And branch to exit with success.

30$:	BBSC	#BLB$V_IOLOCK,-		; Know bucket must be read in if set.
		BLB$B_BLBFLGS(R4), 50$	; Clear so it doesn't remain set.
	CMPL	BLB$L_VALSEQNO(R4),-	; Compare lock value number with
		BDB$L_VBNSEQNO(R5)	; BDB sequence number.
	BNEQ	50$			; NEQ cached copy is invalid.
40$:
	MOVL	R5, R4			; Set address of BDB into R4.
	RMSSUC				; Note success
	BRB	SETR5			; Branch to exit.

;
; Bucket must be read because sequence numbers don't match, meaning the
; cached copy is invalid, or because the iolock bit is set, meaning this
; bucket is just being faulted into the cache.
;

50$:	MOVL	BLB$L_VALSEQNO(R4),-	; Update BDB copy of sequence num
		BDB$L_VBNSEQNO(R5)	; assuming success.  BDB will be deq'd
					; on errors.
READ_BKT:
	MOVL	R5, R4			; Get BDB/GBPB addr into R4 for read.
	PUSHL	R3			; save cache flags over call
	BSBW	RM$RDBUFWT		; Read in the bucket.
	POPL	R3			; restore cache flags over call
	BLBC	R0, ERREX		; Branch on error.
SETR5:
	MOVL	BDB$L_ADDR(R4), R5	; Buffer address into R5.
   	CMPB	#BDB$C_BID,BDB$B_BID(R4); If this is not a BDB
	BNEQ	EXIT			;  then return.

;
; If this is an ISAM file marked for BI Journaling, and if an EXclusive lock
; has been requested for the bucket that is about to be returned, then move
; the contents of the bucket (before they are potentially modified) into the
; buffer controlled by the BI BDB associated with the BDB that is about to be
; returned.
;
; ** Actually make the copy whether EX or not.  If bucket accessed for read
; ** and later upgraded to write, journaling failed because no before-image
; ** was in the buffer.  Improve performance here for FT2 as in note in
; ** revision history.

10$:
;	blbc	r3,20$			; branch if EX lock not requested
	BBC	#IFB$V_BI,-		; branch if file is not marked for 
		IFB$B_JNLFLG(R10),20$	; BI Journaled
	CMPB	#IFB$C_IDX,-		; branch if file is not an index file
		IFB$B_ORGCASE(R10)	; otherwise set up to save bucket before
	BNEQ	20$			; it is modified

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; save registers over move
	MOVZWL	BDB$W_NUMB(R4),R0	; move the entire bucket
	MOVL	BDB$L_BI_BDB(R4),R4	; retrieve address of BI Journaling BDB
	beql	15$			; skip if none, too early
	ADDL3	#RJR$C_BKTLEN,-		; position within the BI Journaling 
		BDB$L_ADDR(R4),R4	; record to where the saved bucket goes
	MOVC3	R0,(R5),(R4)		; save the un-modified bucket
15$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; restore the saved registers

20$:	REMQUE	(R4), R4		; Take out of current position.
	INSQUE	(R4), IFB$L_BDB_FLNK(R10) ; And stick it up front.
EXIT:
	RSB				; Done
ERREX:
	MOVL	#RLS$M_DEQ, R3		; Force complete release of buffer.
ERRX:	PUSHL	R0			; Save the error code.
	MOVL	R5, R4			; BDB/GBPB addr into R4 for release.
	BSBW	RM$RELEASE		; And release the buffer.
	POPL	R0			; Restore error code.
	RSB				; And Return.

ERREX1:	CMPW	#RMS$_RLK&^XFFFF, R0	; Was it not queued? (nowait was set)
	BNEQ	ERREX			; NEQ, it was something else.
	TSTL	BLB$L_LOCK_ID(R4)	; Was this already locked?
	BEQL	ERREX			; EQL no so DEQ entirely.
	CLRL	R3			; No need to DEQ then.
	BRB	ERRX			; Br to release it.

	.SBTTL	BUFF_ONLY path.
BUFF_ONLY:

;
; Always use local buffer for scratch buffer.
;

	DECW	IFB$W_AVLCL(R10)	; Note use of local buffer.
	BGEQ	10$			; GEQ if have enough.
	BSBW	RM$FREE_LCL		; Free up a buffer.
	BLBS	R0, 10$			; Branch if success.
	INCW	IFB$W_AVLCL(R10)	; Restore count.
	RSB				; Return with error in R0.
10$:
	BSBW	RM$GET_LCL_BUFF		; Go get a free buffer.
	INCW	BDB$W_USERS(R5)		; Note in use.
	MOVL	R5, R4			; Return BDB addr in R4.
	RMSSUC				; Note success.
	BRB	SETR5			; Set R5 and return.

	.SBTTL	SCAN_LOCKS Search BLB list for BLB.
;++
;
;	SCAN_LOCKS
;
;	Scan BLB list for match on desired vbn.  If BDB for that
;	vbn is found, note BDB address.  If BLB free or this stream
;	owns it, then note that also.
;	GBPB's are only reported if this stream already has it
;	accessed.  (Only 1 GBPB per accessor, ever).
;
; Calling sequence:
;
;	BSBW	SCAN_LOCKS
;
; Input Parameters:
;
;	R1 - VBN of bucket desired
;	R3 - CSH flags.
;	R9 - IFAB/IRAB address
;	R10 - IFAB
;	  IFB$L_BLBFLNK - listhead for BLB list
;
; Output Parameters:
;
;	R0 - success if non-accessed BLB or BLB owned by this
;		stream is found.
;	   - failure otherwise.
;
;	R4 - BLB address if R0 success, undefined otherwise.
;
;	R5 - BDB address of BDB for bucket R1 if any present, regardless
;		of R0 status.  Zero if no BDB for bucket R1 at all.
;	     GBPB address only if this stream currently has it accessed.
;
; Side effects:
;
;	If existing deferred writeback buffer accessed for a locker,
;	then the DFW flag in the BLB is cleared.
;	AP destroyed.
;--

SCAN_LOCKS:
	CLRL	R5			; Init BDB return.
	MOVAL	IFB$L_BLBFLNK(R10), R0	; Save for end test
	MOVL	R0, R4			; Get start of list

	ASSUME	BLB$L_FLNK	EQ	0

10$:	MOVL	(R4), R4		; Get next BLB
	CMPL	R4, R0			; At end of list?
 	BEQL	50$			; EQL get a free one
	CMPL	BLB$L_VBN(R4), R1	; Is this the one?
	BNEQ	10$			; NEQ then try next one

;
; A BLB for the requested bucket has been located.
; If this stream already owns it, return with success.
; 

	MOVL	BLB$L_BDB_ADDR(R4), AP	; Pick up BDB/GBPB address.
	CMPL	BLB$L_OWNER(R4), R9	; Does this stream own it?
	BEQL	30$			; Br if so.
	TSTL	AP			; Was there a BDB/GBPB?
	BEQL	10$			; No, keep looking.

	ASSUME	BDB$B_BID	EQ	GBPB$B_BID
	ASSUME	<BDB$C_BID & 1>	EQ	0
	ASSUME	<GBPB$C_BID & 1> EQ	1

	BLBS	GBPB$B_BID(AP), 10$	; Ignore all other GBPB's.
	MOVL	AP, R5			; Note BDB address.
	MOVL	BLB$L_OWNER(R4), AP	; Pick up owner, if any.
	BEQL	20$			; No owner, then use it.
	CMPL	R10, AP			; Is the ifab the owner?
	BNEQ	10$			; If not, keep looking.

;
; This is a BLB for the desired bucket, with the ifab as the owner.
; It is a deferred write buffer (DFW).  If this stream only wants read
; access to the buffer, then simply use this BLB.  No conversion will
; be done in that case, which means a blocking AST to write back the
; buffer can occur at any time.  This is not a problem because readers
; don't modify the buffer.
; If the bucket is to be locked, the DFW flag is used to interlock access
; to this BLB.  By clearing the flag, the blocking AST is inhibited from
; writing back the buffer while it is being modified.  The buffer will
; be written back when this access is complete.
; If the DFW flag is already clear, it indicates that a write back is
; already in progress.  In that case, this thread must be stalled
; until the writeback is complete.
; This avoids the need to send a blocking AST in the normal multistream case.
; Dirty buffers are therefore passed from stream to stream, although
; they are not passed from process to process.
;

	ASSUME	CSH$V_LOCK	EQ	0

	BLBC	R3, 20$			; If only a reader, take the buffer.
	BBSC	#BLB$V_DFW,-		; Branch unless writeback is
		BLB$B_BLBFLGS(R4), 20$	; already in progress.
	MOVL	R9, BLB$L_OWNER(R4)	; Note thread that is stalling.
	BISB2	#BLB$M_LOCK, BLB$B_BLBFLGS(R4) ; Note that thread is stalling.
	MOVQ	R2, -(SP)		; Save registers.
	BSBW	RM$STALL		; Wait for writeback to complete.
	TSTB	IRB$B_EFN(R9)		; DO NOT set efn if zero.
	BEQL	18$
	$SETEF_S IRB$B_EFN(R9)		; Set event flag.
18$:	MOVQ	(SP)+, R2		; Restore registers.
20$:
	RMSSUC				; Note success.
	RSB				; Return.

;
; BLB was found which we own.  Note the BDB/GBPB address and return success.
;

30$:	MOVL	AP, R5			; Note BDB/GBPB address.
	BRB	20$			; Return success.
50$:	CLRL	R0			; Note failure.
	RSB				; Return.

;++
;
;	GET_BLB
;
;	Look for free BLB from the end of list to the front.
;	A 'free BLB' has a zero vbn field.
;
; Calling sequence:
;
;	BSBW	GET_BLB
;
; Input parameters:
;
;	R10 -	ifab address
;		BLB$L_FLNK - BLB listhead forward link
;		BLB$L_BLNK - BLB listhead backward link
;
;	R9  -	structure which will own lock (ifab/irab)
;
;	R1  -	VBN to be accessed by bucket lock
;
; Output parameters:
;
;	R4  -	address of free BLB
;
; Side effects:
;
;	BLB returned in R4 is moved to head of BLB chain.
;	AP destroyed.
;	Bugcheck if no BLB is available.
;
;--

GET_BLB:

	ASSUME	BLB$L_BLNK	EQ	<BLB$L_FLNK + 4>
	ASSUME	IFB$L_BLBBLNK	EQ	<IFB$L_BLBFLNK + 4>

	MOVAL	IFB$L_BLBFLNK(R10), R4	; Get list head.
	MOVL	R4, AP			; Save for end test.
100$:	MOVL	4(R4), R4		; Get back link.
	CMPL	R4, AP			; Back at list head?
	BEQL	110$			; If so, then bugcheck
	TSTL	BLB$L_VBN(R4)		; This one free?
	BNEQ	100$			; No, move on to next one.
	MOVL	R9, BLB$L_OWNER(R4)	; Note owner.
	MOVL	R1, BLB$L_VBN(R4)	; Note resource.
	REMQUE	(R4), R4		; Remove from current place in chain.
	INSQUE	(R4), IFB$L_BLBFLNK(R10) ; Put in front to find quick.
	RSB				; Return.
110$:
	RMSPBUG	FTL$_NOBLB		; Should always find one.

;++
;
;	RM$FREE_LCL
;
; Toss the oldest least valuable buffer out of the cache.  This
; routine is called when the AVLCL count is less than zero, meaning
; that all BLB's are being used either for caching or access of a
; bucket.  It does not necessarily mean that there are no BDB's free
; because multiple BLB's may be tied up referencing a single BDB.
; Nonetheless, a BDB must be tossed out of the cache to free up its
; associated BLB.
;
; Calling sequence:
;
;	BSB	RM$FREE_LCL
;
; Input Parameters:
;
;	R10 -	Ifab address
;	    IFB$L_BDB_BLNK - back link of BDB listhead.
;	R9 - Thread to stall (if necessary)
;
; Output Parameters:
;
;	R0  -	status value from call to RM$RELEASE
;		DME - all valid BDB's were in use.
;
; Side effects:
;
;	AP destroyed.
;
;--

RM$FREE_LCL::
	PUSHR	#^M<R1,R2,R3,R4>	; Save registers.
	CLRL	R4			; Init last BDB seen.
	MNEGL	#1, R1			; Init last cache value.
					; This should always cause the first
					; BDB possible to be selected.
	ASSUME	BDB$L_FLINK	EQ	0
	ASSUME	BDB$L_BLINK	EQ	<BDB$L_FLINK + 4>

	MOVAL	IFB$L_BDB_FLNK(R10), R0	; Get list head into R0.
	MOVL	R0, AP			; Save for end test.
10$:
	MOVL	4(R0), R0		; Get next BDB.
	CMPL	R0, AP			; End of chain?
	BEQL	20$			; EQL means at end.

	ASSUME	BDB$B_BID	EQ	GBPB$B_BID
	ASSUME	<BDB$C_BID & 1>	EQ	0
	ASSUME	<GBPB$C_BID & 1> EQ	1

	BLBS	BDB$B_BID(R0), 10$	; Continue scan if gbpb.
	TSTW	BDB$W_USERS(R0)		; Is this one accessed?
	BNEQ	10$			; NEQ it is - keep going.
	TSTL	BDB$L_VBN(R0)		; See if valid.
	BEQL	10$			; Continue search for valid BDB.
	CMPB	BDB$B_CACHE_VAL(R0), R1	; Less valuable than what has already
					; been seen?
	BGEQU	10$			; GEQU, then just keep looking.
	MOVL	R0, R4			; Save this BDB address.
	MOVZBL	BDB$B_CACHE_VAL(R0), R1	; Save this as lowest seen.
	BNEQ	10$			; If non-zero, keep trying.
	BRB	50$			; Use the first BDB with zero value.

;
; At end of list.  If anything was noted, then use it.
; If no BDB's can be tossed out, scan the BLB list for a deferred write
; BLB, and DEQ that lock.
;

20$:	TSTL	R4			; Did we find a BDB?
	BNEQ	50$			; Go free it, if one found.
	BBC	#IFB$V_NORECLK,(R10),25$; None found, check BLBs if locking.
	RMSPBUG	FTL$_NOLCLBUF		; We should have found a BDB, The
					; AVLCL count is probably wrong.

	ASSUME	BLB$L_FLNK	EQ	0
	ASSUME	BLB$L_BLNK	EQ	<BLB$L_FLNK + 4>
	ASSUME	IFB$L_BLBBLNK	EQ	<IFB$L_BLBFLNK + 4>

25$:	MOVAL	IFB$L_BLBFLNK(R10), R2	; Address of listhead.
	MOVL	R2, AP			; Save for end test.
30$:	MOVL	4(R2), R2		; Get next BLB (going backwards).
	CMPL	R2, AP			; Done yet?
	BEQL	40$			; EQL then at end of list.
	CMPL	BLB$L_OWNER(R2), R10	; Does ifab own this lock?
	BNEQ	30$			; No, check the next one.
	BBS	#BLB$V_DFW,-		; Found one, now make sure this
		BLB$B_BLBFLGS(R2),35$	; is really a deferred write lock
	BBC	#BLB$V_WRITEBACK,-	; and not the IFAB from a $OPEN
		BLB$B_BLBFLGS(R2),30$	; command.


;
; Have found a lock with the ifab as the owner.  This is a deferred
; write lock.  Get the BDB address into R4 and branch into code to
; release this lock and free the BLB.
;

35$:	MOVL	BLB$L_BDB_ADDR(R2), R4	; Want BDB address in R4.
	BRB	55$			; And go release it.
40$:
	RMSERR	DME			; Couldn't find anything to release.
	BRB	80$			; Branch to exit.

50$:

;
; A BDB has been selected to toss out of the cache.  Release it, forcing
; write-thru if dirty.  The RLS$M_DEQ flag causes the buffer to be
; completely released and made available.
;
; Check now to see if a writeback is already in progress on this
; BLB.  If so, then stall until it is complete.
; At this point, we know there are no other accessors to this bucket,
; and therefore the BLB_PTR must point to the deferred write
; BLB if there is one.
;

	MOVL	BDB$L_BLB_PTR(R4), R2	; Get the BLB address.
	BEQL	60$			; No locking, just dequeue then.
	TSTL	BLB$L_OWNER(R2)		; Any owner for this lock?
	BEQL	60$			; EQL then it's not dirty.
55$:	MOVL	R9, BLB$L_OWNER(R2)	; Note thread that is stalling.
	BBSC	#BLB$V_DFW,-		; Branch if writeback has not
		BLB$B_BLBFLGS(R2), 60$	; started and claim this BLB.
	BISB2	#BLB$M_LOCK, BLB$B_BLBFLGS(R2) ; Note this thread is stalled.
	BSBW	RM$STALL		; Stall until writeback complete.
	TSTB	IRB$B_EFN(R9)		; DO NOT set efn if zero.
	BEQL	60$
	$SETEF_S IRB$B_EFN(R9)		; Set event flag.
60$:
	BBCC	#BDB$V_AST_DCL,-	; Branch if no writeback has been done.
		BDB$B_FLGS(R4), 70$
	BLBC	BDB$L_IOSB(R4), 90$	; Branch if an error has occured.
70$:	MOVL	#RLS$M_DEQ, R3		; Init release flags to release lock.
					; DEQ flag implies write thru if dirty.
	INCW	BDB$W_USERS(R4)		; Make it look accessed.
	BSBW	RM$RELEASE		; And release it.
80$:	POPR	#^M<R1,R2,R3,R4>	; Restore registers.
	RSB				; Return.
90$:
	MOVZWL	BDB$L_IOSB(R4), RAB$L_STV(R8) ; Store i/o error code.
	RMSERR	WER			; Note error with RMS code.
	BRB	80$			; and return.

;++
;
;	SCAN_LCL_CACHE
;
;	Search list of all BDB's for match on the VBN field.
;
; Calling sequence:
;
;	BSB	SCAN_LCL_CACHE
;
; Input Parameters:
;
;	R10 - ifab address
;	    IFB$L_BDB_FLNK - forward link of BDB listhead.
;
;	R1 - VBN of bucket desired
;
; Output Parameters:
;
;	R5 - address of BDB that matches desired VBN or 0 if not found
;--

SCAN_LCL_CACHE:
	MOVAL	IFB$L_BDB_FLNK(R10), R5	; Address of BDB listhead.
	MOVL	R5, AP			; Save for end test.

	ASSUME	BDB$L_FLINK	EQ	0

10$:	MOVL	(R5), R5		; Get next BDB.
	CMPL	R5, AP			; At end of list yet?
	BEQL	50$			; EQL yes, quit.
	CMPL	BDB$L_VBN(R5), R1	; Is this the right one?
	BNEQ	10$			; No, try next one.

	ASSUME	<BDB$C_BID & 1>	EQ	0
	ASSUME	<GBPB$C_BID & 1> EQ	1

	BLBS	BDB$B_BID(R5), 10$	; Not a BDB.  Continue search.
20$:	RSB				; Return.
50$:	CLRL	R5			; Note failure.
	RSB				; Return.

;++
;
;     RM$GET_LCL_BUFF
;
;	Search list of BDB's from the end of list to the front for
;	one with VBN=0, USERS=0, and SIZE large enough.
;
; Calling sequence:
;
;	BSBW	RM$GET_LCL_BUFF
;
; Input Parameters:
;
;	R1 - VBN desired
;	R2 - Size of bucket
;	R10 - Ifab address
;	  BDB_BLNK - Back BDB link
;
; Output Parameters:
;
;	R5 - BDB address
;	  VBN set to R1
;	  NUMB set to R2
;
; Side effects:
;
;	NOLCLBUF bugcheck if no BDB is found.
;
;--

RM$GET_LCL_BUFF::

	ASSUME	BDB$L_FLINK	EQ	0
	ASSUME	BDB$L_BLINK	EQ	<BDB$L_FLINK + 4>
	ASSUME	IFB$L_BDB_BLNK	EQ	<IFB$L_BDB_FLNK + 4>

	MOVAL	IFB$L_BDB_FLNK(R10), R5	; Get BDB list head.
	MOVL	R5, AP			; Save for end test.
10$:
	MOVL	4(R5), R5		; Get next BDB.
	CMPL	R5, AP			; At end of list?
	BEQL	100$			; Bug if none found in list.
	TSTL	BDB$L_VBN(R5)		; This buffer free?
	BNEQ	10$			; NEQ it's in use.  Continue search.
	TSTW	BDB$W_USERS(R5)		; In use?
	BNEQ	10$			; NEQ in use, try another.

	ASSUME	<BDB$C_BID & 1>	EQ	0
	ASSUME	<GBPB$C_BID & 1> EQ	1

	BLBS	BDB$B_BID(R5), 10$	; It's not a BDB.  Continue search.
	CMPW	BDB$W_SIZE(R5), R2	; Is this buffer large enough?
	BLSSU	10$			; LSSU not big enough - try another.

	CLRL	BDB$L_BLB_PTR(R5)	; Make sure this is 0.
	MOVL	R1, BDB$L_VBN(R5)	; Found one- store VBN.
	MOVW	R2, BDB$W_NUMB(R5)	; Store size desired.
	BBC	#IFB$V_MSE, (R10), 20$	; Branch if not multistreaming.
	BISB2	#BDB$M_NOLOCATE, BDB$B_FLGS(R5) ; Don't allow locate mode.
20$:	RSB

100$:	RMSPBUG	FTL$_NOLCLBUF		; Should always find one.

;++
;
;	LOCK_BKT
;
;	This routine is called to obtain a lock for the requested bucket
;	for either read only or modify.  In addition, it may also be known
;	that the lock must be of a high enough mode to interlock an i/o
;	operation.  The following lock manager modes are used:
;
;	LCK$K_PWMODE if holding modified buffer.  No conversion will
;		be done if this is not a LOCK request to cache.
;	LCK$K_EXMODE for all locks.
;
; Calling sequence:
;
;	BSBW	LOCK_BKT
;
; Input Parameters:
;
;	R10 -	ifab address
;	    IFB$L_SFSB_PTR - pointer to shared file synchronization block
;		SFSB$L_LOCK_ID - lock id of shared file lock
;
;	R9  -	ifab/irab address
;	    IRB$B_EFN - event flag to use.
;
;	R4  -	BLB address
;	    BLB$B_MODEHELD - mode of lock currently held.
;	    BLB$L_LOCK_ID - ID of lock if one already held
;	    BLB$L_RESDSC - resource name descriptor (should point to BLB$L_VBN)
;
;	R3  -	Cache flags (same as input to RM$CACHE).
;
; Output Parameters:
;
;	R0  -	status value of $ENQ service after call to RM$MAPERR.
;
; Side effects:
;
;	BLB$L_LKSTS field contains value of ENQ service.
;	BLB$L_VALBLK contains value block for lock requested.
;	BLB$L_OWNER is set to R9.
;	BLB$B_MODEHELD contains mode of lock obtained.
;	BLB$B_BLBFLGS contain the cache flags also.
;
;	R1 is always destroyed.
;	If lock not granted synchonously, will return at AST level with
;	event flag (IRB$B_EFN) set and AP, and R2 will be destroyed.
;
;--

LOCK_BKT:

	ASSUME	CSH$V_LOCK	EQ	BLB$V_LOCK
	ASSUME	CSH$V_NOWAIT	EQ	BLB$V_NOWAIT
	ASSUME	CSH$V_NOREAD	EQ	BLB$V_NOREAD
	ASSUME	CSH$V_NOBUFFER	EQ	BLB$V_NOBUFFER

	MOVL	R9, BLB$L_OWNER(R4)	; Note owning stream.
	BICB2	#^CCSH_MASK_ALL, R3	; Clear out all but csh flags
	BICB2	#CSH_MASK_ALL, BLB$B_BLBFLGS(R4) ; Clear out csh flags
	BISB2	R3, BLB$B_BLBFLGS(R4)	; Store csh flags in blb flags field.

;
; The lock may currently be held in NL, PW or EX mode.
; NL mode is used to cache local buffers.
; PW mode is used when a modified buffer is held locally.
; EX mode is normally used when a bucket is accessed.
; The exception is that if a PW lock is already held and only a read
; lock on the bucket is desired, no conversion is necessary.
; PW is converted to EX for modify access to eliminate the possibility of
; a blocking AST arriving during the access.
;
	ASSUME	CSH$V_LOCK EQ 0

	MOVL	#LCK$K_PWMODE, R1	; Assume read lock desired.
	BLBC	BLB$B_BLBFLGS(R4), 10$	; Branch if write lock not wanted.
	MOVL	#LCK$K_EXMODE, R1	; Get exclusive lock.
10$:	CMPB	BLB$B_MODEHELD(R4), R1	; Is high enough mode held already?
	BLSSU	30$			; LSSU then continue
	RMSSUC				; return success.
	RSB
;
; Build FLAG list for ENQ.
;
30$:	PUSHL	R3			; save cache flags
	MOVL	#LCK$M_SYSTEM!LCK$M_SYNCSTS!LCK$M_VALBLK,R3 ; Always use these flags
	TSTL	BLB$L_LOCK_ID(R4)	; Is lock already held?
	BEQL	31$			; No, go on
	BISL2	#LCK$M_CONVERT,R3	; Add conversion flag to our list.
31$:	BBC	#BLB$V_NOWAIT,BLB$B_BLBFLGS(R4),32$ ; Br if wait desired.
	BISL2	#LCK$M_NOQUEUE,R3	; Do not wait for this lock.

32$:	TSTL	IFB$L_PAR_LOCK_ID(R10)	; Make sure parent lock is present.
	BNEQ	35$
	RMSPBUG	FTL$_NOSFSB		; No, we are in trouble!

;
; Do the ENQ for the bucket.
;

35$:	BSBW	RM$SETEFN		; Get an event flag
	POPL	R0			; Put it in R0.
	$ENQ_S	EFN	= R0,-
		LKMODE	= #LCK$K_EXMODE,-
		LKSB	= BLB$W_LKSTS(R4),-
		FLAGS	= R3,-
		RESNAM	= BLB$L_RESDSC(R4),-
		PARID	= IFB$L_PAR_LOCK_ID(R10),-
		ASTADR	= W^RM$STALLAST,-
		ASTPRM	= R9

	BLBC	R0, 110$		; Exit on error.
	CMPW	#SS$_SYNCH, R0		; Need to stall?
	BEQL	70$			; EQL all done.
50$:	PUSHL	R3			; Save ENQ flags around stall.
	BSBW	RM$STALL		; Stall for lock.
	POPL	R3			; Restore ENQ flags.
70$:	MOVZWL	BLB$W_LKSTS(R4), R0	; Get completion status into R0.
	BLBC	R0, 110$		; Branch on error.
80$:	MOVB	#LCK$K_EXMODE, BLB$B_MODEHELD(R4); Store lock mode in blb.
90$:	POPL	R3			; restore cache flags
	RSB				; Return.

;
; An error occured on the ENQ service.  Deadlock errors may occur
; normally because of the deferred write mechanism and are simply
; requeued.
;

110$:	CMPW	#SS$_DEADLOCK, R0	; Was it deadlock?
	BEQL	35$			; Try it again if it was.
	CMPW	#SS$_EXENQLM, R0	; Exceed our lock quota?
	BEQL	150$			; Br if yes.
	CMPW	#SS$_NOLOCKID, R0	; Lock id table full?
	BEQL	150$			; Br if yes.
	CMPW	#SS$_VALNOTVALID,R0	; Has lock manager returned old value block?
	BNEQ	120$			; No, report the error.
	INCL	BLB$L_VALSEQNO(R4)	; Bump sequence number on bucket to get new copy.
	RMSSUC				; Consider this ENQ successful.
	BRB	80$			; Branch to finish up.
115$:	POPL	R0			; Return with original error.
120$:	RMSERR	ENQ, R1			; Default error code.
	BSBW	RM$MAPERR		; Try to map error.
	BRB	90$			; Return.

;
; This is either a case where we've exceeded our lock quota or the system
; lock id table is full.  It may be the case that something can be tossed
; out of our local cache and thereby free up a lock to continue with this
; operation.  If that fails, return with the original error.  Otherwise,
; requeue the lock request.
;

150$:	PUSHL	R0			; Save this error code.
	BSBW	RM$FREE_LCL		; Try to free a buffer.
	BLBC	R0, 115$		; Branch on failure.
	POPL	R0			; Pop error off stack.
	BRW	35$			; Go try request again.

;++
; 
; SCAN_GBL
;
; Scan global cache for match on desired bucket.
;
; Calling sequence:
;
;	BSBW	SCAN_GBL
;
; Input parameters:
;
;	R10 - ifab address
;	  GBH_PTR - pointer to global buffer header area
;
;	R1 - vbn of desired bucket
;
; Output parameters:
;
;	R0 - success
;	R5 - GBPB address
; else
;	R0 - failure (0)
;	R5 - addr of next lower valued GBD or zero if no GBPB found.
;
; Side effects:
;	AP destroyed.
;	EXclusive lock on global buffer section is obtained and kept.
;
;--

SCAN_GBL:
	ASSUME	GBH$L_GBD_FLNK	EQ	0
	ASSUME	GBH$L_GBD_BLNK	EQ	4
	ASSUME	GBD$L_FLINK	EQ	0
	ASSUME	GBD$L_BLINK	EQ	4
	ASSUME	GBD$L_VBN	EQ	GBH$L_HI_VBN

	BSBW	RM$RAISE_GBS_LOCK	; Get EX lock on GBS to search cache.
	MOVL	IFB$L_GBH_PTR(R10), R0	; Get pointer to gbl header.
	MOVL	R0, AP			; Save for later.

10$:	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BLSSU	10$			; LSSU then keep scanning.
20$:	BEQL	30$			; EQL we found it - finish up.

	INCL	GBH$L_MISS(AP)		; Note cache miss.
	ADDL3	4(R0), R0, R5		; Get addr of previous element.
	CLRL	R0			; Note failure.
	RSB				;
30$:
	INCL	GBH$L_HIT(AP)		; Note cache hit and drop through.

;++
;
; GET_GBPB
;
; Branch or drop through to this point after locating GBD to get a 
; GBPB and point it to GBD.
;
; Input parameters:
;	R10 - ifab
;	  BDB_FLNK - BDB (and GBPB) listhead.
;	R0 - GBD address
;
; Output parameters:
; If	R0 - success
; then	R5 - GBPB address
; else	R5 = 0 if GBPB not found.
;
;--
GET_GBPB:
	INCW	GBD$W_USECNT(R0)	; Bump use count in GBD (we are assuming
					;  that a GBPB will be found).
	PUSHL	R0			; Save GBD around lock manager call.
	BSBW	RM$LOWER_GBS_LOCK	; Lower lock on GBS to NL.
	POPL	R0			; Restore GBD.

	MOVAL	IFB$L_BDB_FLNK(R10), R5	; BDB/GBPB listhead.
	MOVL	R5, AP			; Save for end test.
10$:
	ASSUME	BDB$L_FLINK	EQ	0
	ASSUME	BDB$L_BLINK	EQ	4

	MOVL	4(R5), R5		; Get next element.(going backwards)
	CMPL	R5, AP			; Back to listhead yet?
	BEQL	100$			; That's a bug.

	ASSUME	BDB$B_BID	EQ	GBPB$B_BID
	ASSUME	<BDB$C_BID & 1>	EQ	0
	ASSUME	<GBPB$C_BID & 1> EQ	1

	BLBC	BDB$B_BID(R5), 10$	; Branch if BDB and keep looking.
	TSTW	GBPB$W_USERS(R5)	; Make sure it's not in use.
	BNEQ	10$			; NEQ it is, so keep looking.
;
; Found the GBPB.  Fill in relevant data from GBD.
;
	MOVL	R0, GBPB$L_GBD_PTR(R5)	; Pointer to GBD.
	MOVL	GBD$L_VBN(R0), GBPB$L_VBN(R5) ; Bucket vbn.
	MOVL	GBD$L_VBNSEQNUM(R0),-	; Move sequence number from GBD to GBPB.
		GBPB$L_VBNSEQNO(R5)

	ASSUME	<GBD$W_NUMB + 2>	EQ	GBD$W_SIZE
	ASSUME	<GBPB$W_NUMB + 2>	EQ	GBPB$W_SIZE

	MOVL	GBD$W_NUMB(R0), GBPB$W_NUMB(R5) ; Numb and size fields.
	MOVB	#BDB$M_VAL!BDB$M_NOLOCATE,- ; Init flags.
		GBPB$B_FLGS(R5) 	;
	MOVL	IFB$L_GBH_PTR(R10), AP	; Get pointer to gbl header.
	ADDL3	GBD$L_REL_ADDR(R0), AP, GBPB$L_ADDR(R5) ; Addr of buffer.
	RMSSUC				; Note success.
	RSB				;
100$:
	DECW	GBD$W_USECNT(R0)	; Decrement use count for GBD.
	CLRL	R0			; Note failure.
	CLRL	R5			; Note no gbpb.
	RSB				;

;++
;
; FIND_FREE_GBL
;
; This routine is called when the desired bucket was not in the
; global cache.  Either find a free global buffer or toss one out
; of the cache to use.
;
; We already have an exclusive lock on the GBS from calling SCAN_GBL.
;
; Input parameters:
;	R5 - Address of preceding GBD.
;
; Output parameters:
;
; R0 - success, failure
; R5 - GBPB addr if success.
;    - 0 if failure.
;
;--
FIND_FREE_GBL:
	PUSHR	#^M<R2,R3,R4,R5>
	CLRQ	R3			; Init lowest val, gbpb found.
	DECL	R3			; Make lowval -1.
	MOVL	IFB$L_GBH_PTR(R10), AP	; Get gbl header.
	ADDL3	GBH$L_GBD_BLNK(AP), AP, R0 ; Get last GBD in list.
	CMPL	GBD$L_VBN(R0), R3	; Is the vbn -1?
	BEQL	GOT_GBD			; EQL then just use this one.
;
; There are no available GBD's at the end of the list.
; Will have to select GBD to toss out of the cache.
;
	CLRL	-(SP)			; Note first pass.
	ADDL3	GBH$L_GBD_END(AP), AP, R5 ; End addr of scan.
	ADDL3	GBH$L_GBD_NEXT(AP), AP, R0 ; Starting point of scan.
	CMPL	GBH$L_GBD_START(AP),-	; Is NEXT pointer the
		GBH$L_GBD_NEXT(AP)	; same as the START of GBD's?
	BNEQ	10$			; NEQ then make two passes.
	INCL	(SP)			; Else only make one.
10$:	MOVL	GBH$L_SCAN_NUM(AP), R2	; Number of GBD's to search.
LTOP:
	TSTW	GBD$W_USECNT(R0)	; This one in use?
	BNEQ	LTST			; NEQ it is. Br to loop test.
	CMPB	GBD$B_CACHE_VAL(R0), R3	; Is this lowest cache value seen?
	BGEQU	SCANTST			; GEQU lower has been seen.  Ignore it.
	MOVL	R0, R4			; Save this GBD addr.
	MOVZBL	GBD$B_CACHE_VAL(R0), R3	; Save this cache value.
	BEQL	USE_GBD			; Use first zero value one found.
SCANTST:
	DECL	R2			; Keep scanning if counter not run out.
	BLEQ	USE_GBD			; Use what's been found.
LTST:
	ACBL	R5, #GBD$C_BLN, R0, LTOP ; Keep going if limit not hit yet.

	BBSS	#0, (SP), USE_GBD	; Br if second pass.
	ADDL3	GBH$L_GBD_START(AP), AP, R0 ; Start at beginning this time.
	ADDL3	GBH$L_GBD_NEXT(AP), AP, R5 ; End with current next ptr.
	SUBL2	#GBD$C_BLN, R5		; Back up one - did it first pass.
	BRB	LTOP			; Branch into loop.
USE_GBD:
	ADDL2	#4, SP			; Pop pass counter off stack.
	ADDL3	GBH$L_GBD_NEXT(AP), AP, R0 ; Get addr of this 'victim'
	TSTB	GBD$B_CACHE_VAL(R0)	; Is it already zero?
	BEQL	10$			; EQL then can't age anymore.
	DECB	GBD$B_CACHE_VAL(R0)	; Age him a unit.
10$:	ADDL2	#GBD$C_BLN, GBH$L_GBD_NEXT(AP) ; Move on to next GBD next time.
	CMPL	GBH$L_GBD_NEXT(AP), GBH$L_GBD_END(AP) ; Is this past GBD's?
	BLEQU	20$			; LEQU it's still in range.
	MOVL	GBH$L_GBD_START(AP), GBH$L_GBD_NEXT(AP) ; Else reset to start.
20$:	MOVL	R4, R0			; Get addr of GBD to use.
	BEQL	ERXIT			; EQL didn't find one.

GOT_GBD:
	POPR	#^M<R2,R3,R4,R5>	; Restore registers.
;
; R0 = GBD to use
; R1 = vbn desired
; R2 = size of bucket
; R5 = previous GBD from search scan.
;

;
; Remove this GBD from current position in queue.
;
	ASSUME	GBD$L_FLINK	EQ	0
	ASSUME	GBD$L_BLINK	EQ	4

	ADDL3	(R0), R0, AP		; Addr of successor
	REMQTI	(AP), R0		; Remove GBD from queue.
;
; Init this GBD.
;

	ASSUME	<GBD$B_FLAGS + 1>	EQ	GBD$B_CACHE_VAL

	CLRW	GBD$B_FLAGS(R0)		; Init flags, cache value.
	TSTL	GBD$L_LOCK_ID(R0)	; Is there a system lock out?
	BEQL	5$			; Branch around this if not.
	PUSHR	#^M<R0,R1>
	ADAWI	#1,@#RMS$GW_GBLBUFQUO	; Count this buffer back in.
	$DEQ_S	LKID = GBD$L_LOCK_ID(R0); Remove old buffer from cache.
	POPR	#^M<R0,R1>
	CLRL	GBD$L_LOCK_ID(R0)	; Clear system lock id from gbd.
5$:	MNEGL	#1,GBD$L_VBNSEQNUM(R0)	; INVALIDATE buffer.
	MOVL	R1, GBD$L_VBN(R0)	; Fill in vbn of bucket.
	MOVW	R2, GBD$W_NUMB(R0)	; Note size of bucket.
;
; Place GBD back into queue.
;
	CMPL	R0, R5			; Did we select the previous GBD?
	BNEQ	10$			; NEQ no.
	ADDL2	4(R5), R5		; Get the previous one then.
10$:	INSQHI	(R0), (R5)		; Insert GBD in queue.
	BRW	GET_GBPB		; Fill in GBPB.

ERXIT:	POPR	#^M<R2,R3,R4,R5>	; Restore registers.
	BSBW	RM$LOWER_GBS_LOCK	; Release our EX lock on the GBS.
	CLRL	R5			; Note no GBPB.
	CLRL	R0			; Note failure in R0.
	RSB				; Return.

	.END
