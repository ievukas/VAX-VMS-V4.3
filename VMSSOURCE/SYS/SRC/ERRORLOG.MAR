	.TITLE	ERRORLOG - ERROR LOG SUPPORT ROUTINES
	.IDENT	'V04-000'
 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 7-MAR-77
;
; ERROR LOG SUPPORT ROUTINES
;
; MODIFIED BY:
;
;	V03-012	EAD0162		Elliott A. Drayton	26-Apr-1984
;		Correct ADDB3 in routine GETFULLNAME to use R0.
;
;	V03-011	EAD0160		Elliott A. Drayton	16-Apr-1984
;		Added a test for the system block address not being there.
;
;	V03-010	EAD0137		Elliott A. Drayton	11-Apr-1984
;		Changed code to log full device names. NODE NAME + DEVICE.
;
;	V03-009	LMP0221		L. Mark Pilant,		30-Mar-1984  13:57
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-008	KPL0100		Peter Lieberwirth	22-Mar-1984
;		Use CONFREGL instead of CONFREG.  Anticipate SBICONF
;		containing a PFN instead of a VA if BI adapter
;		initialization didn't originally recognize the adapter.
;
;	V03-007	SSA0007		Stan Amway		2-Feb-1984
;		Fix broken branch to ERL$ALLOCEMB.
;
;	V03-006	LMP0185		L. Mark Pilant,		1-Feb-1984  9:37
;		Fix some broken branches.
;
;	V03-005	ROW0241		Ralph O. Weber		12-OCT-1983
;		Correct ERL$LOG_D(T)MSCP to allocate space for the error log 
;		header in addition to the space needed for the logged message 
;		etc.  Also use symbolic size of error log entry header instead 
;		of a constant.
;
;	V03-004	RLRMSCP		Robert L. Rappaport	27-Jul-1983
;		Add two entrypoints, ERL$LOG_DMSCP and ERL$LOG_TMSCP,
;		to log invalid Disk MSCP and Tape MSCP messages.
;
;	V03-003	KDM0051		Kathleen D. Morse	11-Jul-1983
;		Change references to TODR to use loadable, cpu-dependent
;		routine, EXE$READ_TODR.
;	V03-002	BLS0187		Benn Schreiber		24-Sep-1982
;		Correct broken branch offset due to UCB growing
;
;-
	.PAGE
;
; MACRO LIBRARY CALLS
;
 
	$CDDBDEF			;DEFINE CDDB OFFSETS
	$CDRPDEF			;DEFINE CDRP OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$EMBDEF	<DV,SU,TS,UI,SP,LM,ET>	;ERROR LOG MESSAGE BUFFERS OFFSETS
	$ERLDEF				;DEFINE ERROR ALLOCATION BUFFER OFFSETS
	$FCBDEF				;DEFINE FCB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION VALUES
	$IRPDEF				;DEFINE IRP OFFSETS
	$MCHKDEF			;DEFINE MACHINE CHECK RECOVERY MASK BITS
	$MSCPDEF			;DEFINE MSCP OFFSETS
	$NDTDEF				;DEFINE NEXUS DEVICE TYPE CODES
	$ORBDEF				;DEFINE OBJECT'S RIGHTS BLOCK OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$SBDEF				;DEFINE SYSTEM BLOCK OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$WCBDEF				;DEFINE WCB OFFSETS
 
					;***
;DEBUG=1				;***IF DEFINED, ENABLE UNEXPECTED
					;*** INTERRUPT IDENTIFIES VECTOR #

;
; LOCAL MACROS
;

;
; MACRO TO DEFINE AN INTERRUPT SERVICE ROUTINE LABEL FOR UNEXPECTED  INTERRUPTS
;
	.MACRO	ISRDEF,VNUM
	.ALIGN	LONG			; Make all vectors long word alligned
ERL$VEC'VNUM::				;INTERRUPT SERVICE LABEL
	.IF	DF,DEBUG		;***IF DEBUGGING
	BSBW	ERL$UNEXP		;***CALL INTERRUPT SERVICE
	.BYTE	<VNUM>/2		;***IDENTIFY VECTOR OFFSET INTO SCB
	.ENDC
	.ENDM	ISRDEF
;
; MACRO TO DEFINE THE INTERRUPT SERVICE ROUTINE LABELS FOR AN ADAPTER
;
	.MACRO	ADPISR,SLOT
VECTOR = SLOT * 4 + 256
	.REPT	4
	ISRDEF	\VECTOR
VECTOR = VECTOR + <16 * 4>
	.ENDR
	.IF	NDF,DEBUG		;IF NOT DEBUGGING
	BSBB	ADP_HANDLER		;CALL INTERRUPT SERVICE
	.ENDC
	.ENDM	ADPISR
;
; LOCAL SYMBOLS
;

;
; MAXIMUM NUMBER OF MESSAGES BEFORE WAKE OF FORMAT PROCESS
;
 
MAXMSG=10				;
 
;
; MAXIMUM TIME IN SECONDS BEFORE WAKE OF FORMAT PROCESS
;
 
MAXTIM=30				;
 
;
; LOCAL DATA
;
 
	.PSECT	$$$260,QUAD,WRT
;
;	WARNING!!!  The next two bytes must be adjacent and word aligned
;
	.ALIGN	WORD
BUF1:	.BYTE	0			;COUNT OF BUSY MESSAGES IN BUFFER
	.BYTE	0			;COUNT OF COMPLETED MESSAGES IN BUFFER
	.BYTE	0			;BUFFER INDICATOR
	.BYTE	0			;BUFFER CONTROL FLAGS
	.LONG	10$			;ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER
	.LONG	20$			;ADDRESS OF END OF BUFFER + 1
10$:	.BLKB	512-ERL$C_LENGTH	;ACTUAL BUFFER AREA
20$:					;REF LABEL
;
;	WARNING!!!  The next two bytes must be adjacent and word aligned
;
	.ALIGN	WORD
BUF2:	.BYTE	0			;COUNT OF BUSY MESSAGES IN BUFFER
	.BYTE	0			;COUNT OF COMPLETED MESSAGES IN BUFFER
	.BYTE	1			;BUFFER INDICATOR
	.BYTE	0			;BUFFER CONTROL FLAGS
	.LONG	10$			;ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER
	.LONG	20$			;ADDRESS OF END OF BUFFER + 1
10$:	.BLKB	512-ERL$C_LENGTH	;ACTUAL BUFFER AREA
20$:					;REF LABEL
 
;
; GLOBAL DATA
;
; ERROR LOG DATA BASE
;
 
ERL$AL_BUFADDR::			;ALLOCATION BUFFER ADDRESS ARRAY
	.LONG	BUF1			;ADDRESS OF BUFFER 1 DESCRIPTOR
	.LONG	BUF2			;ADDRESS OF BUFFER 2 DESCRIPTOR
ERL$GB_BUFIND::				;CURRENT ALLOCATION BUFFER INDICATOR
	.BYTE	0			;
ERL$GB_BUFFLAG::			;BUFFER STATUS FLAGS
	.BYTE	0			;
ERL$GB_BUFPTR::				;FORMAT PROCESS BUFFER INDICATOR
	.BYTE	0			;
ERL$GB_BUFTIM::				;FORMAT PROCESS WAKEUP TIMER
	.BYTE	MAXTIM			;
ERL$GL_ERLPID::				;PROCESS ID OF ERROR LOG PROCESS
	.LONG	0			;
ERL$GL_SEQUENCE::			;UNIVERSAL ERROR SEQUENCE NUMBER
	.LONG	0			;
	.PAGE
	.SBTTL	UNEXPECTED INTERRUPT SERVICE

;+
; ERL$VEC'VNUM - INTERRUPT SERVICE FOR SCB VECTOR VNUM.
; ERL$UNEXP - GENERAL UNEXPECTED INTERRUPT SERVICE
;
; THESE INTERRUPT SERVICE ROUTINES ARE EXECUTED FOR UNUSED SCB VECTORS.
;
; IF DEBUG IS DEFINED, EACH INTERRUPT SERVICE CALLS ERL$UNEXP WITH
; THE <VECTOR OFFSET>/2 INTO THE SCB AS A 1 BYTE ARGUMENT.
;
; IF DEBUG IS NOT DEFINED, ALL CPU INTERRUPT SERVICE ROUTINES COLLAPSE TO
; GLOBAL LABELS EQUAL TO ERL$UNEXP AND ALL ADAPTER INTERRUPT SERVICE
; ROUTINES CALL A ROUTINE THAT SAVES THE ADAPTER TYPE, TRIES TO DISABLE
; FURTHER INTERRUPTS, AND LOGS THE INTERRUPT.
;
; THERE ARE ENOUGH INTERRUPT SERVICE ROUTINES FOR THE ARCHITECTURAL PAGE 
; OF THE SCB, I.E., 128 ROUTINES.
;
; INPUTS:
;
;	(SP) = PC AT INTERRUPT
;	4(SP) = PSL AT INTERRUPT
;
; OUTPUTS:
;
;	ERROR IS LOGGED, OR PROCESSOR BUGCHECKS.
;-
	.PSECT	$AEXENONPAGED,LONG
;
; UNEXPECTED ADAPTER INTERRUPT HANDLER: IF DEBUG IS DISABLED, SAVE THE
; ADAPTER TYPE, ATTEMPT TO DISABLE FURTHER INTERRUPTS FROM THE ADAPTER,
; AND LOG THE INTERRUPT.  IF DEBUG IS ENABLED, BUGCHECK AS FOR CPU INTERRUPTS.
;
	.ALIGN	LONG
ADP_UNEXP:
	NEXUS = 0			;FIRST ADAPTER = 0
	.REPT	16			;ISR'S FOR 16 ADAPTERS ONLY
	ADPISR	\NEXUS			;DEFINE ERL$INT'VNUM LABELS AND ISRS
	NEXUS = NEXUS + 1		;NEXT ADAPTER
	.ENDR				;
ADP_HANDLER:
	SUBL	#ADP_UNEXP+2,(SP)	;COMPUTE ADAPTER OFFSET
	DIVL	#4,(SP)			;COMPUTE ADAPTER SLOT/TR NUMBER
	PUSHR	#^M<R0,R1,R2,R3,R4>	;SAVE REGISTERS
	MOVL	5*4(SP),R3		;RETRIEVE SLOT NUMBER
	MOVL	@MMG$GL_SBICONF[R3],R4	;GET ADDRESS OF ADAPTER REGISTERS
	BGEQ	100$			;GEQ MEANS SBICONF DOES NOT CONTAIN
					; A SYSTEM VA, MUST BE PFN OR 0
 
	$PRTCTINI B^5$,#<MCHK$M_NEXM!MCHK$M_LOG>
 
	CLRL	4(R4)			;DISABLE ADAPTER INTERRUPTS (HOPEFULLY)
	MOVL	(R4),R1			;GET ADAPTER CONFIGURATION REG CONTENTS
	CMPB	R1,#NDT$_DR32		;IS THIS A DR32?
	BNEQ	1$			;BRANCH IF NOT
	MOVL	#^X500,(R4)		;ELSE CLEAR INTERRUPTS IN SPECIAL WAY
1$:	MOVL	(R4),R4			;GET THE ADAPTER'S CONFIGURATION REG
 
	$PRTCTEND 5$
	BLBC	R0,100$			;IF R0 LBC, THEN NO ADPATER PRESENT
 
	TSTL	@EXE$GL_CONFREGL[R3]	;ALREADY CONFIGURED?
	BNEQ	10$			;IF NEQ, YES
	MOVZBL	R4,@EXE$GL_CONFREGL[R3]	;SAVE THE ADAPTER TYPE
10$:
	MOVL	#EMB$C_UI_LENGTH,R1	;SET SIZE OF MESSAGE TO ALLOCATE
	JSB	ERL$ALLOCEMB		;ALLOCATE AN ERROR LOG BUFFER
	BLBC	R0,20$			;BRANCH IF NONE AVAILABLE
	MOVW	#EMB$C_UI,EMB$W_UI_ENTRY(R2) ;SET MESSAGE TYPE
	MOVL	R3,EMB$L_UI_TR(R2)	;SET SLOT/TR NUMBER
	MOVL	R4,EMB$L_UI_CSR(R2)	;SET CONFIGURATION REGISTER VALUE
	JSB	ERL$RELEASEMB		;RELEASE BUFFER
20$:	POPR	#^M<R0,R1,R2,R3,R4>	;RESTORE REGISTERS
	ADDL	#4,SP			;REMOVE SLOT NUMBER
	REI				;
 
100$:	CLRL	R4			;FLAG NO ADAPTER PRESETN
	BRB	10$			;JOIN COMMON CODE
 
;
; UNEXPECTED CPU INTERRUPT HANDLER:  IF DEBUG IS ENABLED, BUGCHECK WITH 
; <VECTOR OFFSET>/2 INTO SCB AS TOP BYTE ON STACK. IF DEBUG IS DISABLED,
; JUST BUGCHECK.
;
	.ALIGN	LONG
CPU_UNEXP:
	VNUM=000			;FIRST VECTOR = 0
	.REPT	64			;ISR'S FOR CPU INTERRUPTS ONLY
	ISRDEF	\VNUM			;DEFINE ERL$INT'VNUM LABEL AND ISR
	VNUM=VNUM+4			;NEXT VECTOR
	.ENDR				;

ERL$UNEXP::				;
	.IF	DF,DEBUG		;***IF VECTOR ID ENABLED,...
	MOVZBL	@(SP),(SP)		;***OVERLAY RETURN WITH VECTOR OFFSET
	MULL	#2,(SP)			;***CONVERT ARG TO VECTOR OFFSET
	.IFTF
	BUG_CHECK UNXINTEXC		;BUGCHECK
	.IFT
	TSTL	(SP)+			;***CLEAN STACK
	.ENDC				;
	REI				;RETURN FROM INTERRUPT

;
; Vector entry for counting unexpected interrupts, rather than logging
; them.  Used on 11/780 for passive release on the DW780 and for the
; CVTP microcode bug.
;
	.ALIGN	LONG

ERL$VEC_RETURN::
	INCL	IO$GL_SCB_INT0		; Increment counter
	REI				; And return


	.PAGE
	.SBTTL	LOG DEVICE ERRORS
;+
; ERL$DEVICERR - LOG DEVICE CONTROLLER AND/OR DRIVE ERROR
; ERL$DEVICTMO - LOG DEVICE TIMEOUT ERROR
;
; THIS ROUTINE IS CALLED TO LOG A DEVICE TIMEOUT OR DEVICE CONTROLLER
; AND/OR DRIVE ERROR.
;
; INPUTS:
;
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF AN ERROR LOG ENTRY IS NOT ALREADY IN PROGRESS ON THE UNIT, ERROR
;	LOGGING IS ENABLED FOR THE UNIT, AND THE CURRENT REQUEST DOES NOT
;	INHIBIT ERROR LOGGING, THEN AN ERROR MESSAGE BUFFER IS ALLOCATED AND
;	FILLED IN WITH PERTINENT REQUEST INFORMATION FOLLOWED BY A DUMP OF
;	THE DEVICE REGISTERS.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-
 
	.PSECT	WIONONPAGED
	.ENABL	LSB
ERL$DEVICERR::				;LOG DEVICE CONTROLLER AND/OR DRIVE ERROR
	PUSHL	#EMB$C_DE		;SET FOR DEVICE ERROR
	BRB	10$			;
ERL$DEVICTMO::				;LOG DEVICE TIMEOUT ERROR
	MOVZWL	#EMB$C_DT,-(SP)		;SET FOR DEVICE TIMEOUT
10$:	BBS	#DEV$V_ELG,UCB$L_DEVCHAR(R5),15$ ;IF SET, ERROR LOG ENABLED
12$:	BRW	40$			;ERROR LOG DISABLED
15$:	BBS	#IO$V_INHERLOG,UCB$W_FUNC(R5),12$ ;IF SET, ERROR LOG INHIBITED
	INCW	UCB$W_ERRCNT(R5)	;INCREMENT NUMBER OF DEVICE ERRORS
	BBS	#UCB$V_ERLOGIP,UCB$W_STS(R5),40$ ;IF SET, ERROR IN PROGRESS
	PUSHR	#^M<R0,R1,R2,R3,R6>	;SAVE REGISTERS
	MOVL	UCB$L_DDB(R5),R3	;GET ADDRESS OF DDB
	MOVL	UCB$L_DDT(R5),R6	;GET ADDRESS OF DDT (from UCB not DDB)
	MOVZWL	DDT$W_ERRORBUF(R6),R1	;GET SIZE OF ERROR LOG BUFFER IN BYTES
	JSB	ERL$ALLOCEMB		;ALLOCATE ERROR MESSAGE BUFFER
	BLBC	R0,30$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,UCB$L_EMB(R5)	;SAVE ADDRESS OF ERROR MESSAGE BUFFER
	BISW	#UCB$M_ERLOGIP,UCB$W_STS(R5) ;SIGNAL ERROR LOGGING IN PROGRESS
	MOVW	5*4(SP),EMB$W_DV_ENTRY(R2) ;INSERT ENTRY TYPE
	ADDL	#EMB$B_DV_CLASS,R2	;POINT TO DEVICE CLASS

	ASSUME	EMB$B_DV_TYPE	EQ	EMB$B_DV_CLASS+1
	MOVW	UCB$B_DEVCLASS(R5),(R2)+ ;INSERT DEVICE CLASS AND TYPE
	MOVL	UCB$L_IRP(R5),R1	;GET ADDRESS OF I/O PACKET

	ASSUME	EMB$L_DV_RQPID	EQ	EMB$B_DV_TYPE+1
	MOVL	IRP$L_PID(R1),(R2)+	;INSERT REQUESTER PROCESS ID

	ASSUME	EMB$W_DV_BOFF	EQ	EMB$L_DV_RQPID+4
	ASSUME	EMB$W_DV_BCNT	EQ	EMB$W_DV_BOFF+2
	MOVL	IRP$W_BOFF(R1),(R2)+	;INSERT TRANSFER PARAMETERS

	ASSUME	EMB$L_DV_MEDIA	EQ	EMB$W_DV_BCNT+2
	MOVL	UCB$L_MEDIA(R5),(R2)+	;INSERT SIZE OF DISK

	ASSUME	EMB$W_DV_UNIT	EQ	EMB$L_DV_MEDIA+4
	MOVW	UCB$W_UNIT(R5),(R2)+	;INSERT UNIT NUMBER

	ASSUME	EMB$W_DV_ERRCNT	EQ	EMB$W_DV_UNIT+2
	MOVW	UCB$W_ERRCNT(R5),(R2)+	;INSERT NUMBER OF DEVICE ERRORS

	ASSUME	EMB$L_DV_OPCNT	EQ	EMB$W_DV_ERRCNT+2
	MOVL	UCB$L_OPCNT(R5),(R2)+	;INSERT OPERATIONS COMPLETED

	ASSUME	EMB$L_DV_OWNUIC	EQ	EMB$L_DV_OPCNT+4
	MOVL	UCB$L_ORB(R5),R0	;GET ORB ADDRESS
	MOVL	ORB$L_OWNER(R0),(R2)+	;INSERT VOLUME OWNER UIC

	ASSUME	EMB$L_DV_CHAR	EQ	EMB$L_DV_OWNUIC+4
	MOVL	UCB$L_DEVCHAR(R5),(R2)+	;INSERT DEVICE CHARACTERISTICS

	ASSUME	EMB$B_DV_SLAVE	EQ	EMB$L_DV_CHAR+4
	MOVZBW	UCB$B_SLAVE(R5),(R2)+	;INSERT SLAVE UNIT NUMBER

	ASSUME	EMB$W_DV_FUNC	EQ	EMB$B_DV_SLAVE+2
	MOVW	IRP$W_FUNC(R1),(R2)+	;INSERT FUNCTION VALUE

	ASSUME	EMB$T_DV_NAME	EQ	EMB$W_DV_FUNC+2
	ADDL3	#EMB$L_DV_REGSAV-EMB$T_DV_NAME,R2,-(SP) ;CALCULATE ADDRESS OF REGISTERS
	BSBW	ERL$GETFULLNAME		; Copy full device name
	POPL	R0			; Restore address of register dump area
	JSB	@DDT$L_REGDUMP(R6)	;CALL REGISTER DUMP ROUTINE
30$:	POPR	#^M<R0,R1,R2,R3,R6>	;RESTORE REGISTERS
40$:	ADDL2	#4,SP			;REMOVE ENTRY TYPE FROM STACK
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	LOG ASYCHRONOUS DEVICE ATTENTIONS

;+
; ERL$DEVICEATTN - Log asychronous device attention interrupts that are
;	not related to the current I/O operation that may be in progress.
;
; INPUTS:
;
;	R5 => UCB
;
; OUTPUTS:
;
;	If error logging is enabled for the device, an error log buffer
;	is allocated, filled in and released.  There may be an error log
;	in progress for the current device, but this is not taken into
;	account since the current attention interrupt is not related to
;	the I/O that may be in progress.
;
;-

ERL$DEVICEATTN::

	PUSHR	#^M<R0,R1,R2,R3,R6>	; Save registers.
	MOVL	UCB$L_DDT(R5),R6	; Get address of DDT.
	MOVZWL	DDT$W_ERRORBUF(R6),R1	; R1=size of error log buffer in bytes.
	INCW	UCB$W_ERRCNT(R5)	; Increment number of device errors.
	BBC	#DEV$V_ELG,-
		UCB$L_DEVCHAR(R5),30$	; If clr, error log disabled.
	BSBW	ERL$ALLOCEMB		; Allocate error message buffer.
	BLBC	R0,30$			; If LBC allocation failure.
	PUSHL	R2			; Save address of allocated buffer.
	MOVW	#EMB$C_DA,-
		EMB$W_DV_ENTRY(R2)	; Insert entry type.
	MOVW	UCB$W_STS(R5),-		; Save device status in buffer.
		EMB$W_DV_STS(R2)
	CLRQ	EMB$Q_DV_IOSB(R2)	; Clear irrelevant field.

	ADDL	#EMB$B_DV_CLASS,R2	; R2 => device class field.

	ASSUME	EMB$B_DV_TYPE	EQ	EMB$B_DV_CLASS+1
	MOVW	UCB$B_DEVCLASS(R5),(R2)+ ; Insert device class and type.

	ASSUME	EMB$L_DV_RQPID	EQ	EMB$B_DV_TYPE+1
	ASSUME	EMB$W_DV_BOFF	EQ	EMB$L_DV_RQPID+4
	ASSUME	EMB$W_DV_BCNT	EQ	EMB$W_DV_BOFF+2
	CLRQ	(R2)+			; Clear PID, BOFF and BCNT.

	ASSUME	EMB$L_DV_MEDIA	EQ	EMB$W_DV_BCNT+2
	MOVL	UCB$L_MEDIA(R5),(R2)+	; Insert size of disk.

	ASSUME	EMB$W_DV_UNIT	EQ	EMB$L_DV_MEDIA+4
	MOVW	UCB$W_UNIT(R5),(R2)+	; Insert unit number.

	ASSUME	EMB$W_DV_ERRCNT	EQ	EMB$W_DV_UNIT+2
	MOVW	UCB$W_ERRCNT(R5),(R2)+	; Insert number of device errors.

	ASSUME	EMB$L_DV_OPCNT	EQ	EMB$W_DV_ERRCNT+2
	MOVL	UCB$L_OPCNT(R5),(R2)+	; Insert operations completed.

	ASSUME	EMB$L_DV_OWNUIC	EQ	EMB$L_DV_OPCNT+4
	MOVL	UCB$L_ORB(R5),R0	;GET ORB ADDRESS
	MOVL	ORB$L_OWNER(R0),(R2)+	; Insert volume owner uic.

	ASSUME	EMB$L_DV_CHAR	EQ	EMB$L_DV_OWNUIC+4
	MOVL	UCB$L_DEVCHAR(R5),(R2)+	; Insert device characteristics.

	ASSUME	EMB$B_DV_SLAVE	EQ	EMB$L_DV_CHAR+4
	MOVZBW	UCB$B_SLAVE(R5),(R2)+	; Insert slave unit number.

	ASSUME	EMB$W_DV_FUNC	EQ	EMB$B_DV_SLAVE+2
	CLRW	(R2)+			; Clear irrelevant function value.

	ASSUME	EMB$T_DV_NAME	EQ	EMB$W_DV_FUNC+2
	ADDL3	#EMB$L_DV_REGSAV-EMB$T_DV_NAME,R2,-(SP) ;CALCULATE ADDRESS OF REGISTERS
	MOVL	UCB$L_DDB(R5),R3	; Get address of DDB
	BSBW	ERL$GETFULLNAME		; Copy full device name
	POPL	R0			; Restore address of register dump area
	MOVL	DDT$L_REGDUMP(R6),R1	; R1 => register dump routine.
	JSB	(R1)			; Call register dump routine.
	POPL	R2			; Restore address of allocated buffer.
	BSBW	ERL$RELEASEMB		; Release this error log buffer.
30$:	POPR	#^M<R0,R1,R2,R3,R6>	; Restore registers.
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	LOG SOFTWARE STATUS

;+
; ERL$LOGSTATUS - Log software status corresponding to a logged message.
;
; INPUTS:
;	R0-R1 contain final I/O status
;	R2 => MSCP end message
;	R3 => UCB
;	R5 => CDRP
;
; OUTPUTS:
;	An error log message (format EMBSPDEF) is allocated and filled in.
;	All registers are preserved.
;-

ERL$LOGSTATUS::

	INCW	UCB$W_ERRCNT(R3)	; Increment number of device errors.
	BBC	#DEV$V_ELG,-		; If clear, error log disabled.
		UCB$L_DEVCHAR(R3),20$

	MOVQ	R0,-(SP)		; Save R0, R1, R2.
	PUSHL	R2
	MOVZWL	#EMB$K_SP_LENGTH,R1	; R1 contains length of buffer to alloc
	BSBW	ERL$ALLOCEMB		; Allocate error message buffer.
	BLBC	R0,10$			; LBC implies allocation failure.

	MOVW	#EMB$C_SP,-		; Indicate type of error log buffer.
		EMB$W_SP_ENTRY(R2)
	MOVAB	EMB$B_SP_CLASS(R2),R0	; R0 => where to begin filling.

	ASSUME	UCB$B_DEVTYPE	EQ	UCB$B_DEVCLASS+1
	ASSUME	EMB$B_SP_TYPE	EQ	EMB$B_SP_CLASS+1
	MOVW	UCB$B_DEVCLASS(R3),(R0)+; Move Device type and class.

	ASSUME	EMB$W_SP_BOFF	EQ	EMB$B_SP_TYPE+1
	MOVW	CDRP$W_BOFF(R5),(R0)+	; Copy BOFF.

	ASSUME	EMB$L_SP_BCNT	EQ	EMB$W_SP_BOFF+2
	MOVL	CDRP$L_BCNT(R5),(R0)+	; Also byte count.

	ASSUME	EMB$L_SP_MEDIA	EQ	EMB$L_SP_BCNT+4
	MOVL	CDRP$L_MEDIA(R5),(R0)+	; Move media address (LBN).

	ASSUME	EMB$L_SP_RQPID	EQ	EMB$L_SP_MEDIA+4
	MOVL	CDRP$L_PID(R5),(R0)+	; Copy requesting PID.

	ASSUME	EMB$Q_SP_IOSB	EQ	EMB$L_SP_RQPID+4
	MOVQ	4(SP),(R0)+		; Copy saved I/O status to buffer.

	ASSUME	EMB$W_SP_FUNC	EQ	EMB$Q_SP_IOSB+8
	MOVW	CDRP$W_FUNC(R5),(R0)+	; Copy I/O function code.

	ASSUME	EMB$W_SP_UNIT	EQ	EMB$W_SP_FUNC+2
	MOVW	UCB$W_UNIT(R3),(R0)+	; Copy unit number.

	ASSUME	EMB$L_SP_OPCNT	EQ	EMB$W_SP_UNIT+2
	MOVL	UCB$L_OPCNT(R3),(R0)+	; Copy cummulative operation count.

	ASSUME	EMB$W_SP_ERRCNT	EQ	EMB$L_SP_OPCNT+4
	MOVW	UCB$W_ERRCNT(R3),(R0)+	; And also cummulative error count.

	ASSUME	EMB$W_SP_UCBSTS	EQ	EMB$W_SP_ERRCNT+2
	MOVW	UCB$W_STS(R3),(R0)+	; Copy UCB STS field.

	ASSUME	EMB$L_SP_OWNUIC	EQ	EMB$W_SP_UCBSTS+2
	MOVL	UCB$L_ORB(R3),R1	;GET ORB ADDRESS
	MOVL	ORB$L_OWNER(R1),(R0)+	; Copy device owner UIC.

	ASSUME	EMB$L_SP_CHAR	EQ	EMB$L_SP_OWNUIC+4
	MOVL	UCB$L_DEVCHAR(R3),(R0)+	; Copy device characteristics.

	ASSUME	EMB$L_SP_CMDREF	EQ	EMB$L_SP_CHAR+4
	MOVL	(SP),R1			; R1 => MSCP end message.
	MOVL	MSCP$L_CMD_REF(R1),(R0)+; Copy command reference number (RSPID).

	ASSUME	EMB$T_SP_DEVNAM	EQ	EMB$L_SP_CMDREF+4
	MOVQ	R2,-(SP)		; Save UCB & buffer base address(R2,R3)
	MOVL	R0,R2			; Get buffer adderss
	MOVL	UCB$L_DDB(R3),R3	; Get DDB address
	BSBW	ERL$GETFULLNAME		; Copy full device name
	MOVQ	(SP)+,R2		; Restore R2 and R3

	BSBW	ERL$RELEASEMB		; Release filled in error buffer.
10$:
	POPL	R2			; Restore registers R2, R1, R0.
	MOVQ	(SP)+,R0
20$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	LOG DRIVER MESSAGE

;+
; ERL$LOGMESSAGE - Subroutine to allocate a message buffer, fill in a
;	standard header, and then copy caller specified test to the rest
;	of the buffer.
;
; INPUTS:
;	R0 =  Code specifying message sub type.
;	R1 =  length of caller specified text
;	R2 => caller text
;	R3 => UCB
;
; OUTPUTS:
;	Message allocated and filled.  All registers preserved.
;-

ERL$LOGMESSAGE::

	INCW	UCB$W_ERRCNT(R3)	; Increment total number of errors.
	BBC	#DEV$V_ELG,-		; Clear means error logging inhibited.
		UCB$L_DEVCHAR(R3),20$

	MOVQ	R0,-(SP)		; Save registers R0-R5.
	MOVQ	R2,-(SP)
	MOVQ	R4,-(SP)
	ADDL	#EMB$K_LM_LENGTH,R1	; Add message header to caller's length.
	BSBW	ERL$ALLOCEMB		; Allocate buffer.
	BLBC	R0,10$			; LBC means allocation failure.

	PUSHL	R2			; Save address of buffer.
	MOVW	#EMB$C_LM,-		; Indicate type of error log buffer.
		EMB$W_LM_ENTRY(R2)

	ASSUME	UCB$B_DEVTYPE	EQ	UCB$B_DEVCLASS+1
	ASSUME	EMB$B_LM_TYPE	EQ	EMB$B_LM_CLASS+1
	MOVW	UCB$B_DEVCLASS(R3),-	; Begin to fill in buffer.  Copy
		EMB$B_LM_CLASS(R2)	;  Device type and class.

	MOVW	UCB$W_UNIT(R3),-	; Also copy device unit number.
		EMB$W_LM_UNIT(R2)

	PUSHL	R3			; Save UCB
	MOVAL	EMB$T_LM_DEVNAM(R2),R2	; Get buffer address for device name
	MOVL	UCB$L_DDB(R3),R3	; Get DDB address
	BSBW	ERL$GETFULLNAME		; Copy full device name
	POPL	R3			; Restore UCB
	MOVL	(SP),R2			; Restore buffer base address

	MOVW	20(SP),EMB$W_LM_MSGTYP(R2)	 ; Copy message subtype.
	MOVL	12(SP),R1			 ; R1 => caller's text.
	MOVC3	24(SP),(R1),EMB$W_LM_MSGTYP+2(R2); Copy caller's text.
	POPL	R2				 ; R2 => allocated buffer.
	BSBW	ERL$RELEASEMB			 ; Release buffer.
10$:
	MOVQ	(SP)+,R4		; Restore Registers R0-R5.
	MOVQ	(SP)+,R2
	MOVQ	(SP)+,R0
20$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	ERL$LOG_DMSCP and ERL$LOG_TMSCP

;+
; Routines that respectively log invalid Disk and Tape MSCP messages.
;
; Inputs:
;	R0 =  type of message
;	R1 =  length of message
;	R2 => message
;	R3 => CDDB
;
; Outputs:
;	All registers preserved.
;
;	We want to log the following items in addition to the message
;	and its type:
;
;		1. CDDB$B_SYSTEMID (6 bytes)
;		2. The ASCII string "DISK" (4 bytes) or "TAPE" (4 bytes)
;		3. CDDB$Q_CNTRLID (8 bytes)
;

	.enabl	lsb

ERL$LOG_TMSCP::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVL	#^A/TAPE/,R4		; R4 has string "TAPE".
	BRB	10$			; Branch around to common code.
ERL$LOG_DMSCP::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVL	#^A/DISK/,R4		; R4 has string "DISK".
10$:
	ADDL	#<2+4+6+8 -		; R1 has length which is bumped by
		 +EMB$K_HD_LENGTH>,R1	;  2 for the type, 4 for "DISK" or 
					;  "TAPE", 6 for SYSTEMID, 8 for 
					;  CNTRLID, and errorlog entry header 
					;  size.
	BSBW	ERL$ALLOCEMB		; Allocate Errorlog Buffer.
	BLBC	R0,20$			; LBC means no allocate.
	PUSHL	R2			; Save R2=>Buffer.
	MOVW	#EMB$C_LOGMSCP,-	; Copy message class to buffer header.
		EMB$W_HD_ENTRY(R2)
	ADDL	#EMB$K_HD_LENGTH,R2	; R2 => beyond header.
	MOVW	4(SP),(R2)+		; Copy message type (from saved regs).
	MOVL	R4,(R2)+		; Copy Class driver type.
	MOVQ	CDDB$Q_CNTRLID(R3),(R2)+; Controller identifier.
	MOVQ	CDDB$B_SYSTEMID(R3),(R2)+;And System ID.
	MOVC3	8(SP),-			; Get length from saved registers.
		@12(SP),-		;  also source address.
		-2(R2)			; Target is -2 since SYSTEMID is 6 bytes.
	POPL	R2			; Restore R2=>Buffer.
	BSBW	ERL$RELEASEMB		; Free Errorlog buffer.
20$:
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	RSB
	.dsabl	lsb
	.PAGE
	.SBTTL	BUILD STARTUP AND POWERFAIL MESSAGES
;+
; ERL$COLDSTART - LOG COLDSTART (SYSTEMBOOT)
;
; THIS ROUTINE IS CALLED BY SYSINIT AFTER CORRECTLY SETTING THE SYSTEM
; TIME TO LOG THE BOOTING OF THE SYSTEM.
;
; ERL$WARMSTART - LOG WARMSTART (POWER RECOVERY)
;
; THIS ROUTINE IS CALLED BY POWERFAIL AFTER CORRECTING THE SYSTEM TIME
; TO LOG THE POWER FAIL AND RECOVERY.
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;
; AN ERROR LOG BUFFER IS ALLOCATED AND FILLED WITH THE APPROPRIATE MESSAGE
; IF POSSIBLE AND THE ERROR LOG PROCESS AWAKENED IF NECESSARY.
;-
	.ENABL	LSB
ERL$COLDSTART::				;
	MOVZWL	#EMB$C_CS,R3		;SET TYPE OF MESSAGE TO COLDSTART
	BRB	10$			;
ERL$WARMSTART::				;
	MOVZWL	#EMB$C_WS,R3		;SET TYPE OF MESSAGE TO WARMSTART
10$:	MOVZWL	#EMB$C_SU_LENGTH,R1	;SET SIZE OF MESSAGE TO ALLOCATE
	BSBB	ERL$ALLOCEMB		;ALLOCATE AN ERROR LOG BUFFER
	BLBC	R0,20$			;BRANCH IF NONE AVAILABLE
	JSB	EXE$READ_TODR		;GET TIME TO LOG
	MOVL	R0,EMB$L_SU_DAYTIM(R2)	;LOG TIME OF DAY CLOCK
	MOVW	R3,EMB$W_SU_ENTRY(R2)	;SET MESSAGE TYPE
	BSBW	ERL$RELEASEMB		;RELEASE BUFFER
20$:	RSB				;
	.DSABL	LSB			;
	.PAGE
	.SBTTL	ALLOCATE ERROR MESSAGE BUFFER
;+
; ERL$ALLOCEMB - ALLOCATE ERROR MESSAGE BUFFER
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN ERROR LOG MESSAGE BUFFER AND
; INITIALIZE ITS HEADER.
;
; INPUTS:
;
;	R1 = SIZE OF MESSAGE BUFFER REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES AN ALLOCATION FAILURE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL ALLOCATION WITH:
;
;		R1 = ERROR SEQUENCE NUMBER.
;		R2 = ADDRESS OF ALLOCATED ERROR MESSAGE BUFFER.
;
;	IN EITHER CASE THE UNIVERSAL ERROR SEQUENCE NUMBER IS INCREMENTED
;	AND STORED IN THE BUFFER AT THE STANDARD PLACE, ALONG WITH THE TIME.
;	AND THE ERROR LOG PROCESS MAY BE AWAKENED IF AN ERROR ALLOCATION
;	BUFFER IS FOUND TO BE FULL.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
ERL$ALLOCEMB::				;ALLOCATE ERROR MESSAGE BUFFER
	DSBINT				;DISABLE ALL INTERRUPTS
	ADDL	#EMB$K_LENGTH,R1	; Add in size of header for message
	MOVZBL	ERL$GB_BUFIND,R0	;GET CURRENT ALLOCATION BUFFER INDICATOR
	MOVL	ERL$AL_BUFADDR[R0],R0	;GET ADDRESS OF ALLOCATION BUFFER DESCRIPTOR
	BBS	#ERL$V_LOCK,ERL$B_FLAGS(R0),15$; IF SET, BUFFER BEING COPIED
10$:	MOVL	ERL$L_NEXT(R0),R2	;GET ADDRESS OF NEXT AVAILABLE SPACE
	ADDL3	R1,R2,ERL$L_NEXT(R0)	;CALCULATE ADDRESS OF NEXT AVAILABLE SPACE
	CMPL	ERL$L_END(R0),ERL$L_NEXT(R0) ;ENTRY FIT WITHIN BUFFER?
	BGEQU	20$			;IF GEQU YES
	BISB	#ERL$M_TIMER,ERL$GB_BUFFLAG ;SET TIMER ACTIVE
	MOVB	#1,ERL$GB_BUFTIM	;FORCE ERROR LOG PROCESS WAKE
15$:	MOVL	ERL$L_END(R0),ERL$L_NEXT(R0) ;INDICATE THAT BUFFER IS FULL
	XORB	#1,ERL$GB_BUFIND	;SWITCH TO ALTERNATE BUFFER
	MOVZBL	ERL$GB_BUFIND,R0	;GET NEW BUFFER INDICATOR
	MOVL	ERL$AL_BUFADDR[R0],R0	;GET ADDRESS OF ALLOCATION BUFFER DESCRIPTOR
	BBS	#ERL$V_LOCK,ERL$B_FLAGS(R0),17$; IF SET, BUFFER BEING COPIED
	ADDL3	R1,ERL$L_NEXT(R0),R2	;CALCULATE ADDRESS OF NEXT AVAILABLE SPACE
	CMPL	ERL$L_END(R0),R2	;ENTRY FIT WITHIN BUFFER?
	BGEQU	10$			;IF GEQU YES
17$:	MOVL	ERL$L_END(R0),ERL$L_NEXT(R0) ;INDICATE THAT BUFFER IS FULL
	CLRL	R0			;INDICATE ALLOCATION FAILURE
	BRB	30$			;
20$:	ADDL	#EMB$K_LENGTH,R2	; Point past the message header
	MFPR	#PR$_SID,EMB$L_HD_SID(R2)	; Set system ID into message
	MOVZWL	R1,EMB$W_SIZE(R2)	; Set size in message header
	MOVB	ERL$B_BUFIND(R0),EMB$B_BUFIND(R2) ;SET RESPECTIVE BUFFER INDICATOR
	INCB	ERL$B_BUSY(R0)		;INCREMENT MESSAGE BUSY COUNT
	MOVL	ERL$GL_SEQUENCE,R1	;GET CURRENT ERROR SEQUENCE NUMBER
	MOVQ	EXE$GQ_SYSTIME,EMB$Q_DV_TIME(R2) ;INSERT CURRENT TIME
	MOVW	R1,EMB$W_DV_ERRSEQ(R2)	;INSERT ERROR SEQUENCE NUMBER
	MOVL	#1,R0			;SET SUCCESS INDICATOR
30$:	INCL	ERL$GL_SEQUENCE		;INCREMENT UNIVERSAL ERROR SEQUENCE NUMBER
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	GET FULL DEVICE NAME
;+
; ERL$GETFULLNAME - GET FULL DEVICE NAME
;
; THIS ROUTINE IS CALLED TO COPY THE FULL DEVICE NAME (NODE NAME + DEVICE NAME)
; TO THE ERROR LOG BUFFER.
;
; INPUTS:
;
;	R3 = address of DDB
;	R2 = address of error log buffer
;
; OUTPUTS:
;
;	If a node name exist in the system block, it is copied with the
;	device name to the error log buffer.
;
;	R0, R1, AND R3 ARE DESTROYED ACROSS CALL.
;-

ERL$GETFULLNAME::
	MOVAB	DDB$T_NAME(R3),R1	; Get address of device name.
	MOVZBL	(R1)+,-(SP)		; Save the string length
	MOVL	DDB$L_SB(R3),R3		; Get address of system block
	BEQL	20$			; If EQL, go to move device name
	MOVAB	SB$T_NODENAME(R3),R3	; Get address of nodename
	MOVZBL	(R3)+,R0		; Get nodename length
	BEQL	20$			; If eql, go move device name
	ADDB3	R0,(SP),(R2)		; Nodename length + device name 
	INCB	(R2)+			; Total string len. + 1 for "$"
10$:	MOVB	(R3)+,(R2)+		; Copy nodename
	SOBGTR	R0,10$
	MOVB	#^A/$/,(R2)+		; Insert the "$"
	BRB	30$			; Go move device name
20$:	MOVB	(SP),(R2)+		; Move dev. name len. to buffer
30$:	MOVL	(SP)+,R0		; Get dev. name length
40$:	MOVB	(R1)+,(R2)+		; Move device name into buffer
	SOBGTR	R0,40$
	RSB				; Return to caller
 
	.PAGE
	.SBTTL	RELEASE ERROR MESSAGE BUFFER
;+
; ERL$RELEASEMB - RELEASE ERROR MESSAGE BUFFER
;
; THIS ROUTINE IS CALLED TO RELEASE AN ERROR MESSAGE BUFFER FOR PROCESSING
; BY THE ERROR LOG PROCESS.
;
; INPUTS:
;
;	R2 = ADDRESS OF ERROR MESSAGE BUFFER.
;
; OUTPUTS:
;
;	THE COMPLETED ERROR MESSAGE COUNT IS INCREMENTED IN THE RESPECTIVE
;	ALLOCATION BUFFER HEADER, THE MESSAGE IS SET VALID, AND THE BUSY
;	MESSAGE COUNT IS DECREMENTED IN THE RESPECTIVE ALLOCATION BUFFER
;	HEADER.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
ERL$RELEASEMB::				;RELEASE ERROR MESSAGE BUFFER
	INCB	EMB$B_VALID(R2)		;SET MESSAGE BUFFER VALID
	MOVZBL	EMB$B_BUFIND(R2),R0	;GET BUFFER INDICATOR OF ALLOCATION BUFFER
	MOVL	ERL$AL_BUFADDR[R0],R0	;GET ADDRESS OF ALLOCATION BUFFER DESCRIPTOR
	ADAWI	#^XFF,ERL$B_BUSY(R0)	;ADJUST BUSY AND COMPLETED MESSAGE COUNT
	BBCS	#ERL$V_TIMER,ERL$GB_BUFFLAG,10$ ;IF CLR, NO TIMER RUNNING
	CMPB	#MAXMSG,ERL$B_MSGCNT(R0) ;MAXIMUM NUMBER OF MESSAGES EXCEEDED?
	BGTRU	10$			;IF GTRU NO
	MOVB	#1,ERL$GB_BUFTIM	;FORCE ERROR LOG PROCESS WAKE
10$:	RSB				;
	.PAGE
	.SBTTL	WAKE ERROR LOG FORMAT PROCESS
;+
; ERL$WAKE - WAKE ERROR LOG FORMAT PROCESS
;
; THIS ROUTINE IS CALLED ONCE A SECOND WHEN THE ERROR BUFFER TIMER IS ACTIVE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE ERROR BUFFER TIMER IS DECREMENTED AND IF THE RESULT IS ZERO THE
;	ERROR LOG FORMAT PROCESS IS AWAKENED.
;-
 
ERL$WAKE::				;WAKE ERROR LOG FORMAT PROCESS
	DECB	ERL$GB_BUFTIM		;DECREMENT TIMER
	BNEQ	10$			;
	BICB	#ERL$M_TIMER,ERL$GB_BUFFLAG ;CLEAR TIMER ACTIVE FLAG
	MOVB	#MAXTIM,ERL$GB_BUFTIM	;RESET TIMER VALUE
	MOVL	ERL$GL_ERLPID,R1	;GET ERROR LOG PROCESS ID
	BSBW	SCH$WAKE		;WAKE ERROR LOG PROCESS
10$:	RSB				;
 
	.END
	
