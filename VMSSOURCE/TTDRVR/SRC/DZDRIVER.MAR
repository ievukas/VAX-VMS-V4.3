.if df DZV
	.TITLE	DZVDRIVER - Port Driver for DZV-11 support
.iff
	.TITLE	DZDRIVER - Port Driver for DZ-11 support
.endc
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	DZ PORT DRIVER
;	This module functions as a port driver for DZ11 and DZ32 terminal
;	controllers. It contains hardware specific port level service
;	routines.
;
; AUTHOR:
;
;	RICK SPITZ
;
; Revision history:
;
;	V03-028	MIR0480		Michael I.Rosenblum	8-Aug-1984
;		Fix bugs found in testing the DZ-32 and reported in
;		QAR 1126 (FT1).
;
;	V03-027	LMP0275		L. Mark Pilant,		12-Jul-1984  21:01
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-026 EMD0090		Ellen M. Dusseault	30-Apr-1984
;		Add DEV$M_NNM characteristic to DEVCHAR2 so that these
;		devices will have the "node$" prefix.
;
;	V03-025	LMP0221		L. Mark Pilant,		7-Apr-1984  13:37
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-024	JLV0321		Jake VanNoy		 5-JAN-1984
;		Minor enhancements to DZV11 support. Comment out
;		DPT_STORE for parity, must fix a restriction.
;
;	V03-023	MIR0055		Michael I. Rosenblum		30-June-1983
;		Remove code from unit and controler-init routines
;		and make insert calls to class driver macros
;		Add DZV11 support.
;
;	V03-022	RKS0022		RICK SPITZ			14-MAR-1983
;		ADD ENHANCEMENTS TO SUPPORT LOGICAL UCB. 
;
;	V03-021	MIR0022		Michael I. Rosenblum		19-Jan-1982
;		Change references to UCB$B_ERTCNT to use UCB$W_TT_UNITBIT
;		to be more maintainable.
;		Replace old vector table with new vector table macro.
;		Remove references to UCB$L_DEVDEPEND and UCB$Q_TT_STATE
;		move these references into the class driver jacket routines
;
;	V03-020	MIR0021		Michael I. Rosenblum		17-Jan-1983
;		Fix DZ32 DZ_SET table entry.
;
;	V03-019	RKS0019		RICK SPITZ			13-JAN-1983
;		Repair problem with port vector macro
;
;	V03-018	MIR0019		Michael I. Rosenblum		11-Jan-1982
;		Fix undefined symbol created by MIR0018.
;
;	V03-017	MIR0018		Michael I. Rosenblum		07-Jan-1983
;		Change the port vector table to use the $VEC macros
;
;	V03-016	MIR0017		Michael I. Rosenblum		05-Jan-1983
;		Add powerfail check in the Unit init routine to allow the
;		terminal class drier to take positive action on powerfail.
;		Change code to accept a byte value as returns from the
;		GETNXT and PUTNXT class survices, this will removes this
;		information from the condition codes.
;		
;	V03-015	MIR0016		Michael I. Rosenblum		29-Dec-1982
;		Replace time calculation code with TIMSET macro call
;
;	V03-014	MIR0015		Michael I. Rosenblum		20-Dec-1982
;		Remove entry point to reflect the redefinition of the PORT_DISCONNECT
;		entry point.
;
;	V03-013 MIR0014		Michael I. Rosenblum		17-Dec-1982
;		Remove code to calculate flow control characters from
;		port XON and XOFF routines and move that code into 
;		the class driver.
;
;	V03-012	RKS0012		RICK SPITZ		16-SEP-1982
;		Check reference count in unit init to determine if
;		modem control should be initialized or hungup. This
;		is needed to insure that a hangup ^Y is posted on
;		powerfail for modem lines.
;
;	V03-011	JLV0211		Jake VanNoy		 2-JUL-1982
;		Remove check for powerfail in unit init that prevents
;		SETUP_UCB from being called. This insures that UCB fields
;		are initialized correctly when Unit init is called for
;		use with CSS unibus switch.
;
;	V03-010	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DEVDEF, $IPLDEF, $PRDEF, and $SSDEF.
;
;
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; EXTERNAL DEFINITIONS:
;
	$ACBDEF				; DEFINE ACB
	$CRBDEF				; DEFINE CRB
	$DCDEF				; DEVICE DEFINITIONS
	$DDBDEF				; DEFINE DDB
	$DEVDEF				; DEFINE DEVICE TYPES
	$DYNDEF				; DYNAMIC STRUCTURE DEFINITONS
	$IDBDEF				; DEFINE IDB OFFSETS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				; IRP DEFINITIONS
	$ORBDEF				; DEFINE OBJECT'S RIGHTS BLOCK OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL TYPES
	$TT2DEF				; DEFINE EXTENDED DEFINITIONS
	$TQEDEF				; DEFINE TIMER QUEUE OFFSETS
	$UCBDEF				; DEFINE UCB
	$UBADEF				; DEFINE UBA
	$VECDEF				; DEFINE VECTOR FOR CRB
	$TTYMACS			; DEFINE TERMINAL DRIVER MACROS
	$TTYDEFS			; DEFINE TERMINAL DRIVER SYMBOLS
	$TTYMODEM			; DEFINE MODEM DEFINITIONS


;
; LOCAL STORAGE
;
	.PSECT	$$$105_PROLOGUE

;
; Driver prologue table:
;

DZ$DPT::				; DRIVER START
.IF DF DZV
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=DZ$END,-		; End and offset to INIT's vectors
		UCBSIZE=UCB$C_TT_LENGTH,- ; SIZE OF UCB
		FLAGS=DPT$M_NOUNLOAD,-	; DO NOT ALLOW UNLOAD
		ADAPTER=UBA,-		; ADAPTER TYPE
		DEFUNITS=4,-		; DZV has 4 units
		NAME=DZDRIVER,-		; NAME OF DRIVER
		VECTOR=PORT_VECTOR	; PORT DRIVER VECTOR TABLE
.IFF
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=DZ$END,-		; End and offset to INIT's vectors
		UCBSIZE=UCB$C_TT_LENGTH,- ; SIZE OF UCB
		FLAGS=DPT$M_NOUNLOAD,-	; DO NOT ALLOW UNLOAD
		ADAPTER=UBA,-		; ADAPTER TYPE
		DEFUNITS=8,-		; Number of units to create
		NAME=DZDRIVER,-		; NAME OF DRIVER
		VECTOR=PORT_VECTOR	; PORT DRIVER VECTOR TABLE
.ENDC
	DPT_STORE INIT
	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-; CHARACTERISTICS
			DEV$M_REC!-	;
			DEV$M_AVL!-	;
			DEV$M_IDV!-	;
			DEV$M_ODV!-	;
			DEV$M_TRM!-	;
			DEV$M_CCL>
    	DPT_STORE UCB,UCB$L_DEVCHAR2,L,- ; Device Characteristics
    			<DEV$M_NNM>	 ; prefix with "node$"
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM;
	DPT_STORE UCB,UCB$B_TT_DETYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_TT_DESIZE,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_TT_DECHAR,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_TT_DECHA1,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_DESPEE,@B,TTY$GB_DEFSPEED; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_DESPEE+1,@B,TTY$GB_RSPEED; DEFAULT SPEED
	DPT_STORE UCB,UCB$B_TT_DEPARI,@B,TTY$GB_PARITY	; DEFAULT PARITY 
;	DPT_STORE UCB,UCB$B_TT_PARITY,@B,TTY$GB_PARITY	; DEFAULT PARITY
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_DEVDEPND2,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_SPEED,@B,TTY$GB_DEFSPEED	; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_SPEED+1,@B,TTY$GB_RSPEED	; DEFAULT SPEED
	DPT_STORE UCB,UCB$B_DIPL,B,21			; DEVICE IPL
	DPT_STORE UCB,UCB$L_TT_WFLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_WBLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_RTIMOU,L,0		; Zero read timed out disp.
	DPT_STORE ORB,ORB$B_FLAGS,B,-		; Protection block flags
			   <ORB$M_PROT_16>	; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,@W,TTY$GW_PROT ; Default allocation protection
	DPT_STORE ORB,ORB$L_OWNER,@L,TTY$GL_OWNUIC ; Default owner UIC
	DPT_STORE DDB,DDB$L_DDT,D,DZ$DDT

	DPT_STORE REINIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,DZ$INITIAL  ; CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,DZ$INITLINE; UNIT INIT
	DPT_STORE END

	DDTAB	DEVNAM = DZ,-	; DUMMY DZ PORT DRIVER DISPATCH TABLE
		START  = 0,-
		FUNCTB = 0

	.PSECT	$$$115_DRIVER

;
; THE ASSOCIATED CLASS DRIVER USES THIS TABLE TO COMMAND THE PORT DRIVER.
; THE ADDRESS OF THIS TABLE IS CONTAINED IN THE TERMINAL UCB EXTENSION AREA.
; THE OFFSET DEFINITONS ARE DEFINED BY TTYDEFS.
;

PORT_VECTOR:			

;
; DZ-11 SPECIFIC DISPATCH TABLE
;
	$VECINI	DZ11,DZ$NULL
	$VEC	STARTIO,DZ11$STARTIO
	$VEC	SET_LINE,DZ$SET_LINE
	$VEC	DS_SET,DZ11$DS_SET
	$VEC	XON,DZ11$XON
	$VEC	XOFF,DZ11$XOFF
	$VEC	STOP,DZ$STOP
	$VEC	ABORT,DZ$ABORT
	$VEC	RESUME,DZ11$RESUME
	$VEC	SET_MODEM,DZ11$SET_MODEM
	$VEC	MAINT,DZ11$MAINT
.IF NDF DZV
	$VECEND	END=NO
;
; DZ-32 SPECIFIC DISPATCH TABLE
;

	$VECINI	DZ32,DZ$NULL
	$VEC	STARTIO,DZ32$STARTIO		; START NEW OUTPUT
	$VEC	SET_LINE,DZ$SET_LINE		; SET NEW PARITY/SPEED
	$VEC	DS_SET,DZ32$DS_SET		; SET NEW OUTPUT MODEM SIGNALS
	$VEC	XON,DZ32$XON			; SEND XON
	$VEC	XOFF,DZ32$XOFF			; SEND XOFF
	$VEC	STOP,DZ$STOP			; STOP CURRENT OUTPUT
	$VEC	ABORT,DZ$ABORT			; ABORT CURRENT OUTPUT
	$VEC	RESUME,DZ32$RESUME		; RESUME STOPPED OUTPUT
	$VEC	MAINT,DZ32$MAINT		; INVOKE MAINTENANCE FUNCTIONS
.ENDC
	$VECEND
DZ$NULL:					; NULL PORT ROUTINE
	RSB


	.PAGE
	.SBTTL	REGISTER DEFINITIONS
 
;
; CSR BIT DEFINITIONS ( CSR ) ( READ/WRITE )
;
	$VIELD	DZCSR,0,<-
		<MODE,1,M>,-	; DZ32 - MODE/ DZ11 - UNUSED
		<DS_ENAB,1,M>,-	; DZ32 - DATA SET INTERRUPT ENABLE
		<,1,>,-		; UNUSED
		<MAINT,1,M>,-	; LINE TURNAROUND
		<CLEAR,1,M>,-	; MASTER RESET
		<MASTENAB,1,M>,-; MASTER SCAN ENABLE
		<RCVINT,1,M>,-	; RECEIVER INTERRUPT ENABLE
		<RCVRDY,1,M>,-	; RECEIVER READY
		<LINE,3,M>,-	; LINE NUMBAE (0 - 7)
		<DS_CHG,1,M>,-	; DZ32 - DATA SET INTERRUPT
		<,2,>,-		; UNUSED
		<SNDINT,1,M>,-	; TRANSMIT INTERRUPT ENABLE
		<SNDRDY,1,M>-	; TRANSMITTER READY
		> 
;
; RECEIVER BUFFER ( CSR+2 ) ( READ ONLY )
;
	$VIELD	DZRCV,0,<-
		<BUF,8,M>,-	; RECEIVER DATA
		<LINE,3,M>,-	; LINE NUMBER (0 - 7)
		<,1,>,-
		<PARERR,1,M>,-	; PARITY ERROR
		<FRAMER,1,M>,-	; FRAME ERROR
		<OVERRUN,1,M>,-	; OVERRUN ERROR
		<VALID,1,M>-	; DATA VALID
		> 
;
; LINE PARAMETER REGISTER ( CSR+2 ) ( WRITE ONLY )
;
 
	$VIELD	DZLPR,0,<-
		<LINE,3,M>,-	; LINE NUMBER (0-7)
		<SIZE,2,M>,-	; CHARACTER SIZE
		<STOP,1,M>,-	; NUMBER STOP BITS
		<PARITY,1,M>,-	; PARITY ENABLE
		<ODD,1,M>,-	; ODD PARITY
		<SPEED,4,M>,-	; LINE SPEED
		<CLOCK,1,M>,-	; RECEIVER CLOCK	 
		<SPLIT,1,M>,-	; DZ32 - SPLIT SPEED
		>

;
; DZ-32 SPECIFIC MODEM CONTROL
;

	$VIELD	DZLCS1,8,<-
		<,7,>,-
		<ACK,1,M>,-	; READY FOR COMMAND/ UPDATE OUTPUT MODEM
		>


	
	.PAGE
	.SBTTL	CONTROLLER INITIALIZATION 



;++
; DZ$INITIAL - INITIALIZE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AT SYSTEM STARTUP AND POWER RECOVERY.
;
; INPUTS:
;
;	R4 = ADDRESS OF THE UNIT CSR
;	R5 = IDB OF UNIT
;	R8 = ADDRESS OF THE UNIT CRB
;
; OUTPUTS:
;
;	R2 is destroyed.
;
; IMPLICIT INPUTS:
;
;	IPL = IPL$_POWER
;
;--
DZ$INITIAL::				; INITIALIZE DZ UNIT

;
; SET UP CONTROLLER
;
	class_ctrl_init	dz$dpt,port_vector

25$:	MOVW	#DZCSR$M_CLEAR,(R4)	; INIT CONTROLLER RESET

;
;	WAIT TILL CONTROLLER INIIALIZATION IS COMPLETE
;
	TIMEWAIT	#500,#DZCSR$M_CLEAR,(R4),W,.FALSE.

	MOVW	#<<DZCSR$M_MASTENAB>!-	;
		<DZCSR$M_RCVINT>!-	; ENABLE RECEIVER INTERRUPTS
		<DZCSR$M_SNDINT>!-	; ENABLE TRANSMITTER INTERRUPTS
		<DZCSR$M_DS_ENAB>!-	; ENABLE DZ-32 DATA SET INTERRUPTS
		<DZCSR$M_MODE>>,(R4)	; ENABLE ENHANCED MODE ON DZ-32
	BLBC	R0,DZ$CTRL_ERROR

	MOVW	(R4),R2			; GET NEW STATUS
	BBS	#DZCSR$V_MODE,R2,110$	; BRANCH IF DZ-32 CONTROLLER

100$:
	MOVB	#DT$_DZ11,CRB$B_TT_TYPE(R8); CONTROLLER IS DZ11
;
; INIT DZ-11 INTERRUPT VECTORS
; 	THIS IS DONE HERE TO ALLOW THE DRIVER TO SERVICE INTERUPTS
; FOR BOTH THE DZ-11 AND DZ-32 BETWEEN CONTROLER AN UNIT INIT.
;
	MOVAL	DZ11$INTINP,CRB$L_INTD+4(R8)	; INIT RECEIVER VECTOR
	MOVAL	DZ11$INTOUT,CRB$L_INTD2+4(R8)	; INIT TRANSMITTER VECTOR

	CLRW	CRB$B_DZ_RING(R8)	; RESET CURRENT DZ-11 MODEM STATE
	RSB

110$:	;DZ-32 CONTROLLER SPECIFIC INIT
.if ndf DZV
	
	MOVB	#DT$_DZ32,CRB$B_TT_TYPE(R8)	; CONTROLLER IS DZ-32
	CLRB	IDB$B_TT_ENABLE(R5)		; RESET DZ-32 LINE ENABLE
	MOVB	IDB$B_TT_ENABLE(R5),7(R4) 	; RESET TRANSMIT LINE ENABLES
;
; INIT DZ-32 ALTERNATE INTERRUPT VECTORS
;
	MOVAL	DZ32$INTINP,CRB$L_INTD+4(R8)	; INIT RECEIVER VECTOR
	MOVAL	DZ32$INTOUT,CRB$L_INTD2+4(R8)	; INIT TRANSMITTER VECTOR
.endc
	RSB

DZ$CTRL_ERROR:
	RSB
	
	.PAGE
	.SBTTL	UNIT INITIALIZATION
;++
; DZ$INITLINE - UNIT INITIALIZATION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS A SIMPLE UNIT INITIALIZATION.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R5 ARE PRESERVED.
;--

DZ$INITLINE::	

	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS

.IF NDF DZV	; IF NOT DZV

	MOVAL	DZ32$VEC,R0		; SET DZ-32 PORT VECTOR TABLE
	CMPB	#DT$_DZ32,CRB$B_TT_TYPE(R4) 	; IS IT DZ-32 ?
	BEQL	5$			; YES	

.ENDC ; END OF DZ32 CODE

	MOVAL	DZ11$VEC,R0		; SET DZ-11 PORT VECTOR TABLE
5$:	CLASS_UNIT_INIT
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5); SET ONLINE
10$:	ASHL	UCB$W_UNIT(R5),#1,R3	; BUILD UNIT'S BIT MASK
	MOVW	R3,UCB$W_TT_UNITBIT(R5)	; SAVE IT
	MOVL	UCB$L_TT_CLASS(R5),R1	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R1)	; INIT UCB FIELDS
20$:
	JSB	DZ$SET_LINE		; INIT SPEED/PARITY
	
	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS

.IF NDF DZV	; IF NOT DZV

	CMPB	#DT$_DZ11,CRB$B_TT_TYPE(R4)	; CONTROLLER DZ11?
	BEQL	25$			; YES


;
; INIT RECEIVER MODEM STATUS FOR DZ-32
;
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; GET CSR ADDRESS
	
; WAIT TILL MODEM CONTROL READY FOR COMMNAD

	TIMEWAIT #500,#DZLCS1$M_ACK,4(R4),W,.TRUE.
	BLBC	R0,DZ$UNIT_ERROR
	MOVW	UCB$W_UNIT(R5),4(R4)		; REQUEST STATUS ON LINE

; WAIT FOR COMPLETION

	TIMEWAIT #500,#DZLCS1$M_ACK,4(R4),W,.TRUE. 
	BLBC	R0,DZ$UNIT_ERROR
	MOVB	4(R4),UCB$B_TT_DS_RCV(R5)	; UPDATE RECEIVER MODEM STATUS

25$:
.ENDC	; END OF DZ32 CODE

	PUSHL	R2
	MOVZBL	#MODEM$C_INIT,R1	; ASSUME INIT MODEM PROTOCOL
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_DS_TRAN(R0)	; INVOKE TO INIT MODEM PROTOCOL
	POPL	R2
30$:
	BBC	#UCB$V_POWER,UCB$W_STS(R5),40$; DID WE DETECT A POWER FAIL
	MOVL	UCB$L_TT_CLASS(R5),R0	; GET THE CLASS VECTOR TABLE ADDRESS
	JMP	@CLASS_POWERFAIL(R0)	; AND GOTO THE POWERFAIL CODE
40$:	RSB
;
; ERROR DETECTED DURING INITIALIZATION
;

DZ$UNIT_ERROR:
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5)	; UNIT NOT ON LINE
	RSB
	.PAGE
	.SBTTL	MAINTENANCE ROUTINES
;++
; DZ$MAINT - MAINTENANCE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS MAINTENANCE FUNCTIONS FOR THE DZ .
;
;
; INPUTS:
;
;	R5 = UBC ADDRESS
;	UCB$B_TT_MAINT = FUNCTION TO BE PERFORMED
;
; OUTPUTS:
;
;--
.IF NDF	DZV
DZ32$MAINT:
	BITB	#IO$M_LOOP@-7,-			; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	5$				; NO
	MOVZBL	#^X40,R2			; SPECIFY LOOPBACK CODE
	BRB	10$
5$:
	BITB	#IO$M_UNLOOP@-7,-		; RESET LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	15$				; NO
	MOVZWL	#^X7200,R2			; SPECIFY UNLOOP CODE (BOTH)
10$:
	JSB	DZ32$DS_SET			; UPDATE CONTROLLER
	MOVZBL	#1,R0				; INDICATE SUCCESS
	RSB
15$:
	BITB	#IO$M_LOOP_EXT@-7,-		; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	20$				; NO
	MOVZBL	#^X72,R2			; SPECIFY LOOPBACK CODE
	BRB	10$

20$:						; CHECK OTHER FUNCTIONS
.ENDC
DZ11$MAINT:
	BITB	#IO$M_LINE_OFF@-7,-		; LINE OFF
		UCB$B_TT_MAINT(R5)
	BEQL	10$				; NO
	BISB	#UCB$M_TT_DSBL,-		; DISABLE LINE
		UCB$B_TT_MAINT(R5)
	BRB	20$
10$:
	BITB	#IO$M_LINE_ON@-7,-			; LINE ON
		UCB$B_TT_MAINT(R5)
	BEQL	30$				; NO
	BICB	#UCB$M_TT_DSBL,-		; REENABLE LINE
		UCB$B_TT_MAINT(R5)
20$:
	JSB	DZ$SET_LINE			; IMPLEMENT FUNCTION
	MOVZBL	#1,R0
	RSB
30$:
	CLRL	R0
	RSB


	.PAGE
	.SBTTL	OUTPUT MODEM CONTROL
;++
; DZ$DS_SET - SET OUTPUT MODEM SIGNALS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE OUTPUT MODEM SIGNALS FOR THE SPECIFIED UNIT
;
; INPUTS:
;
;	R2 = LOW BYTE - SIGNALS TO ACTIVATE
;	     HIGH BYTE- SIGNALS TO DEACTIVATE
;	
;	R5 = UBC ADDRESS
;	
; OUTPUTS:
;
;	R0-R3 ARE USED.
;--

DZ11$DS_SET:
	PUSHL	R4			; SAVE 
	BISB	R2,UCB$B_TT_DS_TX(R5)	; SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		; ACCESS SIGNALS TO RESET
	BICB	R2,UCB$B_TT_DS_TX(R5)	; RESET THEM
	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3
					; GET CSR ADDRESS
	EXTZV	#TT$V_DS_DTR,#1,UCB$B_TT_DS_TX(R5),R1
					; GET CURRENT DTR FOR LINE
	ASHL	UCB$W_UNIT(R5),R1,R1	; SHIFT TO RELATIVE LINE POSITION
	BICB	UCB$W_TT_UNITBIT(R5),CRB$B_DZ_DTR(R4)
					; RESET CURRENT DTR FOR THAT LINE
	BISB	R1,CRB$B_DZ_DTR(R4)	; SET IT IF NEED BE
	MOVB	CRB$B_DZ_DTR(R4),5(R3)	; UPDATE DTR STATUS FOR LINES
	POPL	R4
	RSB
.IF NDF DZV
DZ32$DS_SET:
	PUSHL	R4			; SAVE 
	BISB	R2,UCB$B_TT_DS_TX(R5)	; SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		; ACCESS SIGNALS TO RESET
	BICB	R2,UCB$B_TT_DS_TX(R5)	; RESET THEM
	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3
	TIMEWAIT #100,#DZLCS1$M_ACK,4(R3),W,.TRUE.	; WAIT FOR READY
	MOVZWL	UCB$B_TT_DS_TX-1(R5),-(SP)		; CREATE TEMP LOCATION
	MOVB	UCB$W_UNIT(R5),(SP)	; SET UNIT NUMBER
	BISW	#DZLCS1$M_ACK,(SP)	; ENABLE NEW OUTPUT SIGNALS
	CVTLW	(SP)+,4(R3)		; SET NEW OUPUT MODEM SIGNALS
	POPL	R4
	RSB
.ENDC
	.PAGE
	.SBTTL	DZ-11 MODEM POLLER
;++
; DZ$TIMER - POLL FOR DZ-11 MODEM TRANSITIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CHECKS FOR DZ-11 CONTROLLER MODEM
; TRANSITION. IT UPDATES THE INPUT MODEM STATUS FOR EACH
; LINE AND CALLS THE CLASS TRANSITION ROUTINE FOR EACH LINE WITH
; A CHANGE.
;
; INPUTS:
;
;	R5 - TQE ADDRESS
;
; OUTPUTS:
;
;	R0 - R4 DESTROYED
;	
;--

DZ$TIMER:
	PUSHR	#^M<R5,R6>		
	MOVAL	DZ$L_DIALUP,R4		; GET DZ TIMER LIST HEAD
5$:
	MOVL	(R4),R4			; GET NEXT CRB ADDRESS
	BNEQ	15$			; PROCESS LINES FOR THIS CRB
	POPR	#^M<R5,R6>		;  RESTORE REGISTERS
	RSB				; RETURN FROM TIMER IMTERRUPT
;
;	TEST LINES ON THIS CONTROLLER FOR A TRANSITION
;

15$:
	PUSHL	R4			; SAVE TIMER THREAD
	SUBL	#CRB$L_DZ_MODEM,R4	; GET ACTUAL CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3 ; GET CSR ADDRESS
	CMPW	CRB$B_DZ_RING(R4),6(R3)	; ANY TRANSITIONS
	BEQL	60$			; NONE
;
;	FIND WHICH SIGNALS CHANGED AND UPDATE THEM
;
	MOVB	6(R3),R2		; GET NEW RING
	XORB3	R2,CRB$B_DZ_RING(R4),R0	; FIND TRANSITIONED LINES
	MOVB	R2,CRB$B_DZ_RING(R4)	; UPDATE CURRENT RING
	MOVB	7(R3),R2		; GET NEW CARRIER
	XORB3	R2,CRB$B_DZ_CARRIER(R4),R6
	BISB	R6,R0			; FLAG LINES WITH TRANSITIONED CARRIER
	MOVB	R2,CRB$B_DZ_CARRIER(R4)	; UPDATE CURRENT CARRIER
;
;	PROCESS TRANSITIONED LINES
;

50$:	FFS	#0,#8,R0,R1		; FIND NEXT LINE NEEDING SERVICE
	BEQL	60$			; DONE
	BBCC	R1,R0,55$		; RESET ATTENTION BIT FOR THIS LINE
55$:
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R6
	MOVL	IDB$L_UCBLST(R6)[R1],R5	; GET UCB FOR THAT LINE
	BEQL	50$			; NONE
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),50$
					; SKIP IF NOT MODEM LINE
	DSBINT	UCB$B_DIPL(R5)			; RAISE TO DEVICE IPL
	EXTZV	R1,#1,CRB$B_DZ_RING(R4),R6	; GET RING FOR THAT LINE
	INSV	R6,#TT$V_DS_RING,#1,-		; UPDATE IT IN UCB
		UCB$B_TT_DS_RCV(R5)
	EXTZV	R1,#1,CRB$B_DZ_CARRIER(R4),R6	; GET CD FOR THAT LINE
	INSV	R6,#TT$V_DS_CARRIER,#1,-	; UPDATE IT IN UCB
		UCB$B_TT_DS_RCV(R5)
	BISB	#<TT$M_DS_DSR!TT$M_DS_CTS>,-	; ASSUME CTS AND DSR ALWAYS SET
		UCB$B_TT_DS_RCV(R5)
	MOVB	UCB$B_TT_DS_RCV(R5),R2	; GET CURRENT RECV MODEM STATUS
	MOVZBL	#MODEM$C_DATASET,R1	; SIGNAL DATASET TRANSITION
	MOVL	UCB$L_TT_CLASS(R5),R6	; GET CLASS VECTOR TABLE
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE VOLITAL REGISTERS
	JSB	@CLASS_DS_TRAN(R6)	; SIGNAL TRANSITION
	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE REGISTERS
	ENBINT				; RESTORE IPL
	BRB	50$

60$:
	POPL	R4			; RESTORE TIMER THREAD
	BRW	5$


	.PAGE
	.SBTTL	RECEIVER INTERRUPT SERIVCE
;++
; DZ$INTINP - DZ RECEIVER READY INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CHARACTER IS AVAILABLE IN THE UNIT'S
; SILO. THE CHARACTER IS EXTRACTED AND IS PASSED TO THE ASSOCIATED
; CLASS DRIVER. IF THE CLASS DRIVER RETURNS CHARACTERS(S) THEN NEW
; OUTPUT IT INITIATED (NORMALLY ECHO).
;
; INPUTS:
;
;	00(SP) = ADDRESS OF IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED WHEN THE SILO IS EMPTY.
;
;--
DZ11$INTINP::				; DZ-11 INPUT INTERRUPTS
;
; GET THE CSR ADDRESS
;
	MOVL	@(SP)+,R4		; GET THE IDB ADDRESS
	PUSHL	R4			; SAVE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE CHARACTER FROM THE INTERFACE
;
25$:	MOVW	2(R0),R3		; GET THE CHARACTER,ERRORS AND LINE NUMBER
	BGEQ	100$			;SILO EMPTY
	BITW	#<DZRCV$M_PARERR>!-
		<DZRCV$M_OVERRUN>!-
		<DZRCV$M_FRAMER>,R3	;ERRORS?
	BNEQ	50$			;YES,PROCESS THEM
27$:	ASHL	#-8,R3,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		; 
	MOVZBL	R3,R3			; CLEAR THE HIGH BYTES OF CHARACTER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB FOR THAT LINE
	BEQL	25$			; IF EQL THEN NOT THERE
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	TSTB	UCB$B_TT_OUTYPE(R5)	; DID HE RETURN ANYTHING TO OUTPUT
	BLEQ	40$			; NONE OR STRING OUTPUT
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE THE CHARACTER IN TANK
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BISW	UCB$W_TT_UNITBIT(R5),4(R0)	;  ENABLE LINE
30$:	MOVL	(SP),R4			; GET IDB ADDRESS
	BRB	25$			; CONTINUE
40$:
	BEQL	30$			; NO CHARACTER
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST
		UCB$W_TT_HOLD(R5)
	BISW	UCB$W_TT_UNITBIT(R5),4(R0)	;  ENABLE LINE
	BRB	30$
;
; SILO EMPTY OR CHARACTER IN ERROR
;
50$:
;
; PROCESS PARITY, FRAME OR OVERRUN ERROR
;
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5; GET UCB ADDRESS
	BEQL	70$			; IF EQL THEN NO UCB
	MOVL	UCB$L_TT_CLASS(R5),R2	; GET CLASS DISPATCH

60$:	JSB	@CLASS_READERROR(R2)	; SIGNAL ERROR
	BNEQ	27$			; BRANCH WITH CHARACTER TO MAIN PATH
70$:	BITW	#^X080,(R0)		; VALID CHARACTER IN SILO NOW?
	BNEQ	30$			; IF NEQ THEN YES
100$:	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI

	.PAGE
.IF NDF DZV
;
; DZ-32 INPUT INTERRUPT SERVICE
;

DZ32$INTINP::				; DZ-32 INPUT INTERRUPTS
;
; GET THE CSR ADDRESS
;
	MOVL	@(SP)+,R4		; GET THE IDB ADDRESS
	PUSHL	R4			; SAVE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
	BICW	#<<DZCSR$M_RCVINT>!-	; DISABLE RECEIVER INTERRUPTS
		<DZCSR$M_DS_ENAB>>,-	; DISABLE DZ-32 DATA SET INTERRUPTS
		(R0)			; DZ-32 during the interrupt service routine
;
; GET THE CHARACTER FROM THE INTERFACE
;
25$:	MOVW	2(R0),R3		; GET THE CHARACTER,ERRORS AND LINE NUMBER
	BGEQ	100$			;SILO EMPTY
	BITW	#<DZRCV$M_PARERR>!-
		<DZRCV$M_OVERRUN>!-	;ERRORS?
		<DZRCV$M_FRAMER>,R3	;ERRORS?
	BNEQ	50$			;YES,PROCESS THEM
27$:	ASHL	#-8,R3,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		; 
	MOVZBL	R3,R3			; CLEAR THE HIGH BYTES OF CHARACTER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB FOR THAT LINE
	BEQL	25$			; IF EQL THEN NOT THERE
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	TSTB	UCB$B_TT_OUTYPE(R5)	; DID HE RETURN ANYTHING TO OUTPUT
	BLEQ	40$			; NONE OR STRING OUTPUT
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE THE CHARACTER IN TANK
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
28$:
	MOVL	(SP),R4			; RESTORE IDB ADDRESS
	BISB	UCB$W_TT_UNITBIT(R5),-	;  ENABLE LINE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)

30$:	MOVL	(SP),R4			; GET IDB ADDRESS
	BRB	25$			; CONTINUE
40$:
	BEQL	30$			; NO CHARACTER
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST
		UCB$W_TT_HOLD(R5)
	BRB	28$
;
; SILO EMPTY OR CHARACTER IN ERROR
;
50$:
;
; PROCESS PARITY, FRAME OR OVERRUN ERROR
;
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET UCB ADDRESS
	BEQL	70$			; IF EQL THEN NO UCB
	MOVL	UCB$L_TT_CLASS(R5),R2	; GET CLASS DISPATCH

60$:	JSB	@CLASS_READERROR(R2)	; SIGNAL ERROR
	BNEQ	27$			; BRANCH WITH CHARACTER TO MAIN PATH
70$:	BITW	#^X080,(R0)		; VALID CHARACTER IN SILO NOW?
	BNEQ	30$			; IF NEQ THEN YES
100$:
	MOVW	(R0),R3			; TEST FOR MODEM TRANSITION
	BBS	#DZCSR$V_DS_CHG,R3,200$	; BRANCH IF MODEM TRANSITION
	BISW	#<<DZCSR$M_RCVINT>!-	;  ENABLE RECEIVER INTERRUPTS
		<DZCSR$M_DS_ENAB>>,-	;  ENABLE DZ-32 DATA SET INTERRUPTS
		(R0)			; DZ-32 BEFORE EXITING
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI
200$:	PUSHL	R0			; SAVE R0
	MOVB	6(R0),R3		; GET NEW RECEIVE MODEM SIGNALS
	BICL3	#^C<7>,R3,R2		; ISOLATE UNIT NUMBER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET ASSOCAITED UCB
	BEQL	110$			; NONE
	MOVB	R3,UCB$B_TT_DS_RCV(R5)	; UPDATE INPUT MODEM SIGNALS
	MOVZBL	R3,R2			; LOAD ARGUMENT
	MOVZBL	#MODEM$C_DATASET,R1	; MODEM TRANSITION
	MOVL	UCB$L_TT_CLASS(R5),R3	; ACCESS CLASS VECTORS
	JSB	@CLASS_DS_TRAN(R3)	; SIGNAL TRANSITION
110$:	POPL	R0			; RESTORE R0
	BRW	30$			; DISMISS INTERRUPT
.ENDC
	.PAGE
	.SBTTL	 START I/O ROUTINE
;++
; DZ$STARTIO - START I/O OERATION ON DZ
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED FROM THE DEVICE INDEPENDENT TERMINAL STARTIO
; ROUTINE TO ENABLE OUTPUT INTERRUPTS ON AN IDLE DZ UNIT.
;
; INPUTS:
;
;	R3 =	CHARACTER	AND	CC = PLUS
;		ADDRESS		AND	CC = NEGATIVE
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
DZ11$STARTIO::				; START I/O ON UNIT
	BGEQ	20$			; SINGLE CHARACTER
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
10$:	MOVL	UCB$L_CRB(R5),R1	; GET CRB OF UNIT
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1; GET CSR
	BISW	UCB$W_TT_UNITBIT(R5),4(R1)	;  ENABLE LINE
	RSB				; RETURN TO CALLER
20$:
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE OUTPUT CHARACTER
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BRB	10$

.IF NDF DZV
DZ32$STARTIO::				; START I/O ON UNIT
	BGEQ	20$			; SINGLE CHARACTER SPECIFIED
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
10$:	MOVL	UCB$L_CRB(R5),R1	; GET CRB OF UNIT
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R4	; GET IDB ADDRESS
	MOVL	(R4),R1			; GET CSR ADDRESS
	BISB	UCB$W_TT_UNITBIT(R5),IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R1)
	RSB				; RETURN TO CALLER
20$:
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE OUTPUT CHARACTER
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BRB	10$
.ENDC
	.PAGE
	.SBTTL	PORT ROUTINES  STOP,RESUME,XON,XOFF
;++
; DZ$XOFF -	SEND XOFF
; DZ$XON -	SEND XON
; DZ$STOP -	STOP OUTPUT
; DZ$ABORT -	ABORT CURRENT OUTPUT
; DZ$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
	.ENABLE	LSB
;
; SCHEDULE XOFF TO BE SEND
;
; INPUTS:
;	R3 - CHARACTER TO BE SENT AS FLOW CONTROL
;
DZ11$XOFF:
;
; SCHEDULE XON TO BE SENT
;
DZ11$XON:
	BISW	#TTY$M_TANK_PREMPT,UCB$W_TT_HOLD(R5)	; SCHEDULE XON
	MOVB	R3,UCB$B_TT_PREMPT(R5)			; SAVE THE CHARACTER

	BBS	#UCB$V_INT,UCB$W_STS(R5),10$		; IF OUTPUT ACTIVE,
							; FINISHED
	PUSHL	R1					; SAVE A REGISTER
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1		; GET CSR ADDRESS
	BISW	UCB$W_TT_UNITBIT(R5),4(R1)			; ENABLE LINE
	POPL	R1
	BBSS	#UCB$V_INT,UCB$W_STS(R5),10$		; SHOW OUTPUT ACTIVE
10$:
	RSB
	.DISABLE	LSB
;
; STOP PORT OUTPUT
;
DZ$STOP:
	BISW	#TTY$M_TANK_STOP,-			; SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	RSB
;
; ABORT ANY CURRENT PORT OUTPUT ACTIVITY
;
DZ$ABORT:
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),-	; RESET BURST ACTIVE
		10$					; 
10$:
	TIMSET	1					; SET A TIMEOUT
							; IN CASE OUTPUT ACTIVE
	RSB

;
; RESUME PREVIOUSLY STOPPED PORT OUTPUT
;
DZ11$RESUME:
	PUSHL	R1					; SAVE A REGISTER
5$:	BICW	#TTY$M_TANK_STOP-
		,UCB$W_TT_HOLD(R5)			; RESET STOP CONDITIONS
	BBS	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),20$	; BURST IN PROGRESS
10$:							; CHAR IN TANK OR OTHER
	TIMSET	1
	BRB	30$
20$:
	MOVZWL	UCB$W_TT_OUTLEN(R5),R1			; GET NUMBER CHARACTERS
	TIMSET	R1,R1					;
30$:
	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1		; GET CSR ADDRESS
	BISW	UCB$W_TT_UNITBIT(R5),4(R1)			; ENABLE LINE
	BBSS	#UCB$V_INT,UCB$W_STS(R5),40$		; SHOW OUTPUT ACTIVE
40$:
	POPL	R1
	RSB
.IF NDF DZV
	.ENABLE	LSB
;
; SCHEDULE XOFF TO BE SENT
;
DZ32$XOFF:
;
; SCHEDULE XON TO BE SENT
;
DZ32$XON:
	BISW	#TTY$M_TANK_PREMPT,UCB$W_TT_HOLD(R5)	; SCHEDULE XON
	MOVB	R3,UCB$B_TT_PREMPT(R5)			; SAVE THE CHARACTER
							; IN THE PREMPT SLOT
	BBS	#UCB$V_INT,UCB$W_STS(R5),10$		; IF OUTPUT ACTIVE,
							; FINISHED
	PUSHR	#^M<R1,R4>				; SAVE  REGISTERS
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R4		; GET IDB ADDRESS
	MOVL	(R4),R1					; GET CSR ADDRESS
	BISB	UCB$W_TT_UNITBIT(R5),IDB$B_TT_ENABLE(R4)	; ENABLE LINE
	MOVB	IDB$B_TT_ENABLE(R4),7(R1)
	POPR	#^M<R1,R4>
	BBSS	#UCB$V_INT,UCB$W_STS(R5),10$		; SHOW OUTPUT ACTIVE
10$:
	RSB
	.DISABLE	LSB

;
; RESUME STOPPED OUTPUT
;
DZ32$RESUME:
	PUSHR	#^M<R1,R4>				; SAVE REGISTERS
5$:	BICW	#TTY$M_TANK_STOP-
		,UCB$W_TT_HOLD(R5)			; RESET STOP CONDITIONS
	BBS	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),20$	; BURST IN PROGRESS
10$:							; CHAR IN TANK OR OTHER
	TIMSET	1					; TIME OUT
	BRB	30$
20$:
	MOVZWL	UCB$W_TT_OUTLEN(R5),R1
	TIMSET	R1,R1					; SET THE TIMER
30$:
	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R4		; GET IDB ADDRESS
	MOVL	(R4),R1					; GET CSR ADDRESS
	BISB	UCB$W_TT_UNITBIT(R5),IDB$B_TT_ENABLE(R4)	; ENABLE LINE
	MOVB	IDB$B_TT_ENABLE(R4),7(R1)
	BBSS	#UCB$V_INT,UCB$W_STS(R5),40$		; SHOW OUTPUT ACTIVE
40$:
	POPR	#^M<R1,R4>
	RSB
.ENDC
	.PAGE
	.SBTTL	OUTPUT INTERRUPT SERVICE
;++
; DZ$INTOUT - DZ-11 OUTPUT INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE DZ-11 FINDS A LINE ENABLED
; AND AN EMPTY UART. THE CORRESPONDING UCB IS FOUND AND 
; ANY OUTSTANDING PORT OUTPUT IS DONE. WHEN ALL OUTSTANDING PORT
; OUTPUT IS COMPLETED, THE CLASS DRIVER IS CALLED TO RETURN THE NEXT
; CHARACTER OR STRING TO BE OUTPUT. IF NO MORE OUTPUT IS FOUND, THEN
; THE LINE IS DISBALED.
;
; INPUTS:
;
;	SP(00) = ADDRESS OF THE IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 SAVED ON THE STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED.
;
;--
DZ11_OUT_EXIT:				; EXIT OUTPUT INTERRUPT
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				; DISMISS INTERRUPT

DZ11$INTOUT::				; DZ-11 OUTPUT INTERRUPT SERVICE

DZ11_OUT_LOOP:
	MOVL	@(SP),R4		; GET THE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE LINE INFO FROM THE CSR
;

	MOVW	(R0),R2			; GET THE CSR VALUE
	BGEQ	DZ11_OUT_EXIT		; NO MORE LINES
	ASHL	#-8,R2,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5; GET THE UCB ADDRESS
	BEQL	DZ11_OUT_LOOP		; IF EQL THEN DISMISS 
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	DZ11_BURST		; YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-			; DISPATCH
		DZ11_PREMPT,-			; SEND PREMPT CHARACTER
		DZ11_STOP,-			; STOP OUTPUT
		DZ11_CHAR,-			; CHAR IN TANK
		DZ11_BURST,-			; BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	CASEB	UCB$B_TT_OUTYPE(R5),#-1,#1; OPTOMIZE FOR THE SINGLE
					; CHARACTER CASE BY SETTING THE
					; LIMIT TO 1
1$:	.WORD	DZ11_START_BURST-1$	; BURST SPECIFIED
	.WORD	50$-1$			; NONE
;
; OUTPUT A CHARACTER TO THE DZ-11
;
20$:	MOVZBW	R3,6(R0)		; OUTPUT CHARACTER
	BRB	DZ11_OUT_LOOP
;
; DISABLE OUTPUT ON THIS LINE
;
50$:
	BBS	#UCB$V_INT,-		; IF INT EXP, THEN DON'T RESET,
		UCB$W_STS(R5),DZ11_OUT_LOOP
					; COULD HAVE BEEN SET DURING CALLBACK

	BICW	UCB$W_TT_UNITBIT(R5),4(R0)	; RESET THE OUTPUT ENABLE
	BRB	DZ11_OUT_LOOP


DZ11_START_BURST:
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
;
;  CONTINUE BURST OUTPUT
;
DZ11_BURST:
	MOVB	@UCB$L_TT_OUTADR(R5),-	; OUTPUT NEXT BYTE
		6(R0)		
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	DZ11_OUT_LOOP		; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
	BRW	DZ11_OUT_LOOP
;
; OUTPUT SINGLE CHARACTER
;
DZ11_CHAR:
	MOVB	UCB$W_TT_HOLD(R5),6(R0)	; OUTPUT CHAR IN TANK
	BICW	#TTY$M_TANK_HOLD,-	; SHOW TANK EMPTY
		UCB$W_TT_HOLD(R5)	
	BRW	DZ11_OUT_LOOP
;
; STOP THE OUTPUT
;
DZ11_STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; RESET OUTPUT ACTIVE
	BICW	UCB$W_TT_UNITBIT(R5),4(R0)	; RESET THE OUTPUT ENABLE
	BRW	DZ11_OUT_LOOP

	.ENABLE	LSB
;
; SEND XON OR XOFF CHARACTER
;

DZ11_PREMPT:
	BICW	#TTY$M_TANK_PREMPT,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	MOVB	UCB$B_TT_PREMPT(R5),6(R0); OUTPUT CHARACTER
	BRW	DZ11_OUT_LOOP
	.DISABLE	LSB

	.PAGE
.IF NDF DZV
;
; DZ-32 OUTPUT INTERRUPT SERVICE CODE
;

DZ32_OUT_EXIT:				; EXIT OUTPUT INTERRUPT
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				; DISMISS INTERRUPT

DZ32$INTOUT::				; DZ-32 OUTPUT INTERRUPT SERVICE
DZ32_OUT_LOOP:
	MOVL	@(SP),R4		; GET THE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE LINE INFO FROM THE CSR
;

	MOVW	(R0),R2			; GET THE CSR VALUE
	BGEQ	DZ32_OUT_EXIT
	ASHL	#-8,R2,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5; GET THE UCB ADDRESS
	BEQL	DZ32_OUT_LOOP		; IF EQL THEN DISMISS 
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	DZ32_BURST		; YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-			; DISPATCH
		DZ32_PREMPT,-			; SEND PREMPT CHARACTERS
		DZ32_STOP,-			; STOP OUTPUT
		DZ32_CHAR,-			; CHAR IN TANK
		DZ32_BURST,-			; BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	CASEB	UCB$B_TT_OUTYPE(R5),#-1,#1; OPTOMIZE FOR THE SINGLE
					; CHARACTER CASE BY SETTING THE
					; LIMIT TO 1
1$:	.WORD	DZ32_START_BURST-1$	; BURST SPECIFIED
	.WORD	50$-1$			; NONE
;
; OUTPUT A CHARACTER TO THE DZ-32
;
20$:	MOVB	R3,6(R0)		; OUTPUT CHARACTER
	BRW	DZ32_OUT_LOOP

;
; DISABLE OUTPUT ON THIS LINE
;
50$:
	BBS	#UCB$V_INT,-		; IF INT EXP, THEN DON'T RESET,
		UCB$W_STS(R5),DZ32_OUT_LOOP
					; COULD HAVE BEEN SET DURING CALLBACK

	MOVL	@(SP),R4		; GET IDB ADDRESS
	BICB	UCB$W_TT_UNITBIT(R5),-	; RESET THE OUTPUT ENABLE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)
	BRW	DZ32_OUT_LOOP


DZ32_START_BURST:
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
DZ32_BURST:
	MOVB	@UCB$L_TT_OUTADR(R5),-	; OUTPUT NEXT BYTE
		6(R0)		
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	60$			; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
60$:	BRW	DZ32_OUT_LOOP
;
; OUTPUT SINGLE CHARACTER
;
DZ32_CHAR:
	MOVB	UCB$W_TT_HOLD(R5),6(R0)	; OUTPUT CHAR IN TANK
	BICW	#TTY$M_TANK_HOLD,-	; SHOW TANK EMPTY
		UCB$W_TT_HOLD(R5)	
	BRW	DZ32_OUT_LOOP
;
; STOP OUTPUT
;
DZ32_STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; RESET OUTPUT ACTIVE
	MOVL	@(SP),R4		; GET IDB ADDRESS
	BICB	UCB$W_TT_UNITBIT(R5),-	; RESET THE OUTPUT ENABLE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)
	BRW	DZ32_OUT_LOOP

	.ENABLE	LSB
;
; SEND XON OR XOFF
;
DZ32_PREMPT:
	BICW	#TTY$M_TANK_PREMPT,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	MOVB	UCB$B_TT_PREMPT(R5),6(R0); OUTPUT CHARACTER
	BRW	DZ32_OUT_LOOP


	.DISABLE	LSB
.ENDC
	.PAGE
	.SBTTL	SET SPEED, PARITY PARAMETERS

;++
; DZ$SET_LINE - RESET SPEED, PARITY
;
; FUNCTIONAL DESCRIPTION:
;
; INPUTS:
;
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;
;	R4 USED
;--

DZ$SET_LINE:
	MOVL	UCB$L_CRB(R5),R4	; ADDRESS CRB
;
;	SET UP LINE SPEED AND PARITY
;
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; GET THE CSR ADDRESS VIA CRB
	CLRL	-(SP)				; RESET A TEMPORARY LOCATION
	SUBB3	#1,UCB$W_TT_SPEED(R5),1(SP)	; ADJUST DATA BASE SPEED
	MOVB	UCB$B_TT_PARITY(R5),(SP); SET PARITY,STOP, CHARACTER SIZE
	BICW	#^XF007,(SP)		; CLEAR SPECIAL FIELDS
	BBS	#UCB$V_TT_DSBL,-	; SKIP CLOCK ENABLE IF LINE DISABLED
		UCB$B_TT_MAINT(R5),3$
	BISW	#<DZLPR$M_CLOCK>,(SP)
3$:
	BISW	UCB$W_UNIT(R5),(SP)	; SET LINE NUMBER
	BITW	#DZCSR$M_MODE,(R4)	; DZ32 CONTROLLER?
	BNEQ	10$			; YES
5$:
	CVTLW	(SP)+,2(R4)		; INSERT AS LINE PARAMETER
	RSB

;	 HANDLE DZ-32 SPECIFIC FUNCTIONS
10$:
	CMPB	UCB$W_TT_SPEED(R5),-	; TRANSMIT/RECEIVE THE SAME
		UCB$W_TT_SPEED+1(R5)
	BEQL	5$			; YES, NO SPLIT SPEED
	TSTB	UCB$W_TT_SPEED+1(R5)	; RECEIVE SPEED SPECIFIED?
	BEQL	5$			; NO, NO SPLIT SPEED

; SET SPLIT SPEED
	
	BISW	#DZLPR$M_SPLIT,(SP)	; SET SPLIT SPEED BIT
	BRB	5$			; COMPLETE SETUP

	.PAGE

	.SBTTL	INITIALIZE DZ-11 MODEM POLLING

;++
; DZ$SET_MODEM - INIT MODEM POLLING
;
; FUNCTIONAL DESCRIPTION:
;
; INIT DZ-11 MODEM TRANSITION POLLING IF NOT ALREADY ACTIVE. LINK CRB
; FOR CURRENT LINE INTO MODEM TRANSITION POLLING LIST
;
; INPUTS:
;
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;
;	R0-R4 USED
;--

DZ11$SET_MODEM:
	MOVL	UCB$L_CRB(R5),R4	; ADDRESS CRB
	TSTL	DZ$L_DIALUP		; DZ-11 POLLING ALREADY ACTIVE?
	BNEQ	5$			; YES, SKIP STARTUP
	PUSHR	#^M<R3,R4,R5>
	MOVAL	DZ$TIMQUENT,R5		; ADDRESS OF TIMER ENTRY
	MOVB	#IPL$_QUEUEAST,TQE$B_RQTYPE(R5) ; SET FORK IPL
	PUSHAB	4$			; RETURN ADDRESS
	BRW	30$			; QUEUE FORK
4$:	POPR	#^M<R3,R4,R5>	
5$:
	MOVAL	CRB$L_DZ_MODEM(R4),R3	; ADDRESS OF DZ CRB THREAD
	MOVAL	DZ$L_DIALUP,R1		; ADDRESS OF DZ TIMER LIST HEAD
	MOVL	R1,R2
;
; LINK CRB INTO DZ-11 MODEM POLLER LIST IF NEEDED
;
10$:
	CMPL	(R2),R3			; IS CRB ON LIST
	BEQL	20$			; YES, DONE
	MOVL	(R2),R2			; POINT TO NEXT CRB
	BNEQ	10$			; LOOK FOR NEXT
	MOVL	(R1),(R3)		; LINK CRB AT LIST HEAD
	MOVL	R3,(R1)			;
20$:
	RSB
30$:
	JSB	G^EXE$FORK		; FORK TO QUEUE TIMER ENTRY
	DSBINT	#IPL$_SYNCH
	MOVAB	W^DZ$TIMER,TQE$L_FPC(R5); ADDRESS OF TIMER SERVICE ROUTINE
	MOVL	G^TTY$GL_DELTA,TQE$Q_DELTA(R5)
					; INTERVAL IS SYSGEN PARAMETER
	MOVB	#TQE$C_SSREPT,TQE$B_RQTYPE(R5)
	MOVQ	G^EXE$GQ_SYSTIME,R0
	ADDL	G^TTY$GL_DELTA,R0
	ADWC	#0,R1
	JSB	G^EXE$INSTIMQ		; INSERT INTO TIMER QUEUE
	ENBINT				; RESTORE IPL
	RSB

	.PAGE

	.PSECT	$$$117_DATA,QUAD
;
;	DZ-11 TIMER DATA STRUCTURES FOR DETECTION OF DZ-11 MODEM TRANSITIONS
;

DZ$L_DIALUP:
		.LONG	0			; LINKED LIST OF DZ-11 CRB'S 
						;  USING MODEM CONTROL
DZ$TIMQUENT:					; TIMER QUE ENTRY USED TO
						; SAMPLE DZ-11 MODEM SIGNALS
						; ON PERIODIC BASIS
	.ALIGN	QUAD
	.BLKB	TQE$C_LENGTH
	STO_TQE	TQE$W_SIZE,WORD,TQE$C_LENGTH,DZ$TIMQUENT
	STO_TQE	TQE$B_TYPE,BYTE,DYN$C_TQE,DZ$TIMQUENT
	STO_TQE	TQE$B_RQTYPE,BYTE,TQE$C_SSREPT,DZ$TIMQUENT


DZ$END:					; End of driver

	.END
